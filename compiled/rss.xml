<?xml version="1.0"?>
<rss version="2.0">  <channel>
    <title>Hugo Zhu</title>
    <link>http://hugozhu.myalert.info</link>
    <pubDate>2014-06-17 09:53:41 +0800</pubDate>
    <item>
      <title>提高Android开发效率的小贴士</title>
      <link>http://hugozhu.myalert.info/2014/02/10/45-android-development-productivity-tips.html</link>
      <pubDate>2014-02-10 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;查看日志-adb-logcat&#34; href=&#34;#查看日志-adb-logcat&#34;&gt;&lt;/a&gt;查看日志 adb logcat&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;下面命令将只显示错误日志，和所有Tag＝mytag的调试日志，-C 会用不同颜色区分不同级别的日志，但只有Android 4.3以后才支持。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;adb logcat [-C] *:E &amp;lt;mytag&amp;gt;:D&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;远程调试-adb-over-tcp&#34; href=&#34;#远程调试-adb-over-tcp&#34;&gt;&lt;/a&gt;远程调试 adb over TCP&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;首先在手机或Pad上执行以下命令（要求root）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;su&#xA;setprop service.adb.tcp.port 5555&#xA;stop adbd&#xA;start adbd&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;再执行下面命令则可以看到手机的网络地址&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;netcfg | grep wlan&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在电脑上则执行&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;adb connect &amp;lt;mobile_phone_ip&amp;gt; 5555&#xA;adb shell&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;安装运行&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gradle installDebug &amp;amp;&amp;amp; adb shell am start -n com.laiwang.protocol.android/.MainActivity&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>拷贝Android应用的数据</title>
      <link>http://hugozhu.myalert.info/2013/11/27/44-copy-android-app-data.html</link>
      <pubDate>2013-11-27 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;有root权限&#34; href=&#34;#有root权限&#34;&gt;&lt;/a&gt;有root权限&lt;/h1&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;adb shell su -c cat /data/data/app.package.name/databases/application.sqlite | sed &#39;s/\r$//&#39; &amp;gt; application.sqlite&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;应用可调试的话&#34; href=&#34;#应用可调试的话&#34;&gt;&lt;/a&gt;应用可调试的话&lt;/h1&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;adb shell&#xA;run-as app.package.name \&#xA;cp /data/data/package.name/databases/application.sqlite /sdcard/&#xA;exit&#xA;adb pull /sdcard/application.sqlite ~/&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;使用备份方法&#34; href=&#34;#使用备份方法&#34;&gt;&lt;/a&gt;使用备份方法&lt;/h1&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;adb backup -f ~/data.ab -noapk app.package.name&#xA;dd if=data.ab bs=1 skip=24 | python -c &amp;quot;import zlib,sys;sys.stdout.write(zlib.decompress(sys.stdin.read()))&amp;quot; | tar -xvf -&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;参考链接&#34; href=&#34;#参考链接&#34;&gt;&lt;/a&gt;参考链接&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://blog.shvetsov.com/2013/02/access-android-app-data-without-root.html&#34;&gt;http://blog.shvetsov.com/2013/02/access-android-app-data-without-root.html&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>在树莓派上使用Phantomjs自动登录微博</title>
      <link>http://hugozhu.myalert.info/2013/07/21/41-use-phantomjs-on-raspberry-pi-to-login-weibo.html</link>
      <pubDate>2013-07-21 12:00:00 +0800</pubDate>
      <description>&#xA;&#xA;&lt;p&gt;&lt;h1&gt;目录：&lt;/h1&gt;&lt;nav&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_0&#34;&gt;Phantomjs&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_1&#34;&gt;代码&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_2&#34;&gt;执行方法&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/nav&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用过新浪开放平台的朋友都知道用户对小应用（用户数较少的）的授权Token很容易&lt;a href=&#34;http://open.weibo.com/wiki/授权机制说明#.E6.8E.88.E6.9D.83.E6.9C.89.E6.95.88.E6.9C.9F&#34;&gt;过期&lt;/a&gt;，自动续期要求授权过的用户在过期前重新打开授权页。如果你想实现一个自动备份自己微博的App，就不得每天（周）自己去访问授权页（想死的心都有了吧？）。这里介绍一种通过脚本自动登录微博获取最新oAuth token的方法（需要微博登录名和密码），合适自己玩。将脚本部署在树莓派上后，我再也不用每周都去登录一次授权页了，只是收到报警消息后（经常是帐号被冻结了）需要手动处理一下。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_0&#34;&gt;Phantomjs&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://phantomjs.org/images/phantomjs-logo.png&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://phantomjs.org/&#34;&gt;Phantomjs&lt;/a&gt; 是一个开源的，没有界面可运行在命令行，跨平台，基于WebKit的全功能浏览器，可以用来做网站自动化测试。从源代码&lt;a href=&#34;http://phantomjs.org/build.html&#34;&gt;编译&lt;/a&gt;比较费时间，可以直接下载&lt;a href=&#34;http://phantomjs.org/download.html&#34;&gt;二进制版本&lt;/a&gt;，树莓派的版本在&lt;a href=&#34;https://github.com/aeberhardo/phantomjs-linux-armv6l&#34;&gt;这里&lt;/a&gt;可下载。Phantomjs下载好了后就一个可执行文件，依赖非常少，我很喜欢这种方式。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_1&#34;&gt;代码&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;以下代码使用提供的微博用户名和密码登录，获得Token后还会打开微博首页看帐号是否被冻结了。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var page = require(&#39;webpage&#39;).create(),&#xA;    system = require(&#39;system&#39;),&#xA;    fs = require(&#39;fs&#39;),&#xA;    address;&#xA;&#xA;var weibo_userid = system.args[1]&#xA;var weibo_passwd = system.args[2]&#xA;&#xA;var startUrl = &amp;quot;https://api.weibo.com/oauth2/authorize?client_id=&amp;lt;your_app_key&amp;gt;&amp;amp;redirect_uri=&amp;lt;your_return_url&amp;gt;/&amp;amp;response_type=token&amp;quot;;&#xA;&#xA;var verify_weibo_freeze = false;&#xA;&#xA;page.onResourceReceived = function (res,network) {&#xA;    if (res.stage == &amp;quot;end&amp;quot;) {&#xA;        // console.log(&amp;quot;\t&amp;lt;-&amp;quot; + res.url);&#xA;        if (res.url.indexOf(&amp;quot;authorize?client_id&amp;quot;)&amp;gt;0) {&#xA;            startUrl = res.url&#xA;        } &#xA;        if (res.url.indexOf(&amp;quot;?access_token&amp;quot;)&amp;gt;0) {&#xA;            var pos1 = res.url.indexOf(&amp;quot;access_token=&amp;quot;)&#xA;            var pos2 = res.url.indexOf(&amp;quot;&amp;amp;&amp;quot;)&#xA;            var access_token = res.url.substring(pos1+&amp;quot;access_token=&amp;quot;.length, pos2)&#xA;            console.log(weibo_userid + &amp;quot; login OK, access_token is: &amp;quot; + access_token)&#xA;            verify_weibo_freeze = true&#xA;        }&#xA;        if (verify_weibo_freeze &amp;amp;&amp;amp; res.url != &amp;quot;http://weibo.com/&amp;quot; &amp;amp;&amp;amp; res.url.indexOf(&amp;quot;http://weibo.com/&amp;quot;)&amp;gt;-1) {&#xA;            var pos1 = res.url.indexOf(&amp;quot;/&amp;quot;,8)&#xA;            var pos2 = res.url.indexOf(&amp;quot;?&amp;quot;)&#xA;            var weibo_name = res.url.substring(pos1+1,pos2)&#xA;            console.log(weibo_name+&amp;quot; status verified OK&amp;quot;)&#xA;            phantom.exit();&#xA;        }&#xA;    }&#xA;};&#xA;&#xA;page.onLoadFinished = function() {&#xA;    if (verify_weibo_freeze) {&#xA;        page.open(&amp;quot;http://weibo.com/&amp;quot;, function() {&#xA;            phantom.exit();&#xA;        })&#xA;    }&#xA;};&#xA;&#xA;page.onConsoleMessage = function(msg) {&#xA;    console.log(msg);&#xA;};&#xA;&#xA;page.open(startUrl, function(status) {&#xA;    if ( status === &amp;quot;success&amp;quot; ) {&#xA;        page.includeJs(&amp;quot;https://ajax.googleapis.com/ajax/libs/jquery/1.6.1/jquery.min.js&amp;quot;, function() {&#xA;            var offset = page.evaluate(function(a,b) {&#xA;                $(&amp;quot;#userId&amp;quot;).val(a)&#xA;                $(&amp;quot;#passwd&amp;quot;).val(b)&#xA;                if ($(&#39;.WB_btn_login&#39;).hasClass(&amp;quot;formbtn_01&amp;quot;)) {&#xA;                    // console.log(&amp;quot;Found button!&amp;quot;)&#xA;                    return $(&#39;.WB_btn_login&#39;).offset()&#xA;                }&#xA;                return undefined&#xA;            }, weibo_userid, weibo_passwd);&#xA;            page.sendEvent(&#39;click&#39;, offset.left + 1, offset.top + 1);&#xA;        });&#xA;    }&#xA;})&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_2&#34;&gt;执行方法&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;timeout 120 phantomjs weibo_login.js &amp;lt;your_weibo_login_id&amp;gt; &amp;lt;your_weibo_login_password&amp;gt;&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;your_weibo_login_id&amp;gt; login OK, access_token is: &amp;lt;your_access_token&amp;gt;&#xA;&amp;lt;your_weibo_login_name&amp;gt; status verified OK&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;使用&lt;code&gt;timeout&lt;/code&gt;要求命令在120秒内完成，防止phantomjs进程遇到问题时一直不退出，实际使用可以用Crontab定时每天执行一次，执行输出可以pipe到另一个脚本，如果不OK则发短信或邮件提示。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>使用夏普GP2Y1010AU0F灰尘传感器检测空气质量</title>
      <link>http://hugozhu.myalert.info/2013/07/21/42-sharp-GP2Y1010AU0F-optical-dust-sensor.html</link>
      <pubDate>2013-07-21 12:00:00 +0800</pubDate>
      <description>&#xA;&#xA;&lt;p&gt;&lt;h1&gt;目录：&lt;/h1&gt;&lt;nav&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_0&#34;&gt;检测原理&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_1&#34;&gt;电路图&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_2&#34;&gt;Arduino 代码&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_3&#34;&gt;参考链接&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/nav&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;夏普&lt;a href=&#34;http://item.taobao.com/item.htm?spm=a230r.1.14.1.X4yMiN&amp;amp;id=25584528001&amp;amp;_u=oqa3375a&#34;&gt;GP2Y1010AU0F&lt;/a&gt;灰尘传感器价格较便宜，能检测出室内空气中的灰尘和烟尘含量。另外还有韩国SYHITECH生产的&lt;a href=&#34;http://item.taobao.com/item.htm?spm=a230r.1.14.9.NNhRMO&amp;amp;id=15543884159&#34;&gt;DSM501A&lt;/a&gt;粉尘传感器也有类似功能。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_0&#34;&gt;检测原理&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;其原理如下图，传感器中心有个洞可以让空气自由流过，定向发射LED光，通过检测经过空气中灰尘折射过后的光线来判断灰尘的含量。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://www.evernote.com/shard/s26/sh/50d1faab-e7fc-45c6-9a0f-2b5f6743ce7f/4422cbee4a324b25d1ebaabba3eb350f/deep/0/www.beck-elektronik.de/fileadmin/templates/beck_folder/opto/sensor/sharp/an-gp2y1010au.pdf.png&#34; width=&#34;500&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_1&#34;&gt;电路图&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://www.evernote.com/shard/s26/sh/d34f08d5-0a93-44cc-b360-0b0686efa11d/e8548764c41977130e79b645e8b82cc3/deep/0/www.beck-elektronik.de/fileadmin/templates/beck_folder/opto/sensor/sharp/an-gp2y1010au.pdf.png&#34; width=&#34;500&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/bmiddle/6bc40342jw1e6x61e41ykj218g0xcamc.jpg&#34; width=&#34;500&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因为数据是通过pin 5的电压模拟信号输出的，而树莓派的引脚不支持模拟信号直接读取（需要增加数模转换芯片），所以先用Arduino来实验。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_2&#34;&gt;Arduino 代码&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://www.evernote.com/shard/s26/sh/5159a7b8-8e50-49ac-9a5f-63deb93c539d/5cee487cce5d3b3cbc530bc9e979908b/deep/0/%E6%88%91%E7%9A%84%E5%BE%AE%E5%8D%9A%20%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A-%E9%9A%8F%E6%97%B6%E9%9A%8F%E5%9C%B0%E5%88%86%E4%BA%AB%E8%BA%AB%E8%BE%B9%E7%9A%84%E6%96%B0%E9%B2%9C%E4%BA%8B%E5%84%BF.png&#34; width=&#34;400&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;根据电路图， 把Arduino和传感器连接起来：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Sharp pin 1 (V-LED)   =&amp;gt; 5V 串联1个&lt;a href=&#34;http://detail.tmall.com/item.htm?id=13437610350&amp;amp;spm=a230r.1.14.1.BiUeau&amp;amp;ad_id=&amp;amp;am_id=&amp;amp;cm_id=140105335569ed55e27b&amp;amp;pm_id=&#34;&gt;150欧姆的电阻&lt;/a&gt;（最好在电阻一侧和GND之间再串联一个&lt;a href=&#34;http://detail.tmall.com/item.htm?id=13661538754&amp;amp;spm=a230r.1.14.17.KlljiT&amp;amp;ad_id=&amp;amp;am_id=&amp;amp;cm_id=140105335569ed55e27b&amp;amp;pm_id=&#34;&gt;220uf的电容&lt;/a&gt;）&lt;/li&gt;&#xA;&lt;li&gt;Sharp pin 2 (LED-GND) =&amp;gt; GND&lt;/li&gt;&#xA;&lt;li&gt;Sharp pin 3 (LED)     =&amp;gt; Arduino PIN 2 （开关LED）&lt;/li&gt;&#xA;&lt;li&gt;Sharp pin 4 (S-GND)   =&amp;gt; GND&lt;/li&gt;&#xA;&lt;li&gt;Sharp pin 5 (Vo)      =&amp;gt; Arduino A0 pin （空气质量数据通过电压模拟信号输出）&lt;/li&gt;&#xA;&lt;li&gt;Sharp pin 6 (Vcc)     =&amp;gt; 5V&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/*&#xA; Interface to Sharp GP2Y1010AU0F Particle Sensor&#xA; Program by Christopher Nafis &#xA; Written April 2012&#xA; &#xA; http://www.sparkfun.com/datasheets/Sensors/gp2y1010au_e.pdf&#xA; http://sensorapp.net/?p=479&#xA; &#xA; Sharp pin 1 (V-LED)   =&amp;gt; 5V (connected to 150ohm resister)&#xA; Sharp pin 2 (LED-GND) =&amp;gt; Arduino GND pin&#xA; Sharp pin 3 (LED)     =&amp;gt; Arduino pin 2&#xA; Sharp pin 4 (S-GND)   =&amp;gt; Arduino GND pin&#xA; Sharp pin 5 (Vo)      =&amp;gt; Arduino A0 pin&#xA; Sharp pin 6 (Vcc)     =&amp;gt; 5V&#xA; */&#xA;#include &amp;lt;SPI.h&amp;gt;&#xA;#include &amp;lt;stdlib.h&amp;gt;&#xA;&#xA;int dustPin=0;&#xA;int ledPower=2;&#xA;int delayTime=280;&#xA;int delayTime2=40;&#xA;float offTime=9680;&#xA;&#xA;int dustVal=0;&#xA;int i=0;&#xA;float ppm=0;&#xA;char s[32];&#xA;float voltage = 0;&#xA;float dustdensity = 0;&#xA;float ppmpercf = 0;&#xA;&#xA;void setup(){&#xA;  Serial.begin(9600);&#xA;  pinMode(ledPower,OUTPUT);&#xA;&#xA;  // give the ethernet module time to boot up:&#xA;  delay(1000);&#xA;&#xA;  i=0;&#xA;  ppm =0;&#xA;}&#xA;&#xA;void loop(){&#xA;  i=i+1;&#xA;  digitalWrite(ledPower,LOW); // power on the LED&#xA;  delayMicroseconds(delayTime);&#xA;  dustVal=analogRead(dustPin); // read the dust value&#xA;  ppm = ppm+dustVal;&#xA;  delayMicroseconds(delayTime2);&#xA;  digitalWrite(ledPower,HIGH); // turn the LED off&#xA;  delayMicroseconds(offTime);&#xA;&#xA;  voltage = ppm/i*0.0049;&#xA;  dustdensity = 0.17*voltage-0.1;&#xA;  ppmpercf = (voltage-0.0256)*120000;&#xA;  if (ppmpercf &amp;lt; 0)&#xA;    ppmpercf = 0;&#xA;  if (dustdensity &amp;lt; 0 )&#xA;    dustdensity = 0;&#xA;  if (dustdensity &amp;gt; 0.5)&#xA;    dustdensity = 0.5;&#xA;  String dataString = &amp;quot;&amp;quot;;&#xA;  dataString += dtostrf(voltage, 9, 4, s);&#xA;  dataString += &amp;quot;,&amp;quot;;&#xA;  dataString += dtostrf(dustdensity, 5, 2, s);&#xA;  dataString += &amp;quot;,&amp;quot;;&#xA;  dataString += dtostrf(ppmpercf, 8, 0, s);&#xA;  i=0;&#xA;  ppm=0;&#xA;  Serial.println(dataString);&#xA;  delay(1000);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;把传感器和Ardiuno连接好后，可以连续打印出传感器的输出电压值。输出电压大小和灰尘含量的曲线入下图：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://www.evernote.com/shard/s26/sh/d9213b42-a489-4b10-a6a6-24b170f5bcab/26d6af8a0fb1c572c7f2c231bb376255/deep/0/%E5%85%B3%E4%BA%8EGP2Y1010AU0F%C2%A0SHARP%E4%BC%A0%E6%84%9F%E5%99%A8%E4%BD%BF%E7%94%A8_dizhuwa_%E6%96%B0%E6%B5%AA%E5%8D%9A%E5%AE%A2.png&#34; width=&#34;400&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过电压的波形还可以判断是烟还是尘呢。。。&#xA;&lt;img src=&#34;https://www.evernote.com/shard/s26/sh/398f3903-7aff-444c-847e-3520e049d142/d7f12635352a30d50bdc4c30b2930367/deep/0/Dust%C2%A0Sensor%C2%A0GP2Y1010AU%C2%A0Application%C2%A0Note_PM2.5%E4%BC%A0%E6%84%9F%E5%99%A8_%E6%96%B0%E6%B5%AA%E5%8D%9A%E5%AE%A2.png&#34; width=&#34;500&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_3&#34;&gt;参考链接&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.sparkfun.com/datasheets/Sensors/gp2y1010au_e.pdf&#34;&gt;Sharp GP2Y1010AU0F Data Sheet&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.beck-elektronik.de/fileadmin/templates/beck_folder/opto/sensor/sharp/an-gp2y1010au.pdf&#34;&gt;Sharp GP2Y1010AU0F Application Note&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.howmuchsnow.com/arduino/airquality/&#34;&gt;http://www.howmuchsnow.com/arduino/airquality/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>替换树莓派的U盘</title>
      <link>http://hugozhu.myalert.info/2013/07/11/39-replace-usb-disk-on-raspberry-pi.html</link>
      <pubDate>2013-07-11 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;除了SD卡上的存储，树莓派还可以使用U盘来做存储，有时候我们可能需要替换已有的U盘为更大容量的。在Mac上可以采用下面的方法：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;备份已有的U盘，把U盘从树莓派上拔下来插在Mac上，找出U盘对应的盘符（下例为&lt;code&gt;/dev/disk2&lt;/code&gt;）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;20:51:19 hugozhu-mac-mini ~ $ diskutil list&#xA;/dev/disk0&#xA;   #:                       TYPE NAME                    SIZE       IDENTIFIER&#xA;   0:      GUID_partition_scheme                        *500.1 GB   disk0&#xA;   1:                        EFI                         209.7 MB   disk0s1&#xA;   2:                  Apple_HFS Macintosh HD            499.2 GB   disk0s2&#xA;   3:                 Apple_Boot Recovery HD             650.0 MB   disk0s3&#xA;/dev/disk2&#xA;   #:                       TYPE NAME                    SIZE       IDENTIFIER&#xA;   0:     FDisk_partition_scheme                        *2.1 GB     disk2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;使用 dd 命令把U盘拷贝到&lt;code&gt;raspberrypi.img&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo dd if=/dev/disk2 of=raspberrypi.img conv=notrunc&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;从Mac上取下旧U盘，把新的U盘插入同一个USB口，注意新U盘容量要大于旧的&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo dd of=/dev/disk2 if=raspberrypi.img conv=notrunc&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;把新U盘插入树莓派，并mount上，用以下命令把U盘的多余空间用起来&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;resize2fs /dev/sda&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>在Mac上使用Sublime 3写Go代码</title>
      <link>http://hugozhu.myalert.info/2013/07/11/40-try-out-sublime-3-beta-on-mac.html</link>
      <pubDate>2013-07-11 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;img src=&#34;http://www.sublimetext.com/anim/rename2_packed.png&#34; width=&#34;540&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.sublimetext.com&#34;&gt;Sublime&lt;/a&gt; 是一个相当好用的文本编辑器，界面简洁，功能强大。最近&lt;a href=&#34;http://www.sublimetext.com/3&#34;&gt;Sublime 3 Beta&lt;/a&gt; 出来了, 体验了一下，发现启动速度比之前快了很多。&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;下载安装&#34; href=&#34;#下载安装&#34;&gt;&lt;/a&gt;下载安装&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;下载地址： &lt;a href=&#34;http://www.sublimetext.com/3&#34;&gt;http://www.sublimetext.com/3&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;安装package-control&#34; href=&#34;#安装package-control&#34;&gt;&lt;/a&gt;安装Package Control&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;Sublime 支持插件来丰富其功能，&lt;a href=&#34;http://wbond.net/sublime_packages/package_control&#34;&gt;package control&lt;/a&gt; 本身也是一个插件，可以用来管理其他插件，所以我们要先安装Package Control，Sublime 3需要安装Pacakge Control Alpha.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cd &amp;quot;Library/Application Support/Sublime Text 3&amp;quot;&#xA;cd Packages/&#xA;git clone https://github.com/wbond/sublime_package_control.git &amp;quot;Package Control&amp;quot;&#xA;cd &amp;quot;Package Control&amp;quot;&#xA;git checkout python3&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;安装gosublime&#34; href=&#34;#安装gosublime&#34;&gt;&lt;/a&gt;安装GoSublime&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;重启Sublime后&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;按cmd+shift+p (OS X)或press ctrl+shift+p (Windows, Linux)&lt;/li&gt;&#xA;&lt;li&gt;在弹出的输入框中输入&lt;code&gt;PacInstall&lt;/code&gt; 选择 &lt;code&gt;Package Control: Install Package&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;在稍后弹出的输入框内输入&amp;rdquo;Gosublime&amp;rdquo;，选择安装&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;好了，就这样可以开始写Go代码了。&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;tips&#34; href=&#34;#tips&#34;&gt;&lt;/a&gt;Tips&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;我的Sublime配置&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    &amp;quot;font_face&amp;quot;: &amp;quot;Microsoft YaHei&amp;quot;,&#xA;    &amp;quot;font_options&amp;quot;:&#xA;    [&#xA;    ],&#xA;    &amp;quot;font_size&amp;quot;: 18.0,&#xA;    &amp;quot;line_padding_top&amp;quot;: 0&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;按快捷键&lt;code&gt;Shift + Command + L&lt;/code&gt;可以按列编辑&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;创建&lt;code&gt;~/bin/subl&lt;/code&gt;软连接&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ln -s /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在终端里就可以直接用&lt;code&gt;subl 文件名|目录&lt;/code&gt; 操作文件和目录了&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;按快捷键&lt;code&gt;Control + Command + G&lt;/code&gt;可以把选中的文本In Place替换成新的&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;安装&lt;a href=&#34;https://github.com/timonwong/SublimeAStyleFormatter&#34;&gt;AStyleFormatter&lt;/a&gt;后按&lt;code&gt;Ctrl+Alt+F&lt;/code&gt;: Format current file&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>Java并发中正确使用volatile</title>
      <link>http://hugozhu.myalert.info/2013/06/30/38-java-volatile-variable.html</link>
      <pubDate>2013-06-30 12:00:00 +0800</pubDate>
      <description>&#xA;&#xA;&lt;p&gt;前几天并发编程群里有同学对volatile的用法提出了疑问，刚好我记得Twitter有关实时搜索的这个&lt;a href=&#34;http://2011.lucene-eurocon.org/attachments/0002/8787/Busch_twitter_realtime_search_eurocon_11.pdf&#34;&gt;PPT&lt;/a&gt;对这个问题解释的很清晰并有一个实际的应用场景，于是周末把这个问题摘录了一些和并发相关的内容如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;h1&gt;目录：&lt;/h1&gt;&lt;nav&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_0&#34;&gt;并发 - 定义&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_1&#34;&gt;悲观锁 - Pressimistic locking&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_2&#34;&gt;乐观锁 - Optimistic locking&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_3&#34;&gt;非阻塞算法 - Non-blocking algorithm&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_4&#34;&gt;无锁算法 - Lock-free algorithm&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_5&#34;&gt;无等待算法 - Wait-free algorithm&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_6&#34;&gt;Java的并发&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_7&#34;&gt;Java内存模型&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_8&#34;&gt;代码顺序规则&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_9&#34;&gt;volatile变量规则&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_10&#34;&gt;传递性&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_11&#34;&gt;Safe publication案例&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_12&#34;&gt;JSR-133&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_13&#34;&gt;参考链接&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/nav&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_0&#34;&gt;并发 - 定义&lt;/h1&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_1&#34;&gt;悲观锁 - Pressimistic locking&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;一个线性在执行一个操作时持有对一个资源的独占锁。（互斥）&lt;/li&gt;&#xA;&lt;li&gt;一般用在冲突比较可能发生的场景下&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_2&#34;&gt;乐观锁 - Optimistic locking&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;尝试采用原子操作，而不需要持有锁；冲突可被检测，如果发生冲突，具有相应的重试逻辑&lt;/li&gt;&#xA;&lt;li&gt;通常用在冲突较少发生的场景下&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_3&#34;&gt;非阻塞算法 - Non-blocking algorithm&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;算法确保对线程间竞争共享资源时候，不会因为互斥而使任一线程的执行无限延迟；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_4&#34;&gt;无锁算法 - Lock-free algorithm&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如果系统整个流程的执行是无阻塞的(系统某一部分可能被短暂阻塞)，这种非阻塞算法就是无锁的。&lt;/li&gt;&#xA;&lt;li&gt;无锁算法比传统的基于锁的算法对系统的开销更小，且更容易在多核多CPU处理器上扩展；&lt;/li&gt;&#xA;&lt;li&gt;在实时系统中可以避免锁带来的延迟；&lt;/li&gt;&#xA;&lt;li&gt;CAS (compare and swap)或LL/SC(load linked/store conditional)，以及内存屏障相关的指令经常被用在算法实现中。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_5&#34;&gt;无等待算法 - Wait-free algorithm&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如果每个线程的执行都是无阻塞的，这种非阻塞算法就是无等待的（比无锁算法更好）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_6&#34;&gt;Java的并发&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Java的内存模型并不保证一个线程可以一直以程序执行的顺序看到另一个线程对变量的修改，除非两个线程都跨越了同一个内存屏障。（Safe publication）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_7&#34;&gt;Java内存模型&lt;/h1&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_8&#34;&gt;代码顺序规则&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;一个线程内的每个动作 happens-before 同一个线程内在代码顺序上在其后的所有动作&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_9&#34;&gt;volatile变量规则&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_10&#34;&gt;传递性&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如果A happens-before B, B happens-before C，那 A happens-before C&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_11&#34;&gt;Safe publication案例&lt;/h1&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class VolatileExample {&#xA;    int x = 0;&#xA;    volatile int b = 0;&#xA;&#xA;    private void write() {&#xA;        x = 5;&#xA;        b = 1;&#xA;    }&#xA;&#xA;    private void read() {&#xA;        int dummy = b;&#xA;        while (x!=5) {&#xA;        }&#xA;    }&#xA;&#xA;    public static void main(String[] args) throws Exception {&#xA;        final VolatileExample example = new VolatileExample();&#xA;        Thread thread1 = new Thread(new Runnable() {&#xA;            public void run() {&#xA;                example.write();&#xA;            }&#xA;        });&#xA;&#xA;        Thread thread2 = new Thread(new Runnable() {&#xA;            public void run() {&#xA;                example.read();&#xA;            }&#xA;        });&#xA;        thread1.start();&#xA;        thread2.start();&#xA;&#xA;        thread1.join();&#xA;        thread2.join();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://www.evernote.com/shard/s26/sh/569ae14f-957d-4ca0-97d7-72f66479d298/b4fb554c924ec7c2356d3ca94d7be61a/deep/0/Screenshot%206/30/13%2010:48%20AM.png&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;x并不需要定义为&lt;code&gt;volatile&lt;/code&gt;, 程序里可以有需要类似x的变量，我们只需要一个volatile变量b来确保线程a能看到线程1对x的修改：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;根据代码顺序规则，线程1的&lt;code&gt;x=5;&lt;/code&gt; happens-before &lt;code&gt;b=1;&lt;/code&gt;; 线程2的&lt;code&gt;int dummy = b;&lt;/code&gt;  happens-before &lt;code&gt;while(x!=5);&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;根据volatile变量规则，线程2的&lt;code&gt;b=1;&lt;/code&gt; happens-before &lt;code&gt;int dummy=b;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;根据传递性，&lt;code&gt;x=5;&lt;/code&gt; happens-before &lt;code&gt;while(x!=5);&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_12&#34;&gt;JSR-133&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;在JSR-133之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但旧的Java内存模型仍然会允许volatile变量与普通变量之间重排序。JSR-133则增强了volatile的内存语义：严格限制编译器（在编译器）和处理器（在运行期）对volatile变量与普通变量的重排序，确保volatile的写-读和监视器的释放-获取一样，具有相同的内存语义。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;延伸阅读： &lt;a href=&#34;http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf&#34;&gt;JSR-133: JavaTM Memory Model and Thread Specification&lt;/a&gt;， &lt;a href=&#34;http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html&#34;&gt;The JSR-133 Cookbook for Compiler Writers&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_13&#34;&gt;参考链接&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://2011.lucene-eurocon.org/attachments/0002/8787/Busch_twitter_realtime_search_eurocon_11.pdf&#34;&gt;http://2011.lucene-eurocon.org/attachments/0002/8787/Busch_twitter_realtime_search_eurocon_11.pdf&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.rossbencina.com/code/lockfree&#34;&gt;http://www.rossbencina.com/code/lockfree&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://rethinkdb.com/blog/lock-free-vs-wait-free-concurrency/&#34;&gt;http://rethinkdb.com/blog/lock-free-vs-wait-free-concurrency/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.infoq.com/cn/articles/java-memory-model-4&#34;&gt;http://www.infoq.com/cn/articles/java-memory-model-4&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf&#34;&gt;JSR-133: JavaTM Memory Model and Thread Specification&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html&#34;&gt;The JSR-133 Cookbook for Compiler Writers&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>在Android上使用tcpdump</title>
      <link>http://hugozhu.myalert.info/2013/06/24/37-tcpdump_on_android.html</link>
      <pubDate>2013-06-24 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;tcpdump工具是分析网络协议和数据包的利器，也可以在Android上使用（需要root）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先在android上安装tcpdump&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;wget http://www.strazzere.com/android/tcpdump&#xA;adb push tcpdump /data/local/tmp/tcpdump&#xA;adb chmod 755 /data/local/tmp/tcpdump&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后使用root用户启动tcpdump，在android上进行相应的操作后，按ctrl+c中断&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;adb shell&#xA;shell@android:/ $ su&#xA;root@android:/ # /data/local/tmp/tcpdump -h                                    &#xA;tcpdump version 3.9.8&#xA;libpcap version 0.9.8&#xA;Usage: tcpdump [-aAdDeflLnNOpqRStuUvxX] [-c count] [ -C file_size ]&#xA;        [ -E algo:secret ] [ -F file ] [ -i interface ] [ -M secret ]&#xA;        [ -r file ] [ -s snaplen ] [ -T type ] [ -w file ]&#xA;        [ -W filecount ] [ -y datalinktype ] [ -Z user ]&#xA;        [ expression ]&#xA;root@android:/ # /data/local/tmp/tcpdump -p -vv -s 0 w /sdcard/capture.pcap&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;tcpdump会在/sdcard下生成文件，可以通过&lt;code&gt;adb pull /sdcard/capture.pcap&lt;/code&gt;把文件传到PC上用&lt;a href=&#34;http://wireshark.org/&#34;&gt;wireshark&lt;/a&gt;看，也可以直接在android上通过&lt;a href=&#34;https://play.google.com/store/apps/details?id=lv.n3o.sharkreader&#34;&gt;SharkReader&lt;/a&gt;看。&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;参考链接&#34; href=&#34;#参考链接&#34;&gt;&lt;/a&gt;参考链接&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.kandroid.org/online-pdk/guide/tcpdump.html&#34;&gt;http://www.kandroid.org/online-pdk/guide/tcpdump.html&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://wireshark.org/&#34;&gt;http://wireshark.org/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.strazzere.com/blog/2009/08/gather-packets-from-your-android-without-arp-spoofing/&#34;&gt;http://www.strazzere.com/blog/2009/08/gather-packets-from-your-android-without-arp-spoofing/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>使用Ping来检查网络连通性</title>
      <link>http://hugozhu.myalert.info/2013/06/01/36-use-ping-to-check-network-connectivity.html</link>
      <pubDate>2013-06-01 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;树莓派使用了一个无线网卡连接家里的无线路由器，在实际使用过程中发现连续运行多天后会掉线，而且掉线后基本上就再也连不上网了，需要重启树莓派才能恢复，十分麻烦。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;假设无线路由器IP是192.168.1.1，于是每隔15分钟检查一下，是否能从树莓派上ping通路由器；如果不能则重启无线网络，脚本如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;network.sh&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/bin/bash&#xA;&#xA;export PATH=/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin&#xA;&#xA;ping_count() {&#xA;  count=0&#xA;  `timeout 5 ping 192.168.1.1 | while read LINE; do&#xA;  {&#xA;        if [[ &amp;quot;${LINE}&amp;quot; =~ &amp;quot;64 bytes from&amp;quot; ]]; then&#xA;                let &amp;quot;count = $count + 1&amp;quot;&#xA;                echo &amp;quot;export count=$count&amp;quot;&#xA;        fi&#xA;  }&#xA;  done`&#xA;  echo $count&#xA;}&#xA;&#xA;&#xA;if [[ $(ping_count) &amp;lt; 1 ]]; then&#xA;        ifconfig wlan0&#xA;        ifconfig wlan0 down&#xA;        sleep 1&#xA;        ifconfig wlan0 up&#xA;        sleep 1&#xA;        netcfg -r wlan0-Hugo-Nas&#xA;        sleep 5&#xA;        if [[ $(ping_count) &amp;lt; 1 ]]; then&#xA;                echo &amp;quot;Fatal error: wifi is down, rebooting now...&amp;quot;&#xA;                reboot&#xA;        fi&#xA;fi&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;可以用ifconfig wlan0 down &amp;amp;&amp;amp; ./network.sh来测试脚本是否能正常工作，测试完成后就可以放到crontab里执行了。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;*/60 * * * * /home/hugo/bin/network.sh &amp;gt;&amp;gt; /mnt/usb/logs/network.log 2&amp;gt;&amp;amp;1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这样出差不在家也不用通知家里的人拔插树莓派电源了。。。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>树莓派的GPIO接口输出电流限制</title>
      <link>http://hugozhu.myalert.info/2013/05/14/35-understanding-output.html</link>
      <pubDate>2013-05-14 12:00:00 +0800</pubDate>
      <description>&#xA;&#xA;&lt;p&gt;&lt;h1&gt;目录：&lt;/h1&gt;&lt;nav&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_0&#34;&gt;阻抗 (impendance)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_1&#34;&gt;结论&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_2&#34;&gt;参考链接&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/nav&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;树莓派提供了一个连接头让我们访问CPU的17个GPIO接口，如下图&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://www.evernote.com/shard/s26/sh/92d52938-5bd9-46a7-9b05-478e9f30f5d7/b29dcc510983784a07472c8282330b30/deep/0/Screenshot%205/14/13%208:51%20PM.png&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这些接口可配置成输入或输出。本文主要讨论GPIO引脚作为输出时电流的限制。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_0&#34;&gt;阻抗 (impendance)&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;阻抗和和电阻的区别（resistance）在于电阻的阻值是固定的，不会随着电流变化，阻抗则不然，可能随着外部变化，如电流或频率变化。从另一个角度来说，电阻是线性的，但阻抗不是。比如放大器的阻抗会随着输出的信号频率变化。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;树莓派的的每个GPIO引脚都有一个寄存器可以设置引脚的驱动强度，也就是在保持输出电压为逻辑0和1的情况下，可以改变阻抗的大小从而改变GPIO引脚的输出电流大小。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过如下电路测量相同电流下不同阻抗对应的GPIO电压输出（其中用到了一个电位器调节电流保持恒定）：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://www.evernote.com/shard/s26/sh/11008332-acac-4625-9b6a-963c97ec7498/1e6d153774b7e95214fe0c2bba9121d8/deep/0/Screenshot%205/14/13%2010:22%20PM.png&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过计算后，下表是当输出电流为2，4 … 16mA时，对应的阻抗大小以及如果发生短路时的短路电流大小。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://www.evernote.com/shard/s26/sh/7a411df0-56b1-4f76-bce5-54961bcfcfc7/4e46d9e28d7d01a34eb9e66ee28a5ba8/deep/0/Screenshot%205/14/13%2010:39%20PM.png&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可以看出短路电流都是超过16mA的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一个发光二极管压降约为1.5~2.0v，工作电流为3~10v&lt;/p&gt;&#xA;&#xA;&lt;p&gt;GPIO引脚的电流是通过板上的3.3V电压调整器输出的，树莓派是按平均每个引脚3mA来设计的，所以总的电流不能超过17 * 3 = 51mA。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_1&#34;&gt;结论&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;树莓派引脚电流大小的限制是：&lt;strong&gt;每个引脚最大输出电流为16毫安(mA)，且同一时刻所有引脚的总输出电流不超过51毫安&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_2&#34;&gt;参考链接&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.thebox.myzen.co.uk/Raspberry/Understanding_Outputs.html&#34;&gt;http://www.thebox.myzen.co.uk/Raspberry/Understanding_Outputs.html&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>使用8位移位寄存器74HC595扩展树莓派的IO端口</title>
      <link>http://hugozhu.myalert.info/2013/05/13/34-use-74HC595-8-bit-shift-register-with-raspberry-pi.html</link>
      <pubDate>2013-05-13 12:00:00 +0800</pubDate>
      <description>&#xA;&#xA;&lt;p&gt;&lt;h1&gt;目录：&lt;/h1&gt;&lt;nav&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_0&#34;&gt;芯片介绍&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_1&#34;&gt;控制流程&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_2&#34;&gt;材料&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_3&#34;&gt;电路图&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_4&#34;&gt;代码&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_5&#34;&gt;参考链接&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/nav&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;树莓派的GPIO接口数目有限，驱动一个步进电机需要占用4个， 一个Nokia 5110液晶也要占4个， 传感器输入至少需要一个，多玩几个外设后接口就不够用了。如果接口可以复用就可以让树莓派驱动更多的外设了，本文讨论如何使用74HC595集成电路芯片来扩展树莓派的I/O接口。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_0&#34;&gt;芯片介绍&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;SN74HC595N是德州仪器公司生产的集成电路芯片，是一个8位串行输入变串行输出或并行输出移位寄存器，具有高阻关断，高电平和低电平三态输出。在IO扩充上，可以最多串联15片，也就是高达120个IO扩充。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://www.evernote.com/shard/s26/sh/b90034cc-cdf8-426d-a79d-16bbbcbb49b2/0ba3371f3039afa71a17bad845eede7a/deep/0/Screenshot%205/12/13%2010:42%20PM.png&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;（注意到芯片上的小凹槽了吗，拿芯片的时候以这个为参考物就不会搞反了）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;接口的常用命名方式有以下两种：&lt;/p&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;接口代号(编号)&lt;/td&gt;&#xA;&lt;td&gt;说明&lt;/td&gt;&#xA;&lt;td&gt;接口代号(编号)&lt;/td&gt;&#xA;&lt;td&gt;说明&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Q7&amp;rsquo;(9)&lt;/td&gt;&#xA;&lt;td&gt;serial data output&lt;/td&gt;&#xA;&lt;td&gt;QH&amp;rsquo;  (9)&lt;/td&gt;&#xA;&lt;td&gt;serial data output&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;MR (10)&lt;/td&gt;&#xA;&lt;td&gt;Master Reset (Active Low)&lt;/td&gt;&#xA;&lt;td&gt;SRCLR  (10)&lt;/td&gt;&#xA;&lt;td&gt;Shift register CLeaR&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;SH_CP (11)&lt;/td&gt;&#xA;&lt;td&gt;shift register clock input&lt;/td&gt;&#xA;&lt;td&gt;SRCLK  (11)&lt;/td&gt;&#xA;&lt;td&gt;Shift Register CLocK input&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;ST_CP (12)&lt;/td&gt;&#xA;&lt;td&gt;storage register clock input&lt;/td&gt;&#xA;&lt;td&gt;RCLK  (12)&lt;/td&gt;&#xA;&lt;td&gt;storage Register CLocK input&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;OE (13)&lt;/td&gt;&#xA;&lt;td&gt;output enable input (Active Low)&lt;/td&gt;&#xA;&lt;td&gt;OE  (13)&lt;/td&gt;&#xA;&lt;td&gt;Output Enable&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;DS (14)&lt;/td&gt;&#xA;&lt;td&gt;serial data input&lt;/td&gt;&#xA;&lt;td&gt;SER (14)&lt;/td&gt;&#xA;&lt;td&gt;SERial data input&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Qx (15，1-7)&lt;/td&gt;&#xA;&lt;td&gt;data output&lt;/td&gt;&#xA;&lt;td&gt;Qx (15，1-7)&lt;/td&gt;&#xA;&lt;td&gt;data output&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_1&#34;&gt;控制流程&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;如果要在8个引脚输出01010101&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;将Pin 14（DS, SER）置为高电平（1）；&lt;/li&gt;&#xA;&lt;li&gt;将Pin 11 (SH_CP, SRCLK))做高低电平切换，形成一个脉冲信号，这个信号会将数据从移位寄存器C1移动到下一个移位寄存器C2，。。。&lt;/li&gt;&#xA;&lt;li&gt;接着将Pin 14设为低电平（0），再将Pin 11做1-&amp;gt;0的脉冲变化，将数据继续往下移，依次类推直到8位都输入完成；&lt;/li&gt;&#xA;&lt;li&gt;将Pin 12（ST_CP, RCLK）做1-&amp;gt;0的脉冲，将8位数据一次并行输出。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;如果要串联多片，由上一片的Pin 9接到下一片的Pin 14即可，这样输入16 bit后，再向Pin 12输入一个1-&amp;gt;0的脉冲，16 bit会并行输出。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果要一次清除所有数据，将Pin 10设为低电平后，再向Pin 12输入一个1-&amp;gt;0的脉冲即可；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Pin 13还有高阻关断的第三态输出功能。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面我们使用一片74HC595来同时控制8个发光二极管的状态，只需要占用树莓派的3个GPIO；否则的话，则需要占用8个。如果需要同时控制16个发光二极管，则可以通过串联两个74HC595来实现。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_2&#34;&gt;材料&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://item.taobao.com/item.htm?spm=a1z0d.1.1000638.45.bTo9PZ&amp;amp;id=3136071980&#34;&gt;74HC595&lt;/a&gt; 因为价格便宜，建议一次买3~10片&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://list.tmall.com/search_product.htm?q=%C3%E6%B0%FC%B0%E5&amp;amp;type=p&amp;amp;style=&amp;amp;cat=all&#34;&gt;面包板&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://re.taobao.com/eauction?e=WZUyNh6fV9rghojqVNxKsQRl3vWzxAV13G1s8WRbfpWLltG5xFicOSFINJCCZ52POOqhJP6qr9i9NE9AQxtQk3S1BzvCCF6OuLrQdcbQlR6B3ujUJI0OeA%3D%3D&amp;amp;ptype=100011&amp;amp;clk1=ebe7f36b49064c26364fbf2d12bbd3da&amp;amp;upsid=ebe7f36b49064c26364fbf2d12bbd3da&#34;&gt;面包板跳线&lt;/a&gt; 14根&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://re.taobao.com/eauction?e=NW2xGTCNV2%2FghojqVNxKsRoUGnN%2F%2FLrYlWsbAjdmP56LltG5xFicOSFINJCCZ52POOqhJP6qr9i9NE9AQxtQk3S1BzvCCF6OuLrQdcbQlR6B3ujUJI0OeA%3D%3D&amp;amp;ptype=100011&amp;amp;clk1=231682cf5123eea41a361c2c62bbf6d8&amp;amp;upsid=231682cf5123eea41a361c2c62bbf6d8&#34;&gt;发光二极管&lt;/a&gt; 8个&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://re.taobao.com/search?e=NW2xGTCNV2%252FghojqVNxKsRoUGnN%252F%252FLrYlWsbAjdmP56LltG5xFicOSFINJCCZ52POOqhJP6qr9i9NE9AQxtQk3S1BzvCCF6OuLrQdcbQlR6B3ujUJI0OeA%253D%253D&amp;amp;keyword=%B5%E7%D7%E8%B0%FC&amp;amp;type=taoke&amp;amp;refpid=mm_12926928_3484851_11423971&amp;amp;refpos=&amp;amp;unid=0&amp;amp;clk1=231682cf5123eea41a361c2c62bbf6d8&amp;amp;ismall=&amp;amp;catid=&amp;amp;frcatid=&#34;&gt;300欧姆电阻&lt;/a&gt; 8个&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_3&#34;&gt;电路图&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://www.evernote.com/shard/s26/sh/392c6eda-a41a-49ee-b2ec-db61a8dbd94d/353eaa84ddc75fda7b92cdce1a48f293/deep/0/Screenshot%205/12/13%2010:14%20PM.png&#34; width=&#34;540&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://ww2.sinaimg.cn/bmiddle/6bc40342jw1e4luoggxabj20vk0nodm9.jpg&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://photo.weibo.com/1808008002/wbphotos/large/photo_id/3577295178801052?refer=weibofeedv5&#34;&gt;&lt;img src=&#34;http://ww3.sinaimg.cn/bmiddle/6bc40342jw1e4lzscegezj20vk0noqai.jpg&#34;/&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;引脚连接&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;596 Pin 14 -&amp;gt; Raspberry Pi GPIO4&lt;/li&gt;&#xA;&lt;li&gt;596 Pin 12 -&amp;gt; Raspberry Pi GPIO5&lt;/li&gt;&#xA;&lt;li&gt;596 Pin 11 -&amp;gt; Raspberry Pi GPIO6&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_4&#34;&gt;代码&lt;/h1&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;wiringPi.h&amp;gt;&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;&#xA;int SER   = 4;&#xA;int RCLK  = 5;&#xA;int SRCLK = 6;&#xA;&#xA;unsigned char LED[8]={0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};&#xA;&#xA;void SIPO(unsigned char byte);&#xA;void pulse(int pin);&#xA;&#xA;void init() {&#xA;    pinMode(SER, OUTPUT);&#xA;    pinMode(RCLK, OUTPUT);&#xA;    pinMode(SRCLK, OUTPUT);&#xA;&#xA;    digitalWrite(SER, 0);&#xA;    digitalWrite(SRCLK, 0);&#xA;    digitalWrite(RCLK, 0);    &#xA;}&#xA;&#xA;void delayMS(int x) {&#xA;  usleep(x * 1000);&#xA;}&#xA;&#xA;int main (void)&#xA;{&#xA;    if (-1 == wiringPiSetup()) {&#xA;        printf(&amp;quot;Setup wiringPi failed!&amp;quot;);&#xA;        return 1;&#xA;    }    &#xA;&#xA;    init();&#xA;    int i;&#xA;    while(1) {  &#xA;      for(i = 0; i &amp;lt; 8; i++)&#xA;      {&#xA;       SIPO(LED[i]);&#xA;       pulse(RCLK);&#xA;       delayMS(50);&#xA;       printf(&amp;quot; i = %d&amp;quot;, i);&#xA;      }&#xA;      printf(&amp;quot;\n&amp;quot;);&#xA;      delayMS(500); // 500 ms&#xA;      &#xA;      for(i = 7; i &amp;gt;= 0; i--)&#xA;      {&#xA;       SIPO(LED[i]);&#xA;       pulse(RCLK);&#xA;       delayMS(50);&#xA;       printf(&amp;quot; i = %d&amp;quot;, i);&#xA;      }&#xA;      delayMS(500); // 500 ms&#xA;    }&#xA;&#xA;    usleep(1000);&#xA;    digitalWrite(RCLK, 1);&#xA;}&#xA;&#xA;void SIPO(unsigned char byte) &#xA;{&#xA;    int i;&#xA;    for (i=0;i&amp;lt;8;i++) &#xA;    {&#xA;        digitalWrite(SER,((byte &amp;amp; (0x80 &amp;gt;&amp;gt; i)) &amp;gt; 0));&#xA;        pulse(SRCLK);&#xA;    }&#xA;}&#xA;&#xA;void pulse(int pin) &#xA;{&#xA;    digitalWrite(pin, 1);&#xA;    digitalWrite(pin, 0);&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;编译执行上面的代码后可以看到LED从左到有一次依次点亮后灭掉，再反向点亮一遍，循环执行，有点像钟摆的效果。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_5&#34;&gt;参考链接&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://baike.baidu.com/view/1309513.htm&#34;&gt;http://baike.baidu.com/view/1309513.htm&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://ruten-proteus.blogspot.com/2012/11/io-74hc595-ic.html&#34;&gt;http://ruten-proteus.blogspot.com/2012/11/io-74hc595-ic.html&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Charlieplexing&#34;&gt;http://en.wikipedia.org/wiki/Charlieplexing&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>树莓派网站容灾：利用DNSPod，Google App Engine和Github</title>
      <link>http://hugozhu.myalert.info/2013/04/22/33-use-google-app-engine-failover-your-blog-between-raspberrypi-and-github.html</link>
      <pubDate>2013-04-22 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;背景介绍&#34; href=&#34;#背景介绍&#34;&gt;&lt;/a&gt;背景介绍&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://hugozhu.myalert.info/2013/02/27/在Pi和Github上搭建自己的个人博客.html&#34;&gt;把网站托管在树莓派上&lt;/a&gt;后如果家里停电或是宽带故障，会造成网站中断。本文提供一个免费的解决方案（前提是你需要有自己的一个域名，并由DNSPod解析）&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;dnspod&#34; href=&#34;#dnspod&#34;&gt;&lt;/a&gt;DNSPod&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;首先需要在DNSPod里设置好需要failover的域名CNAME：比如&lt;code&gt;hugozhu.myalert.info&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://www.evernote.com/shard/s26/sh/95d90628-5c74-4773-aaff-c2110e1863a6/6b592609ef02c42e46664d1fa1493e1c/deep/0/Screenshot%204/22/13%204:57%20PM.png&#34; width=&#34;528&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其中&lt;code&gt;默认&lt;/code&gt;指向&lt;code&gt;pi.myalert.info&lt;/code&gt;, 这是一个域名的A Record，会由运行在树莓派上的&lt;a href=&#34;http://hugozhu.myalert.info/2013/02/26/dynamic-dns-script.html&#34;&gt;脚本&lt;/a&gt;来更新动态IP，&lt;code&gt;国外&lt;/code&gt;则指向github。当停电时我们需要自动把｀默认｀这条纪录修改成github。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用下面命令获得相应CNAME的domain_id：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;curl -k https://dnsapi.cn/Domain.List -d &amp;quot;login_email=xxx&amp;amp;login_password=xxx&amp;quot; &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;使用下面命令获得相应CNAME的record_id：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;curl -k https://dnsapi.cn/Record.List -d &amp;quot;login_email=xxx&amp;amp;login_password=xxx&amp;amp;domain_id=xxx&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;google-app-engine&#34; href=&#34;#google-app-engine&#34;&gt;&lt;/a&gt;Google App Engine&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;切换dns脚本&#34; href=&#34;#切换dns脚本&#34;&gt;&lt;/a&gt;切换DNS脚本&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package dnspod&#xA;&#xA;import (&#xA;    &amp;quot;io/ioutil&amp;quot;&#xA;    &amp;quot;net/http&amp;quot;&#xA;    &amp;quot;net/url&amp;quot;&#xA;    &amp;quot;strings&amp;quot;&#xA;)&#xA;&#xA;const (&#xA;    login_email    = &amp;quot;&amp;lt;your_login_email&amp;gt;&amp;quot;&#xA;    login_password = &amp;quot;&amp;lt;your_login_password&amp;gt;&amp;quot;&#xA;    format         = &amp;quot;json&amp;quot;&#xA;    domain_id      = &amp;quot;&amp;lt;domain_id&amp;gt;&amp;quot;&#xA;    record_id      = &amp;quot;&amp;lt;record_id&amp;gt;&amp;quot;&#xA;    sub_domain     = &amp;quot;&amp;lt;your_subdomain&amp;gt;&amp;quot;&#xA;    record_type    = &amp;quot;CNAME&amp;quot;&#xA;    record_line    = &amp;quot;默认&amp;quot;&#xA;    ttl            = &amp;quot;600&amp;quot;&#xA;)&#xA;&#xA;func Update(client *http.Client, cname string) string {&#xA;    body := url.Values{&#xA;        &amp;quot;login_email&amp;quot;:    {login_email},&#xA;        &amp;quot;login_password&amp;quot;: {login_password},&#xA;        &amp;quot;format&amp;quot;:         {format},&#xA;        &amp;quot;domain_id&amp;quot;:      {domain_id},&#xA;        &amp;quot;record_id&amp;quot;:      {record_id},&#xA;        &amp;quot;sub_domain&amp;quot;:     {sub_domain},&#xA;        &amp;quot;record_type&amp;quot;:    {record_type},&#xA;        &amp;quot;record_line&amp;quot;:    {record_line},&#xA;        &amp;quot;value&amp;quot;:          {cname},&#xA;        &amp;quot;ttl&amp;quot;:            {ttl},&#xA;    }&#xA;    req, err := http.NewRequest(&amp;quot;POST&amp;quot;, &amp;quot;https://dnsapi.cn/Record.Modify&amp;quot;, strings.NewReader(body.Encode()))&#xA;    req.Header.Set(&amp;quot;Accept&amp;quot;, &amp;quot;text/json&amp;quot;)&#xA;    req.Header.Set(&amp;quot;Content-type&amp;quot;, &amp;quot;application/x-www-form-urlencoded&amp;quot;)&#xA;    resp, err := client.Do(req)&#xA;    if err != nil {&#xA;        return err.Error()&#xA;    }&#xA;    defer resp.Body.Close()&#xA;    bytes, _ := ioutil.ReadAll(resp.Body)&#xA;    return string(bytes)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;检测接口&#34; href=&#34;#检测接口&#34;&gt;&lt;/a&gt;检测接口&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;部署一个web应用到Google App Engine上，该应用接受树莓派上的一个URL（注意这里不应该用需failver的域名），并请求该域名以检查网站是否正常。这里也可以使用监控宝来监控，但只有付费专业版才支持出错后回调URL。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func ping(w http.ResponseWriter, r *http.Request) {&#xA;    url := r.FormValue(&amp;quot;url&amp;quot;)&#xA;    c := appengine.NewContext(r)&#xA;    client := urlfetch.Client(c)&#xA;    ok, body := url_ok(client, url)&#xA;&#xA;    item, _ := memcache.Get(c, &amp;quot;site_fails&amp;quot;)&#xA;&#xA;    if ok {&#xA;        if item != nil {&#xA;            //switch back to pi&#xA;            dnspod.Update(client, &amp;quot;pi.myalert.info.&amp;quot;)&#xA;            memcache.Delete(c, &amp;quot;site_fails&amp;quot;)&#xA;        }&#xA;    } else {&#xA;        if item != nil {&#xA;            //previously failed, switch to github&#xA;            dnspod.Update(client, &amp;quot;hugozhu.github.com.&amp;quot;)&#xA;            value, _ := strconv.Atoi(string(item.Value))&#xA;            value++&#xA;            item.Value = []byte(strconv.Itoa(value))&#xA;            memcache.Set(c, item)&#xA;        } else {&#xA;            //first time failed&#xA;            item = &amp;amp;memcache.Item{&#xA;                Key:   &amp;quot;site_fails&amp;quot;,&#xA;                Value: []byte(&amp;quot;0&amp;quot;),&#xA;            }&#xA;            memcache.Set(c, item)&#xA;        }&#xA;    }&#xA;&#xA;    w.Header().Set(&amp;quot;Content-type&amp;quot;, &amp;quot;text/plain&amp;quot;)&#xA;    fmt.Fprintf(w, &amp;quot;%s&amp;quot;, body)&#xA;}&#xA;&#xA;func url_ok(client *http.Client, url string) (bool, string) {&#xA;    resp, err := client.Get(url)&#xA;    ok := false&#xA;    body := &amp;quot;&amp;quot;&#xA;    if err != nil {&#xA;        body = err.Error()&#xA;    } else {&#xA;        bytes, _ := ioutil.ReadAll(resp.Body)&#xA;        body = string(bytes)&#xA;        resp.Body.Close()&#xA;        ok = resp.StatusCode == 200&#xA;    }&#xA;    return ok, body&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;定时任务&#34; href=&#34;#定时任务&#34;&gt;&lt;/a&gt;定时任务&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;在gae项目里增加一个文件：&lt;a href=&#34;https://github.com/hugozhu/gae-rpi-webapp/blob/master/cron.yaml&#34;&gt;cron.yaml&lt;/a&gt;，内容如下，这样gae会自动每隔15分钟检查一次，如果连续发现两次不可用，就会切换到Github，恢复后则会切换回来。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cron:&#xA;- description: check pi if it&#39;s still alive&#xA;  url: /ping&#xA;  schedule: every 15 minutes&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;参考链接&#34; href=&#34;#参考链接&#34;&gt;&lt;/a&gt;参考链接&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://hugozhu.myalert.info/2013/02/27/在Pi和Github上搭建自己的个人博客.html&#34;&gt;http://hugozhu.myalert.info/2013/02/27/在Pi和Github上搭建自己的个人博客.html&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/hugozhu/gae-rpi-webapp&#34;&gt;https://github.com/hugozhu/gae-rpi-webapp&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>使用Goroutine和Channel实现按键超时交互</title>
      <link>http://hugozhu.myalert.info/2013/04/21/32-use-goroutine-and-channel-to-implement-interaction-with-timeout.html</link>
      <pubDate>2013-04-21 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;背景介绍&#34; href=&#34;#背景介绍&#34;&gt;&lt;/a&gt;背景介绍&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;前面的文章（见&lt;a href=&#34;#参考链接&#34;&gt;参考链接&lt;/a&gt;）已经介绍了如何使用按键作为树莓派的输入。在实际应用中可以通过按下按键循环显示预先设定的脚本输出到显示屏幕，需求如下：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如果按键不被触动，则定时5秒执行脚本获取最新内容显示；&lt;/li&gt;&#xA;&lt;li&gt;因为不同的脚本获取内容速度会不一样，我们要求如果超过500ms脚本还未返回，需要在屏幕上显示“loading…”这样的过渡内容，如果脚本在500ms内返回，则不显示。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;使用Goroutine和Channel可以很方便的实现这个需求。&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;代码&#34; href=&#34;#代码&#34;&gt;&lt;/a&gt;代码&lt;/h1&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var screen_chan chan int&#xA;var switch_chan = make(chan bool)&#xA;&#xA;func main() {&#xA;    //a goroutine： 检查按键是否被按&#xA;    go func() {&#xA;        last_time := time.Now().UnixNano() / 1000000&#xA;        btn_pushed := 0&#xA;        total_mode := 3&#xA;        for msg := range WiringPiISR(PIN_GPIO_6, INT_EDGE_FALLING) {&#xA;            if msg &amp;gt; -1 {&#xA;                n := time.Now().UnixNano() / 1000000&#xA;                delta := n - last_time&#xA;                if delta &amp;gt; 300 { //如果两次按键变化的间隔时间&amp;lt;300ms，是因为接触信号不稳定可以忽略掉&#xA;                    last_time = n&#xA;                    btn_pushed++&#xA;                    screen_chan &amp;lt;- btn_pushed % total_mode&#xA;                }&#xA;            }&#xA;        }&#xA;    }()&#xA;&#xA;    //a goroutine： 根据管道消息刷新屏幕&#xA;    go loop_update_display()&#xA;&#xA;    //选择确实的屏幕内容脚本编号&#xA;    screen_chan &amp;lt;- 0&#xA;&#xA;    //a goroutine: 定时5s向管道发送更新屏幕内容的信号&#xA;    ticker := time.NewTicker(5 * time.Second)&#xA;    go func() {&#xA;        for {&#xA;            &amp;lt;-ticker.C&#xA;            screen_chan &amp;lt;- -1&#xA;        }&#xA;    }()&#xA;    &#xA;    ... &#xA;}&#xA;&#xA;func loop_update_display() {&#xA;    current_screen := 0&#xA;    for msg := range screen_chan {&#xA;        switch_screen := false&#xA;        if msg &amp;gt;= 0 {&#xA;           //说明是按钮触发的消息，而不是定时器触发的(-1)&#xA;            if msg != current_screen {&#xA;                //btn pushed&#xA;                current_screen = msg&#xA;                switch_screen = true&#xA;                go func() {&#xA;                    select {&#xA;                    case &amp;lt;-time.After(500 * time.Millisecond):&#xA;                        display_loading()&#xA;                        &amp;lt;-switch_chan&#xA;                    case &amp;lt;-switch_chan:&#xA;                    }&#xA;                }()&#xA;            }&#xA;        }&#xA;        switch current_screen {&#xA;        case 0:&#xA;            display_screen0()&#xA;        case 1:&#xA;            display_screen1()&#xA;        case 2:&#xA;            display_screen2()&#xA;        }&#xA;        if switch_screen {&#xA;            switch_chan &amp;lt;- true&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;go func() {&#xA;    select {&#xA;    case &amp;lt;-time.After(500 * time.Millisecond):&#xA;        display_loading(current_screen)&#xA;        &amp;lt;-switch_chan&#xA;    case &amp;lt;-switch_chan:&#xA;    }&#xA;}()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;超时控制的代码就是上面几行了。首先如果是按键触发，主goroutine会创建一个检查超时的goroutine，该goroutine执行&lt;code&gt;select&lt;/code&gt;语句时会试图从两个管道里获取消息，先获取到消息的管道会继续执行相应分支的代码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果&lt;code&gt;display_screenN&lt;/code&gt;方法在500ms内完成了，&lt;code&gt;switch_chan&lt;/code&gt;会被主goroutine发送&lt;code&gt;true&lt;/code&gt;，这时超时检查的goroutine就会直接从&lt;code&gt;select&lt;/code&gt;语句退出；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果&lt;code&gt;display_screenN&lt;/code&gt;方法在500ms内未完成，则&lt;code&gt;display_loading()&lt;/code&gt;会先执行，执行完后继续等待&lt;code&gt;switch_chan&lt;/code&gt;的消息，直到&lt;code&gt;display_screenN&lt;/code&gt;完成。注意&lt;code&gt;display_xxxxxx&lt;/code&gt;方法内部都使用了互斥锁，有一种边界情况是&lt;code&gt;display_screenN&lt;/code&gt;先获取了锁，完成显示后&lt;code&gt;dislay_loading&lt;/code&gt;再执行，这样内容就会一直保持为&amp;rdquo;loading…&amp;rdquo;直到下一次定时刷新到来。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果有其它更好的方法请指教。&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;参考链接&#34; href=&#34;#参考链接&#34;&gt;&lt;/a&gt;参考链接&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://hugozhu.myalert.info/2013/04/08/27-interrupts-with-gpio-pins.html&#34;&gt;http://hugozhu.myalert.info/2013/04/08/27-interrupts-with-gpio-pins.html&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://hugozhu.myalert.info/2013/04/14/29-use-wiringpi-go-binding.html&#34;&gt;http://hugozhu.myalert.info/2013/04/14/29-use-wiringpi-go-binding.html&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>Go语言内存模型</title>
      <link>http://hugozhu.myalert.info/2013/04/20/31-golang-memory-model.html</link>
      <pubDate>2013-04-20 12:00:00 +0800</pubDate>
      <description>&#xA;&#xA;&lt;p&gt;&lt;h1&gt;目录：&lt;/h1&gt;&lt;nav&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_0&#34;&gt;名词定义&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_1&#34;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_2&#34;&gt;Happens Before&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_3&#34;&gt;Happens-before 定义&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_4&#34;&gt;同步方法&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_5&#34;&gt;初始化&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_6&#34;&gt;创建Goroutine&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_7&#34;&gt;销毁Goroutine&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_8&#34;&gt;Channel通信&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_9&#34;&gt;锁&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_10&#34;&gt;Once&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_11&#34;&gt;参考链接&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/nav&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_0&#34;&gt;名词定义&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;执行体 - Go里的Goroutine或Java中的Thread&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_1&#34;&gt;背景介绍&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;内存模型的目的是为了定义清楚变量的读写在不同执行体里的可见性。理解内存模型在并发编程中非常重要，因为代码的执行顺序和书写的逻辑顺序并不会完全一致，甚至在编译期间编译器也有可能重排代码以最优化CPU执行, 另外还因为有CPU缓存的存在，内存的数据不一定会及时更新，这样对内存中的同一个变量读和写也不一定和期望一样。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;和&lt;a href=&#34;http://ifeve.com/java-memory-model-1/&#34;&gt;Java的内存模型规范&lt;/a&gt;类似，Go语言也有一个内存模型，相对JMM来说，Go的内存模型比较简单，Go的并发模型是基于CSP（&lt;a href=&#34;http://en.wikipedia.org/wiki/Communicating_sequential_processes&#34;&gt;Communicating Sequential Process&lt;/a&gt;）的，不同的Goroutine通过一种叫Channel的数据结构来通信；Java的并发模型则基于多线程和共享内存，有较多的概念（violatie, lock, final, construct, thread, atomic等）和场景，当然java.util.concurrent并发工具包大大简化了Java并发编程。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Go内存模型规范了在什么条件下一个Goroutine对某个变量的修改一定对其它Goroutine可见。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_2&#34;&gt;Happens Before&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;在一个单独的Goroutine里，对变量的读写和代码的书写顺序一致。比如以下的代码:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;log&amp;quot;&#xA;)&#xA;&#xA;var a, b, c int&#xA;&#xA;func main() {&#xA;    a = 1&#xA;    b = 2&#xA;    c = a + 2&#xA;    log.Println(a, b, c)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;尽管在编译期和执行期，编译器和CPU都有可能重排代码，比如，先执行b=2，再执行a=1，但c=a+2是保证在a=1后执行的。这样最后的执行结果一定是&lt;code&gt;1 2 3&lt;/code&gt;，不会是&lt;code&gt;1 2 2&lt;/code&gt;。但下面的代码则可能会输出&lt;code&gt;0 0 0&lt;/code&gt;，&lt;code&gt;1 2 2&lt;/code&gt;,  &lt;code&gt;0 2 3&lt;/code&gt; (b=2比a=1先执行), &lt;code&gt;1 2 3&lt;/code&gt;等各种可能。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;log&amp;quot;&#xA;)&#xA;&#xA;var a, b, c int&#xA;&#xA;func main() {&#xA;    go func() {&#xA;        a = 1&#xA;        b = 2&#xA;    }()&#xA;    go func() {&#xA;        c = a + 2&#xA;    }()&#xA;    log.Println(a, b, c)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_3&#34;&gt;Happens-before 定义&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Happens-before用来指明Go程序里的内存操作的局部顺序。如果一个内存操作事件e1 happens-before e2，则e2 happens-after e1也成立；如果e1不是happens-before e2,也不是happens-after e2，则e1和e2是并发的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在这个定义之下，如果以下情况满足，则对变量（v）的内存写操作（w）对一个内存读操作（r）来说&lt;strong&gt;允许&lt;/strong&gt;可见的：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;r不在w开始之前发生（可以是之后或并发）；&lt;/li&gt;&#xA;&lt;li&gt;w和r之间没有另一个写操作(w&amp;rsquo;)发生；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;为了保证对变量（v）的一个特定写操作（w）对一个读操作（r）可见，就需要确保w是r&lt;strong&gt;唯一&lt;/strong&gt;&lt;strong&gt;允许&lt;/strong&gt;的写操作，于是如果以下情况满足，则对变量（v）的内存写操作（w）对一个内存读操作（r）来说&lt;strong&gt;保证&lt;/strong&gt;可见的：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;w在r开始之前发生；&lt;/li&gt;&#xA;&lt;li&gt;所有其它对v的写操作只在w之前或r之后发生；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;可以看出后一种约定情况比前一种更严格，这种情况要求没有w或r没有其他的并发写操作。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在单个Goroutine里，因为肯定没有并发，上面两种情况是等价的。对变量v的读操作可以读到最近一次写操作的值（这个应该很容易理解）。但在多个Goroutine里如果要访问一个共享变量，我们就必须使用同步工具来建立happens-before条件，来保证对该变量的读操作能读到期望的修改值。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;要保证并行执行体对共享变量的顺序访问方法就是用锁&lt;/strong&gt;。Java和Go在这点上是一致的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;以下是具体的可被利用的Go语言的happens-before规则，从本质上来讲，happens-before规则确定了CPU缓冲和主存的同步时间点（通过&lt;a href=&#34;http://hugozhu.myalert.info/2013/03/28/22-memory-barriers-or-fences.html&#34;&gt;内存屏障&lt;/a&gt;等指令），从而使得对变量的读写顺序可被确定&amp;ndash;也就是我们通常说的“同步”。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_4&#34;&gt;同步方法&lt;/h1&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_5&#34;&gt;初始化&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;如果package p 引用了package q，q的init()方法 happens-before p&lt;/strong&gt; （Java工程师可以对比一下&lt;a href=&#34;http://www.infoq.com/cn/articles/java-memory-model-6?utm_source=infoq&amp;amp;utm_medium=related_content_link&amp;amp;utm_campaign=relatedContent_articles_clk&#34;&gt;final变量的happens-before规则&lt;/a&gt;）&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;main.main()方法 happens-after所有package的init()方法结束。&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_6&#34;&gt;创建Goroutine&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;go语句创建新的goroutine happens-before 该goroutine执行&lt;/strong&gt;（这个应该很容易理解）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;time&amp;quot;&#xA;)&#xA;&#xA;var a, b, c int&#xA;&#xA;func main() {&#xA;    a = 1&#xA;    b = 2&#xA;    go func() {&#xA;        c = a + 2&#xA;        log.Println(a, b, c)&#xA;    }()&#xA;    time.Sleep(1 * time.Second)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;利用这条happens-before，我们可以确定&lt;code&gt;c=a+2&lt;/code&gt;是happens-after&lt;code&gt;a=1和b=2&lt;/code&gt;，所以结果输出是可以确定的&lt;code&gt;1 2 3&lt;/code&gt;，但如果是下面这样的代码，输出就不确定了，有可能是&lt;code&gt;1 2 3&lt;/code&gt;或&lt;code&gt;0 0 2&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func main() {&#xA;    go func() {&#xA;        c = a + 2&#xA;        log.Println(a, b, c)&#xA;    }()&#xA;    a = 1&#xA;    b = 2&#xA;    time.Sleep(1 * time.Second)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_7&#34;&gt;销毁Goroutine&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;Goroutine的退出并不保证happens-before任何事件&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var a string&#xA;&#xA;func hello() {&#xA;    go func() { a = &amp;quot;hello&amp;quot; }()&#xA;    print(a)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上面代码因为&lt;code&gt;a=&amp;quot;hello&amp;quot;&lt;/code&gt; 没有使用同步事件，并不能保证这个赋值被主goroutine可见。事实上，极度优化的Go编译器甚至可以完全删除这行代码&lt;code&gt;go func() { a = &amp;quot;hello&amp;quot; }()&lt;/code&gt;。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Goroutine对变量的修改需要让对其它Goroutine可见，除了使用锁来同步外还可以用Channel。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_8&#34;&gt;Channel通信&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;在Go编程中，Channel是被推荐的执行体间通信的方法，Go的编译器和运行态都会尽力对其优化。&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;对一个Channel的发送操作(send) happens-before 相应Channel的接收操作完成&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;关闭一个Channel happens-before 从该Channel接收到最后的返回值0&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;不带缓冲的Channel的接收操作（receive） happens-before 相应Channel的发送操作完成&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var c = make(chan int, 10)&#xA;var a string&#xA;&#xA;func f() {&#xA;    a = &amp;quot;hello, world&amp;quot;&#xA;    c &amp;lt;- 0&#xA;}&#xA;&#xA;func main() {&#xA;    go f()&#xA;    &amp;lt;-c&#xA;    print(a)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上述代码可以确保输出&lt;code&gt;hello, world&lt;/code&gt;，因为&lt;code&gt;a = &amp;quot;hello, world&amp;quot;&lt;/code&gt; happens-before &lt;code&gt;c &amp;lt;- 0&lt;/code&gt;，&lt;code&gt;print(a)&lt;/code&gt; happens-after &lt;code&gt;&amp;lt;-c&lt;/code&gt;， 根据上面的规则1）以及happens-before的可传递性，&lt;code&gt;a = &amp;quot;hello, world&amp;quot;&lt;/code&gt; happens-before&lt;code&gt;print(a)&lt;/code&gt;。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;根据规则2）把&lt;code&gt;c&amp;lt;-0&lt;/code&gt;替换成&lt;code&gt;close(c)&lt;/code&gt;也能保证输出&lt;code&gt;hello,world&lt;/code&gt;，因为关闭操作在&lt;code&gt;&amp;lt;-c&lt;/code&gt;接收到0之前发送。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var c = make(chan int)&#xA;var a string&#xA;&#xA;func f() {&#xA;    a = &amp;quot;hello, world&amp;quot;&#xA;    &amp;lt;-c&#xA;}&#xA;&#xA;func main() {&#xA;    go f()&#xA;    c &amp;lt;- 0&#xA;    print(a)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;根据规则3），因为c是不带缓冲的Channel，&lt;code&gt;a = &amp;quot;hello, world&amp;quot;&lt;/code&gt; happens-before &lt;code&gt;&amp;lt;-c&lt;/code&gt; happens-before &lt;code&gt;c &amp;lt;- 0&lt;/code&gt; happens-before &lt;code&gt;print(a)&lt;/code&gt;， 但如果c是缓冲队列，如定义&lt;code&gt;c = make(chan int, 1)&lt;/code&gt;, 那结果就不确定了。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_9&#34;&gt;锁&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;sync&lt;/code&gt; 包实现了两种锁数据结构:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;sync.Mutex -&amp;gt; java.util.concurrent.ReentrantLock&lt;/li&gt;&#xA;&lt;li&gt;sync.RWMutex -&amp;gt; java.util.concurrent.locks.ReadWriteLock&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;其happens-before规则和Java的也类似：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;任何sync.Mutex或sync.RWMutex 变量（l），定义 n &amp;lt; m， 第n次 &lt;code&gt;l.Unlock()&lt;/code&gt; happens-before 第m次&lt;code&gt;l.lock()&lt;/code&gt;调用返回。&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var l sync.Mutex&#xA;var a string&#xA;&#xA;func f() {&#xA;    a = &amp;quot;hello, world&amp;quot;&#xA;    l.Unlock()&#xA;}&#xA;&#xA;func main() {&#xA;    l.Lock()&#xA;    go f()&#xA;    l.Lock()&#xA;    print(a)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;a = &amp;quot;hello, world&amp;quot;&lt;/code&gt; happens-before &lt;code&gt;l.Unlock()&lt;/code&gt; happens-before 第二个 &lt;code&gt;l.Lock()&lt;/code&gt; happens-before &lt;code&gt;print(a)&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_10&#34;&gt;Once&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;sync&lt;/code&gt;包还提供了一个安全的初始化工具Once。还记得Java的Singleton设计模式，double-check，甚至triple-check的各种单例初始化方法吗？Go则提供了一个标准的方法。&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;once.Do(f)&lt;/code&gt;中的&lt;code&gt;f()&lt;/code&gt; happens-before 任何多个once.Do(f)调用的返回，且f()有且只有一次调用。&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var a string&#xA;var once sync.Once&#xA;&#xA;func setup() {&#xA;    a = &amp;quot;hello, world&amp;quot;&#xA;}&#xA;&#xA;func doprint() {&#xA;    once.Do(setup)&#xA;    print(a)&#xA;}&#xA;&#xA;func twoprint() {&#xA;    go doprint()&#xA;    go doprint()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上面的代码虽然调用两次&lt;code&gt;doprint()&lt;/code&gt;，但实际上&lt;code&gt;setup&lt;/code&gt;只会执行一次，并且并发的&lt;code&gt;once.Do(setup)&lt;/code&gt;都会等待&lt;code&gt;setup&lt;/code&gt;返回后再继续执行。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_11&#34;&gt;参考链接&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://golang.org/ref/mem&#34;&gt;http://golang.org/ref/mem&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Java_Memory_Model&#34;&gt;http://en.wikipedia.org/wiki/Java_Memory_Model&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://ifeve.com/java-memory-model-1/&#34;&gt;http://ifeve.com/java-memory-model-1/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://code.google.com/p/golang-china/wiki/go_mem&#34;&gt;http://code.google.com/p/golang-china/wiki/go_mem&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>树莓派I2C编程</title>
      <link>http://hugozhu.myalert.info/2013/04/18/30-raspberrypi-i2c-programming.html</link>
      <pubDate>2013-04-18 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;(！未完！)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;除了&lt;a href=&#34;http://hugozhu.myalert.info/2013/04/05/25-get-spi-working-on-raspberry-pi-spi.html&#34;&gt;SPI&lt;/a&gt;协议外，树莓派还支持&lt;a href=&#34;http://zh.wikipedia.org/wiki/I²C&#34;&gt;I2C&lt;/a&gt;。I2C是为了连接低速周边装置设计的，只需要用两根线（SDA和SCL，也就是树莓派的端口8和9-wiringPi编号）。&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;i2c&#34; href=&#34;#i2c&#34;&gt;&lt;/a&gt;I2C&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://upload.wikimedia.org/wikipedia/commons/thumb/3/3e/I2C.svg/350px-I2C.svg.png&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;上图是一个主控使用I2C驱动3个设备的示意图&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;参考链接&#34; href=&#34;#参考链接&#34;&gt;&lt;/a&gt;参考链接&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://zh.wikipedia.org/wiki/I²C&#34;&gt;http://zh.wikipedia.org/wiki/I²C&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://projects.drogon.net/raspberry-pi/wiringpi/i2c-library/&#34;&gt;https://projects.drogon.net/raspberry-pi/wiringpi/i2c-library/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>使用Go语言在树莓派上编程</title>
      <link>http://hugozhu.myalert.info/2013/04/14/29-use-wiringpi-go-binding.html</link>
      <pubDate>2013-04-14 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;a href=&#34;https://projects.drogon.net/raspberry-pi/wiringpi/&#34;&gt;WiringPi&lt;/a&gt;是树莓派上比较好的一个开发库，是用C语言写的。使用cgo，我们可以在Go语言里方便的调用WiringPI的函数，于是我包装了一个&lt;a href=&#34;https://github.com/hugozhu/rpi&#34;&gt;WiringPi-Go&lt;/a&gt;，目前支持wiringPi的基本功能，硬件SPI协议驱动Nokia 5110屏幕，以及中断，未来还会增加PWM和I2C协议的支持。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面是一个完整的使用例子，结合了之前的两个电路：&lt;a href=&#34;http://hugozhu.myalert.info/2013/04/08/27-interrupts-with-gpio-pins.html&#34;&gt;链接1&lt;/a&gt;，&lt;a href=&#34;http://hugozhu.myalert.info/2013/04/05/25-get-spi-working-on-raspberry-pi-spi.html&#34;&gt;链接2&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过push button可以切换液晶屏显示不同脚本的输出内容。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;lcd_switch.go&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    . &amp;quot;github.com/hugozhu/rpi&amp;quot;&#xA;    &amp;quot;github.com/hugozhu/rpi/pcd8544&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;os/exec&amp;quot;&#xA;    &amp;quot;time&amp;quot;&#xA;)&#xA;&#xA;const (&#xA;    DIN        = PIN_MOSI&#xA;    SCLK       = PIN_SCLK&#xA;    DC         = PIN_GPIO_2&#xA;    RST        = PIN_GPIO_0&#xA;    CS         = PIN_CE0&#xA;    PUSHBUTTON = PIN_GPIO_6&#xA;    CONTRAST   = 40 //may need tweak for each Nokia 5110 screen&#xA;)&#xA;&#xA;var screen_chan chan int&#xA;var TOTAL_MODES = 3&#xA;&#xA;func init() {&#xA;    WiringPiSetup()&#xA;    pcd8544.LCDInit(SCLK, DIN, DC, CS, RST, CONTRAST)&#xA;    screen_chan = make(chan int, 1)&#xA;}&#xA;&#xA;func main() {&#xA;    //a goroutine to check button push event&#xA;    go func() {&#xA;        last_time := time.Now().UnixNano() / 1000000&#xA;        btn_pushed := 0&#xA;        for pin := range WiringPiISR(PUSHBUTTON, INT_EDGE_FALLING) {&#xA;            if pin &amp;gt; -1 {&#xA;                n := time.Now().UnixNano() / 1000000&#xA;                delta := n - last_time&#xA;                if delta &amp;gt; 300 { //software debouncing&#xA;                    log.Println(&amp;quot;btn pushed&amp;quot;)&#xA;                    last_time = n&#xA;                    btn_pushed++&#xA;                    screen_chan &amp;lt;- btn_pushed % TOTAL_MODES //switch the screen display&#xA;                }&#xA;            }&#xA;        }&#xA;    }()&#xA;&#xA;    //a groutine to update display every 5 seconds&#xA;    go loop_update_display()&#xA;&#xA;    //set screen 0 to be default display&#xA;    screen_chan &amp;lt;- 0&#xA;&#xA;    ticker := time.NewTicker(5 * time.Second)&#xA;&#xA;    for {&#xA;        &amp;lt;-ticker.C&#xA;        screen_chan &amp;lt;- -1 //refresh current screen every 5 seconds&#xA;    }&#xA;}&#xA;&#xA;func loop_update_display() {&#xA;    current_screen := 0&#xA;    for screen := range screen_chan {&#xA;        if screen &amp;gt;= 0 {&#xA;            if screen != current_screen {&#xA;                //btn pushed&#xA;                current_screen = screen&#xA;                display_loading()&#xA;            }&#xA;        }&#xA;        switch current_screen {&#xA;        case 0:&#xA;            display_screen0()&#xA;        case 1:&#xA;            display_screen1()&#xA;        case 2:&#xA;            display_screen2()&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;func display_loading() {&#xA;    pcd8544.LCDclear()&#xA;    pcd8544.LCDdrawstring(0, 20, &amp;quot;Loading ...&amp;quot;)&#xA;    pcd8544.LCDdisplay()&#xA;}&#xA;&#xA;func display_screen0() {&#xA;    out, err := exec.Command(&amp;quot;/bin/screen_0.sh&amp;quot;).CombinedOutput()&#xA;    if err != nil {&#xA;        out = []byte(err.Error())&#xA;    }&#xA;&#xA;    pcd8544.LCDclear()&#xA;    pcd8544.LCDdrawstring(0, 0, string(out))&#xA;    pcd8544.LCDdisplay()&#xA;}&#xA;&#xA;func display_screen1() {&#xA;    out, err := exec.Command(&amp;quot;/bin/screen_1.sh&amp;quot;).CombinedOutput()&#xA;    if err != nil {&#xA;        out = []byte(err.Error())&#xA;    }&#xA;&#xA;    pcd8544.LCDclear()&#xA;    pcd8544.LCDdrawstring(0, 0, string(out))&#xA;    pcd8544.LCDdisplay()&#xA;}&#xA;&#xA;func display_screen2() {&#xA;    out, err := exec.Command(&amp;quot;/bin/screen_2.sh&amp;quot;).CombinedOutput()&#xA;    if err != nil {&#xA;        out = []byte(err.Error())&#xA;    }&#xA;&#xA;    pcd8544.LCDclear()&#xA;    pcd8544.LCDdrawstring(0, 0, string(out))&#xA;    pcd8544.LCDdisplay()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;/bin/screen_2.sh&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/bin/bash&#xA;&#xA;echo &amp;quot;Current IP:&amp;quot; &#xA;ifconfig  | grep &amp;quot;inet &amp;quot; | awk &#39;{print $2}&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>使用tsar记录和监控树莓派CPU温度</title>
      <link>http://hugozhu.myalert.info/2013/04/13/28-use-tsar-to-monitor-raspberry-pi.html</link>
      <pubDate>2013-04-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;夏天到了，树莓派的CPU温度也开始节节攀升，虽然我们也可以用云服务&lt;a href=&#34;https://cosm.com&#34;&gt;cosm&lt;/a&gt;来监控，但每5分钟采样一次精度不够高，每分钟采样一次则上传次数又太多了点。最好的方法还是使用&lt;a href=&#34;http://github.com/alibaba/tsar&#34;&gt;tsar&lt;/a&gt;这样的工具本地高频（如每1分钟）采样，然后再定时将5分钟的均值上传到cosm绘图。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Tsar是淘宝的一个用来收集服务器系统和应用信息的采集报告工具，如收集服务器的系统信息（cpu，mem等），以及应用数据（nginx、swift等），收集到的数据存储在服务器磁盘上，可以随时查询历史信息，也可以将数据发送到nagios报警。Tsar能够比较方便的增加模块，只需要按照tsar的要求编写数据的采集函数和展现函数，就可以把自定义的模块加入到tsar中。&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;**更新**&#34; href=&#34;#**更新**&#34;&gt;&lt;/a&gt;&lt;strong&gt;更新&lt;/strong&gt;&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;[2013-04-14] mod_rpi已经被合并到了主干代码：&lt;a href=&#34;https://github.com/alibaba/tsar/blob/master/modules/mod_rpi.c&#34;&gt;https://github.com/alibaba/tsar/blob/master/modules/mod_rpi.c&lt;/a&gt;  只需要增加文件：&lt;code&gt;/etc/tsar/conf.d/rpi.conf&lt;/code&gt;，内容为以下即可开始使用mod_rpi模块：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;mod_rpi on&#xA;&#xA;####add it to tsar default output&#xA;output_stdio_mod mod_rpi&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;mod_rpi模块开发方法&#34; href=&#34;#mod_rpi模块开发方法&#34;&gt;&lt;/a&gt;mod_rpi模块开发方法&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;首先按照安装说明，见&lt;a href=&#34;https://github.com/alibaba/tsar&#34;&gt;https://github.com/alibaba/tsar&lt;/a&gt;将tsar和tsardevel安装好。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先运行下面的命令生成mod_rpi模块：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;hugo@raspberrypi2 ~/projects/tsardevel $ tsardevel rpi &#xA;build:make&#xA;install:make install&#xA;uninstall:make uninstall&#xA;hugo@raspberrypi2 ~/projects/tsardevel $ ls rpi&#xA;Makefile  mod_rpi.c  mod_rpi.conf&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后修改mod_rpi.c，增加读取CPU温度的逻辑：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/*&#xA; * (C) 2010-2011 Alibaba Group Holding Limited&#xA; *&#xA; * Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);&#xA; * you may not use this file except in compliance with the License.&#xA; * You may obtain a copy of the License at&#xA; *&#xA; *     http://www.apache.org/licenses/LICENSE-2.0&#xA; *&#xA; * Unless required by applicable law or agreed to in writing, software&#xA; * distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,&#xA; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#xA; * See the License for the specific language governing permissions and&#xA; * limitations under the License.&#xA; *&#xA; */&#xA;&#xA;#include &amp;quot;tsar.h&amp;quot;&#xA;&#xA;/*&#xA; * Structure for rpi infomation.&#xA; */&#xA;struct stats_rpi {&#xA;    unsigned int cpu_temp;&#xA;};&#xA;&#xA;#define STATS_TEST_SIZE (sizeof(struct stats_rpi))&#xA;&#xA;static char *rpi_usage = &amp;quot;    --rpi               Rapsberry Pi information (CPU temprature ...)&amp;quot;;&#xA;&#xA;&#xA;static void read_rpi_stats(struct module *mod, char *parameter)&#xA;{&#xA;    FILE *fp;&#xA;    char buf[64];&#xA;    memset(buf, 0, sizeof(buf));&#xA;    struct stats_rpi st_rpi;&#xA;    memset(&amp;amp;st_rpi, 0, sizeof(struct stats_rpi));&#xA;&#xA;    if ((fp = fopen(&amp;quot;/sys/class/thermal/thermal_zone0/temp&amp;quot;, &amp;quot;r&amp;quot;)) == NULL) {&#xA;        return;&#xA;    }&#xA;&#xA;    int cpu_temp;&#xA;&#xA;    fscanf(fp, &amp;quot;%d&amp;quot;, &amp;amp;cpu_temp);&#xA;&#xA;    st_rpi.cpu_temp = cpu_temp;&#xA;&#xA;    int pos = sprintf(buf, &amp;quot;%u&amp;quot;,&#xA;            /* the store order is not same as read procedure */&#xA;            st_rpi.cpu_temp);&#xA;    buf[pos] = &#39;\0&#39;;&#xA;    set_mod_record(mod, buf);&#xA;    fclose(fp);&#xA;    return;&#xA;}&#xA;&#xA;static struct mod_info rpi_info[] = {&#xA;    {&amp;quot;  temp&amp;quot;, SUMMARY_BIT,  0,  STATS_NULL}&#xA;};&#xA;&#xA;static void set_rpi_record(struct module *mod, double st_array[],&#xA;        U_64 pre_array[], U_64 cur_array[], int inter)&#xA;{&#xA;    st_array[0] = cur_array[0]/1000.0;&#xA;}&#xA;&#xA;void mod_register(struct module *mod)&#xA;{   &#xA;    register_mod_fileds(mod, &amp;quot;--rpi&amp;quot;, rpi_usage, rpi_info, 1, read_rpi_stats, set_rpi_record);&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;最后&lt;code&gt;make &amp;amp;&amp;amp; sudo make install&lt;/code&gt;将mod_rpi自定义tsar模块安装好。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;执行&lt;code&gt;tsar --rpi -l -i 1&lt;/code&gt;可以看到每秒一次输出的实时CPU温度&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;hugo@raspberrypi2 ~/projects/tsardevel/rpi $ tsar --rpi -l -i 1&#xA;Time              ---rpi-- &#xA;Time                temp   &#xA;13/04/13-12:57:36  47.08   &#xA;13/04/13-12:57:37  47.08   &#xA;13/04/13-12:57:38  47.08   &#xA;13/04/13-12:57:39  46.54   &#xA;13/04/13-12:57:40  47.08   &#xA;13/04/13-12:57:41  47.08   &#xA;13/04/13-12:57:42  47.62   &#xA;13/04/13-12:57:43  47.08   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;执行&lt;code&gt;tsar&lt;/code&gt;则可以看到间隔为5分钟的历史值&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Time           ---cpu-- ---mem-- ---tcp-- -----traffic---- mmcblk0- mmcblk0p mmcblk0p --sda---  ---load- ---rpi-- &#xA;Time             util     util   retran    pktin  pktout     util     util     util     util     load1     temp   &#xA;13/04/13-12:30   7.77    10.08     5.78     0.00    0.00     8.09     0.00     8.09     1.21      0.28    47.08   &#xA;13/04/13-12:35   6.39    10.11     2.53     0.00    0.00     7.70     0.00     7.70     0.23      0.20    47.62   &#xA;13/04/13-12:40   5.01    10.11     3.88     0.00    0.00     8.49     0.00     8.49     0.29      0.25    47.62   &#xA;13/04/13-12:45   6.24    10.10     3.62     0.00    0.00     6.72     0.00     6.72     0.20      0.09    47.62   &#xA;13/04/13-12:50   2.77    10.11     3.99     0.00    0.00     5.20     0.00     5.20     0.16      0.02    47.08   &#xA;13/04/13-12:55   2.34    10.09     3.94     0.00    0.00     3.93     0.00     3.93     0.00      0.04    47.62   &#xA;&#xA;MAX             14.68    10.27   100.00     0.00    0.00    18.43     0.00    18.43     1.21      0.56    47.62   &#xA;MEAN             2.51     9.08     3.06     0.00    0.00     4.59     0.00     4.59     0.05      0.14     6.15   &#xA;MIN              1.67     7.82     0.00     0.00    0.00     3.14     0.00     3.14     0.10      0.08     0.04   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;tsar很方便吧？ 室温，湿度，网站在线人数等也可以用同样的方法记录。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;利用下面的脚本我们还可以把tsar的数据上传到cosm:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/bin/bash&#xA;####################################################&#xA;# Please customize these values appropriately:&#xA;LOCATION=/home/hugo/projects/dht11&#xA;API_KEY=&#39;&amp;lt;your_api_key&amp;gt;&#39;&#xA;FEED_ID=&#39;&amp;lt;your_feed_id&amp;gt;&#39;&#xA;####################################################&#xA;COSM_URL=http://api.cosm.com/v2/feeds/$FEED_ID?timezone=+8&#xA;&#xA;eval `tsar --cpu --rpi --load --check | awk &#39;{print $8,$10,$14}&#39; | sed -e &#39;s/:/_/g&#39; | sed -e &#39;s/ /\n/g&#39;`&#xA;&#xA;STR=`awk &#39;BEGIN {printf &amp;quot;{\&amp;quot;datastreams\&amp;quot;:[\&#xA;{\&amp;quot;id\&amp;quot;:\&amp;quot;1\&amp;quot;,\&amp;quot;current_value\&amp;quot;:\&amp;quot;%.2f\&amp;quot;},\&#xA;{\&amp;quot;id\&amp;quot;:\&amp;quot;2\&amp;quot;,\&amp;quot;current_value\&amp;quot;:\&amp;quot;%.2f\&amp;quot;},\&#xA;{\&amp;quot;id\&amp;quot;:\&amp;quot;3\&amp;quot;,\&amp;quot;current_value\&amp;quot;:\&amp;quot;%.2f\&amp;quot;}]}&amp;quot;,\&#xA;&#39;$load_load5&#39;,&#39;$rpi_temp&#39;,&#39;$cpu_util&#39;}&#39;`&#xA;&#xA;echo $STR&#xA;echo $STR &amp;gt; $LOCATION/cosm.json&#xA;curl -v --request PUT --header &amp;quot;X-ApiKey: $API_KEY&amp;quot; --data-binary @$LOCATION/cosm.json $COSM_URL&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;参考链接&#34; href=&#34;#参考链接&#34;&gt;&lt;/a&gt;参考链接&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://hugozhu.myalert.info/2013/03/17/03-17-interfacing-temperature-and-humidity-sensor-with-raspberry-pi.html&#34;&gt;http://hugozhu.myalert.info/2013/03/17/03-17-interfacing-temperature-and-humidity-sensor-with-raspberry-pi.html&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>备份Raspberry Pi</title>
      <link>http://hugozhu.myalert.info/2013/04/08/26-backup-raspberry-pi.html</link>
      <pubDate>2013-04-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;树莓派的操作系统安装在SD卡，使用一段时间后还是很有必要备份一下，以防哪天SD卡就坏了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;备份的目的地最方便的还是使用网络存储，我使用的是西部数据的&lt;a href=&#34;http://detail.tmall.com/item.htm?spm=a220m.1000858.1000725.1.Cz5Mlq&amp;amp;id=13865367896&amp;amp;is_b=1&amp;amp;cat_id=50099232&amp;amp;q=mybooklive&amp;amp;rn=638aa11bdda81f8d589bb0e052c57187&#34;&gt;MyBooklive&lt;/a&gt;3T网络硬盘。挺不错的一个产品，功能基本满足我的需求。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;准备好备份目标盘，将Nas的备份目录mount到树莓派:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;mkdir /mnt/backup&#xA;mount -t cifs //mybooklive/Public/Backup /mnt/backup -o guest&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;完整备份&#34; href=&#34;#完整备份&#34;&gt;&lt;/a&gt;完整备份&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;确定相应的SD卡设备ID&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;root@raspberrypi2 ~/bin # fdisk -l&#xA;&#xA;Disk /dev/mmcblk0: 1973 MB, 1973420032 bytes, 3854336 sectors&#xA;Units = sectors of 1 * 512 = 512 bytes&#xA;Sector size (logical/physical): 512 bytes / 512 bytes&#xA;I/O size (minimum/optimal): 512 bytes / 512 bytes&#xA;Disk identifier: 0x0004f23a&#xA;&#xA;        Device Boot      Start         End      Blocks   Id  System&#xA;/dev/mmcblk0p1   *        2048      186367       92160    c  W95 FAT32 (LBA)&#xA;/dev/mmcblk0p2          186368     3667967     1740800   83  Linux&#xA;&#xA;Disk /dev/sda: 2107 MB, 2107637760 bytes, 4116480 sectors&#xA;Units = sectors of 1 * 512 = 512 bytes&#xA;Sector size (logical/physical): 512 bytes / 512 bytes&#xA;I/O size (minimum/optimal): 512 bytes / 512 bytes&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;执行备份&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;root@raspberrypi2 /mnt/backup # dd if=/dev/mmcblk0 of=raspberrypi2.img bs=2M&#xA;941+0 records in&#xA;941+0 records out&#xA;1973420032 bytes (2.0 GB) copied, 786.555 s, 2.5 MB/s&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;增量备份&#34; href=&#34;#增量备份&#34;&gt;&lt;/a&gt;增量备份&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;增量备份最简单的方法是用rsync，每天定时将指定目录下变化的文件保存到备份目录，方法如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;root@raspberrypi:~# crontab -l&#xA;0 3 * * * /root/bin/backup.sh &amp;gt; /var/logs/backup.log 2&amp;gt;&amp;amp;1&#xA;&#xA;&#xA;root@raspberrypi:~# cat /root/bin/backup.sh &#xA;#!/bin/sh&#xA;mount /mnt/backup&#xA;sleep 3&#xA;rsync -v -a --delete --size-only -O --no-t --no-o --no-p --no-g /var/www /mnt/backup/raspberrypi/&#xA;rsync -v -a --delete --size-only -O --no-t --no-o --no-p --no-g /home/hugo /mnt/backup/raspberrypi/&#xA;rsync -v -a --delete --size-only -O --no-l --no-t --no-o --no-p --no-g /etc /mnt/backup/raspberrypi/&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Raspberry Pi的GPIO中断编程</title>
      <link>http://hugozhu.myalert.info/2013/04/08/27-interrupts-with-gpio-pins.html</link>
      <pubDate>2013-04-08 12:00:00 +0800</pubDate>
      <description>&#xA;&#xA;&lt;p&gt;&lt;h1&gt;目录：&lt;/h1&gt;&lt;nav&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_0&#34;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_1&#34;&gt;应用&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_2&#34;&gt;wiringPi&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_3&#34;&gt;示例代码&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_4&#34;&gt;RPi.GPIO&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_5&#34;&gt;参考链接&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/nav&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_0&#34;&gt;背景介绍&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;树莓派的GPIO引脚不仅可以输出高低电平，也可以当做输入端口（可以想象成键盘输入），当GPIO接入的是高电平，GPIO的值可以认为是1，如果是低电平则是0。如下图所示，可以使用一个Push Button开关按键来控制GPIO 25（BCM Numbering）的高低电平以达到控制的目的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://www.evernote.com/shard/s26/sh/bd720803-1b71-454d-98a2-cf0e907df688/649d6eb30376f8a378ef3e8a7cc3c552/deep/0/Screenshot%204/8/13%2011:25%20PM.jpg?noteKey=649d6eb30376f8a378ef3e8a7cc3c552&amp;suffix=deep%2F0%2FScreenshot+4%2F8%2F13+11%3A25+PM.jpg&amp;noteGuid=bd720803-1b71-454d-98a2-cf0e907df688&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;GPIO 25和VCC（3.3V）之间通过R1（10K欧姆）和R2（1K欧姆）&lt;a href=&#34;https://zh.wikipedia.org/zh/上拉电阻&#34;&gt;上拉电阻&lt;/a&gt;相连，当按键未被按下时，GPIO 25上拉到VCC，程序可以读到1，当按键按下时，GPIO 25被下拉电阻R2拉到GND（0V），程序可以读到0。如果不加R1，而GPIO 25不小心被设置成输出低电平时，将直接和VCC相连而造成短路，这样可能会烧掉这个引脚，所以加上限流电阻R1后，即使发生这样的情况，也不会出现短路情况。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_1&#34;&gt;应用&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;如果我们需要根据GPIO 25的值来控制树莓派，比如按下按钮时希望点亮某个LED或在液晶上显示当前时间，就需要通过程序来获取状态的变化。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一种常见的做法是在循环里不断读取该引脚的状态，当发生对应的变化的时执行控制逻辑，但显而易见，这种做法很消耗CPU，如果在循环增加&lt;code&gt;sleep(1000)&lt;/code&gt;这样的调用，又很容易错过按键变化。较好的做法则是通过&lt;a href=&#34;http://zh.wikipedia.org/wiki/中断&#34;&gt;中断&lt;/a&gt;来实现。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;最新的树莓派Raspbian和Arch Linux内核都已经包含了GPIO的中断处理支持。但使用前需要将指定GPIO引脚输出，方法如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先可以通过命令&lt;code&gt;echo 25 &amp;gt; /sys/class/gpio/export&lt;/code&gt;导出GPIO 25端口，执行成功后在相应的目录下看到以下文件，得益于Linux下&lt;strong&gt;一切都是文件&lt;/strong&gt;的设计理念，GPIO的状态可以通过&lt;code&gt;value&lt;/code&gt;文件来获取，这样就可以利用Linux的poll/epoll来获取&lt;code&gt;value&lt;/code&gt;文件的变化(这点和Linux高性能网络编程是类似的)。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;root@raspberrypi2 ~/projects/interrupt_test # ls -l /sys/class/gpio/gpio25/&#xA;total 0&#xA;-rw-r--r-- 1 root root 4096 Apr  8 23:56 active_low&#xA;-rw-r--r-- 1 root root 4096 Apr  8 22:29 direction&#xA;-rw-r--r-- 1 root root 4096 Apr  8 22:29 edge&#xA;drwxr-xr-x 2 root root    0 Apr  8 23:56 power&#xA;lrwxrwxrwx 1 root root    0 Apr  8 23:56 subsystem -&amp;gt; ../../../../class/gpio&#xA;-rw-r--r-- 1 root root 4096 Apr  8 22:08 uevent&#xA;-rw-r--r-- 1 root root 4096 Apr  8 22:29 value&#xA;root@raspberrypi2 ~/projects/interrupt_test # &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_2&#34;&gt;wiringPi&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://projects.drogon.net/raspberry-pi/wiringpi/functions/&#34;&gt;wiringPi&lt;/a&gt;库封装了一个简单的接口，传入一个回调函数，当事件发生时传入的函数将被调用。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;int wiringPiISR (int pin, int edgeType,  void (*function)(void)) ;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;其最主要的部分的实现代码是：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;int waitForInterruptSys (int pin, int mS)&#xA;{&#xA;  int fd, x ;&#xA;  uint8_t c ;&#xA;  struct pollfd polls ;&#xA;&#xA;  if ((fd = sysFds [pin &amp;amp; 63]) == -1)&#xA;    return -2 ;&#xA;&#xA;// Setup poll structure&#xA;&#xA;  polls.fd     = fd ;&#xA;  polls.events = POLLPRI ;      // Urgent data!&#xA;&#xA;// Wait for it ...&#xA;&#xA;  x = poll (&amp;amp;polls, 1, mS) ;&#xA;&#xA;// Do a dummy read to clear the interrupt&#xA;//      A one character read appars to be enough.&#xA;&#xA;  (void)read (fd, &amp;amp;c, 1) ;&#xA;&#xA;  return x ;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_3&#34;&gt;示例代码&lt;/h1&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;string.h&amp;gt;&#xA;#include &amp;lt;errno.h&amp;gt;&#xA;#include &amp;lt;stdlib.h&amp;gt;&#xA;#include &amp;lt;wiringPi.h&amp;gt;&#xA;&#xA;&#xA;// What GPIO input are we using?&#xA;//      This is a wiringPi pin number&#xA;&#xA;#define BUTTON_PIN      6&#xA;&#xA;static volatile int globalCounter = 0 ;&#xA;&#xA;&#xA;void myInterrupt (void)&#xA;{&#xA;  ++globalCounter ;&#xA;}&#xA;&#xA;&#xA;int main (void)&#xA;{&#xA;  int myCounter = 0 ;&#xA;&#xA;  if (wiringPiSetup () &amp;lt; 0)&#xA;  {&#xA;    fprintf (stderr, &amp;quot;Unable to setup wiringPi: %s\n&amp;quot;, strerror (errno)) ;&#xA;    return 1 ;&#xA;  }&#xA;&#xA;  if (wiringPiISR (BUTTON_PIN, INT_EDGE_FALLING, &amp;amp;myInterrupt) &amp;lt; 0)&#xA;  {&#xA;    fprintf (stderr, &amp;quot;Unable to setup ISR: %s\n&amp;quot;, strerror (errno)) ;&#xA;    return 1 ;&#xA;  }&#xA;&#xA;&#xA;  for (;;)&#xA;  {&#xA;    printf (&amp;quot;Waiting ... &amp;quot;) ; fflush (stdout) ;&#xA;&#xA;    while (myCounter == globalCounter)&#xA;      delay (100) ;&#xA;&#xA;    printf (&amp;quot; Done. counter: %5d\n&amp;quot;, globalCounter) ;&#xA;    myCounter = globalCounter ;&#xA;  }&#xA;&#xA;  return 0 ;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_4&#34;&gt;RPi.GPIO&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;Python的PRI.GPIO库也对中断进行了封装，以下是使用例子，差别在于wiringPi支持多线程，允许在等待中断的时候干点别的。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python2.7  &#xA;# script by Alex Eames http://RasPi.tv/  &#xA;# http://raspi.tv/2013/how-to-use-interrupts-with-python-on-the-raspberry-pi-and-rpi-gpio  &#xA;import RPi.GPIO as GPIO  &#xA;GPIO.setmode(GPIO.BCM)  &#xA;  &#xA;# GPIO 25 set up as input. It is pulled up to stop false signals  &#xA;GPIO.setup(25, GPIO.IN, pull_up_down=GPIO.PUD_UP)  &#xA;  &#xA;print &amp;quot;Make sure you have a button connected so that when pressed&amp;quot;  &#xA;print &amp;quot;it will connect GPIO port 23 (pin 16) to GND (pin 6)\n&amp;quot;  &#xA;raw_input(&amp;quot;Press Enter when ready\n&amp;gt;&amp;quot;)  &#xA;  &#xA;print &amp;quot;Waiting for falling edge on port 23&amp;quot;  &#xA;# now the program will do nothing until the signal on port 23   &#xA;# starts to fall towards zero. This is why we used the pullup  &#xA;# to keep the signal high and prevent a false interrupt  &#xA;  &#xA;print &amp;quot;During this waiting time, your computer is not&amp;quot;   &#xA;print &amp;quot;wasting resources by polling for a button press.\n&amp;quot;  &#xA;print &amp;quot;Press your button when ready to initiate a falling edge interrupt.&amp;quot;  &#xA;while 1:&#xA;    try:  &#xA;        GPIO.wait_for_edge(25, GPIO.FALLING)  &#xA;        print &amp;quot;\nFalling edge detected. Now your program can continue with&amp;quot;  &#xA;        print &amp;quot;whatever was waiting for a button press.&amp;quot;  &#xA;    except KeyboardInterrupt:  &#xA;        GPIO.cleanup()       # clean up GPIO on CTRL+C exit  &#xA;GPIO.cleanup()           # clean up GPIO on normal exit  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_5&#34;&gt;参考链接&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://projects.drogon.net/raspberry-pi/wiringpi/functions/&#34;&gt;https://projects.drogon.net/raspberry-pi/wiringpi/functions/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://raspi.tv/2013/how-to-use-interrupts-with-python-on-the-raspberry-pi-and-rpi-gpio&#34;&gt;http://raspi.tv/2013/how-to-use-interrupts-with-python-on-the-raspberry-pi-and-rpi-gpio&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>在Raspberry Pi上使用硬件SPI</title>
      <link>http://hugozhu.myalert.info/2013/04/05/25-get-spi-working-on-raspberry-pi-spi.html</link>
      <pubDate>2013-04-05 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;什么是spi&#34; href=&#34;#什么是spi&#34;&gt;&lt;/a&gt;什么是SPI&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;SPI (Serial Peripheral Interface)，是一种高速，全双工，同步的通信总线协议，基于SPI的设备需要4根线：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://www.evernote.com/shard/s26/sh/61dba789-b17b-4570-b124-03925a97a4bf/4e64405c3b1a486f7aa4b9451e142b32/deep/0/Screenshot%204/5/13%204:27%20PM.jpg&#xA;&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;SDO / MOSI - 主设备数据输出，从设备数据输入&lt;/li&gt;&#xA;&lt;li&gt;SDI / MISO - 主设备数据输入，从设备数据输出&lt;/li&gt;&#xA;&lt;li&gt;SCLK / CLK - 时钟信号，由主设备产生&lt;/li&gt;&#xA;&lt;li&gt;CS / SS - 从设备使能信号，由主设备控制&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;通过CS，主设备可以控制和哪个从设备通信。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;bit-banging&#34; href=&#34;#bit-banging&#34;&gt;&lt;/a&gt;Bit Banging&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Bit-banging是一种用软件替代专职硬件的串行通信的技术。软件直接对微处理器的管脚的状态进行设置和采样，其功能涵盖诸如：时钟，电平，同步等所有参数。与此不同的是（传统的串行通信技术中），专职硬件诸如 modem、UART 或者 位移寄存器等一般是用来处理这些参数并且提供一个（缓存）的数据接口，软件在这种情况下同信号处理无关。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;bit-banging 具有明显优点诸如：让相同的设备运行不同的协议而只需很小的（甚至不需）硬件的改动。借助很少的额外设备，我们也许可以从数字管脚（数字终端）可以得到视频信号。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;bit-banging 也有一些明显的缺点。在软件仿真的过程中消耗的能量比同样功能的专职硬件大。微处理器过忙地从管脚采样和发送采样信号到管脚。在同等微处理器处理能力下，系统常常会有些噪音。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在Rasperry Pi上使用Bit Banging在实际情况下有可能因为操作系统调度造成时钟信号不稳定而使设备收到错误的消息，具体的表现就是Nokia 5110屏在长时间运行过程中出现白屏或花屏现象，如下图：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://ww2.sinaimg.cn/bmiddle/6bc40342jw1e3dzvsfxblj.jpg&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;采用硬件SPI，由Pi的管脚14号Pin（左边倒数第二个）SCLK发出一定频率的时钟信号。经过测试，这种方法产生的时钟信号比Bit Banging软件模拟产生的信号要稳定很多。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/small/6bc40342jw1e3f1s62pnuj.jpg&#34;/&gt;&#xA;软件模拟时钟信号波形&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/small/6bc40342jw1e3f6d4wsjij.jpg&#34;/&gt;&#xA;硬件SPI时钟信号波形&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;测试pi的硬件spi&#34; href=&#34;#测试pi的硬件spi&#34;&gt;&lt;/a&gt;测试Pi的硬件SPI&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;确认内核支持&#34; href=&#34;#确认内核支持&#34;&gt;&lt;/a&gt;确认内核支持&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;root@raspberrypi2 ~/projects/spi_test # ls -la /dev/spi*&#xA;crw------- 1 root root 153, 0 Jan  1  1970 /dev/spidev0.0&#xA;crw------- 1 root root 153, 1 Jan  1  1970 /dev/spidev0.1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;测试代码&#34; href=&#34;#测试代码&#34;&gt;&lt;/a&gt;测试代码&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;下载 &lt;a href=&#34;http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/plain/Documentation/spi/spidev_test.c&#34;&gt;spidev_test.c&lt;/a&gt; 或拷贝下面的代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/*&#xA; * SPI testing utility (using spidev driver)&#xA; *&#xA; * Copyright (c) 2007  MontaVista Software, Inc.&#xA; * Copyright (c) 2007  Anton Vorontsov &amp;lt;avorontsov@ru.mvista.com&amp;gt;&#xA; *&#xA; * This program is free software; you can redistribute it and/or modify&#xA; * it under the terms of the GNU General Public License as published by&#xA; * the Free Software Foundation; either version 2 of the License.&#xA; *&#xA; * Cross-compile with cross-gcc -I/path/to/cross-kernel/include&#xA; */&#xA;&#xA;#include &amp;lt;stdint.h&amp;gt;&#xA;#include &amp;lt;unistd.h&amp;gt;&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;stdlib.h&amp;gt;&#xA;#include &amp;lt;getopt.h&amp;gt;&#xA;#include &amp;lt;fcntl.h&amp;gt;&#xA;#include &amp;lt;sys/ioctl.h&amp;gt;&#xA;#include &amp;lt;linux/types.h&amp;gt;&#xA;#include &amp;lt;linux/spi/spidev.h&amp;gt;&#xA;&#xA;#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))&#xA;&#xA;static void pabort(const char *s)&#xA;{&#xA;    perror(s);&#xA;    abort();&#xA;}&#xA;&#xA;static const char *device = &amp;quot;/dev/spidev1.1&amp;quot;;&#xA;static uint8_t mode;&#xA;static uint8_t bits = 8;&#xA;static uint32_t speed = 500000;&#xA;static uint16_t delay;&#xA;&#xA;static void transfer(int fd)&#xA;{&#xA;    int ret;&#xA;    uint8_t tx[] = {&#xA;        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,&#xA;        0x40, 0x00, 0x00, 0x00, 0x00, 0x95,&#xA;        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,&#xA;        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,&#xA;        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,&#xA;        0xDE, 0xAD, 0xBE, 0xEF, 0xBA, 0xAD,&#xA;        0xF0, 0x0D,&#xA;    };&#xA;    uint8_t rx[ARRAY_SIZE(tx)] = {0, };&#xA;    struct spi_ioc_transfer tr = {&#xA;        .tx_buf = (unsigned long)tx,&#xA;        .rx_buf = (unsigned long)rx,&#xA;        .len = ARRAY_SIZE(tx),&#xA;        .delay_usecs = delay,&#xA;        .speed_hz = speed,&#xA;        .bits_per_word = bits,&#xA;    };&#xA;&#xA;    ret = ioctl(fd, SPI_IOC_MESSAGE(1), &amp;amp;tr);&#xA;    if (ret &amp;lt; 1)&#xA;        pabort(&amp;quot;can&#39;t send spi message&amp;quot;);&#xA;&#xA;    for (ret = 0; ret &amp;lt; ARRAY_SIZE(tx); ret++) {&#xA;        if (!(ret % 6))&#xA;            puts(&amp;quot;&amp;quot;);&#xA;        printf(&amp;quot;%.2X &amp;quot;, rx[ret]);&#xA;    }&#xA;    puts(&amp;quot;&amp;quot;);&#xA;}&#xA;&#xA;static void print_usage(const char *prog)&#xA;{&#xA;    printf(&amp;quot;Usage: %s [-DsbdlHOLC3]\n&amp;quot;, prog);&#xA;    puts(&amp;quot;  -D --device   device to use (default /dev/spidev1.1)\n&amp;quot;&#xA;         &amp;quot;  -s --speed    max speed (Hz)\n&amp;quot;&#xA;         &amp;quot;  -d --delay    delay (usec)\n&amp;quot;&#xA;         &amp;quot;  -b --bpw      bits per word \n&amp;quot;&#xA;         &amp;quot;  -l --loop     loopback\n&amp;quot;&#xA;         &amp;quot;  -H --cpha     clock phase\n&amp;quot;&#xA;         &amp;quot;  -O --cpol     clock polarity\n&amp;quot;&#xA;         &amp;quot;  -L --lsb      least significant bit first\n&amp;quot;&#xA;         &amp;quot;  -C --cs-high  chip select active high\n&amp;quot;&#xA;         &amp;quot;  -3 --3wire    SI/SO signals shared\n&amp;quot;);&#xA;    exit(1);&#xA;}&#xA;&#xA;static void parse_opts(int argc, char *argv[])&#xA;{&#xA;    while (1) {&#xA;        static const struct option lopts[] = {&#xA;            { &amp;quot;device&amp;quot;,  1, 0, &#39;D&#39; },&#xA;            { &amp;quot;speed&amp;quot;,   1, 0, &#39;s&#39; },&#xA;            { &amp;quot;delay&amp;quot;,   1, 0, &#39;d&#39; },&#xA;            { &amp;quot;bpw&amp;quot;,     1, 0, &#39;b&#39; },&#xA;            { &amp;quot;loop&amp;quot;,    0, 0, &#39;l&#39; },&#xA;            { &amp;quot;cpha&amp;quot;,    0, 0, &#39;H&#39; },&#xA;            { &amp;quot;cpol&amp;quot;,    0, 0, &#39;O&#39; },&#xA;            { &amp;quot;lsb&amp;quot;,     0, 0, &#39;L&#39; },&#xA;            { &amp;quot;cs-high&amp;quot;, 0, 0, &#39;C&#39; },&#xA;            { &amp;quot;3wire&amp;quot;,   0, 0, &#39;3&#39; },&#xA;            { &amp;quot;no-cs&amp;quot;,   0, 0, &#39;N&#39; },&#xA;            { &amp;quot;ready&amp;quot;,   0, 0, &#39;R&#39; },&#xA;            { NULL, 0, 0, 0 },&#xA;        };&#xA;        int c;&#xA;&#xA;        c = getopt_long(argc, argv, &amp;quot;D:s:d:b:lHOLC3NR&amp;quot;, lopts, NULL);&#xA;&#xA;        if (c == -1)&#xA;            break;&#xA;&#xA;        switch (c) {&#xA;        case &#39;D&#39;:&#xA;            device = optarg;&#xA;            break;&#xA;        case &#39;s&#39;:&#xA;            speed = atoi(optarg);&#xA;            break;&#xA;        case &#39;d&#39;:&#xA;            delay = atoi(optarg);&#xA;            break;&#xA;        case &#39;b&#39;:&#xA;            bits = atoi(optarg);&#xA;            break;&#xA;        case &#39;l&#39;:&#xA;            mode |= SPI_LOOP;&#xA;            break;&#xA;        case &#39;H&#39;:&#xA;            mode |= SPI_CPHA;&#xA;            break;&#xA;        case &#39;O&#39;:&#xA;            mode |= SPI_CPOL;&#xA;            break;&#xA;        case &#39;L&#39;:&#xA;            mode |= SPI_LSB_FIRST;&#xA;            break;&#xA;        case &#39;C&#39;:&#xA;            mode |= SPI_CS_HIGH;&#xA;            break;&#xA;        case &#39;3&#39;:&#xA;            mode |= SPI_3WIRE;&#xA;            break;&#xA;        case &#39;N&#39;:&#xA;            mode |= SPI_NO_CS;&#xA;            break;&#xA;        case &#39;R&#39;:&#xA;            mode |= SPI_READY;&#xA;            break;&#xA;        default:&#xA;            print_usage(argv[0]);&#xA;            break;&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;    int ret = 0;&#xA;    int fd;&#xA;&#xA;    parse_opts(argc, argv);&#xA;&#xA;    fd = open(device, O_RDWR);&#xA;    if (fd &amp;lt; 0)&#xA;        pabort(&amp;quot;can&#39;t open device&amp;quot;);&#xA;&#xA;    /*&#xA;     * spi mode&#xA;     */&#xA;    ret = ioctl(fd, SPI_IOC_WR_MODE, &amp;amp;mode);&#xA;    if (ret == -1)&#xA;        pabort(&amp;quot;can&#39;t set spi mode&amp;quot;);&#xA;&#xA;    ret = ioctl(fd, SPI_IOC_RD_MODE, &amp;amp;mode);&#xA;    if (ret == -1)&#xA;        pabort(&amp;quot;can&#39;t get spi mode&amp;quot;);&#xA;&#xA;    /*&#xA;     * bits per word&#xA;     */&#xA;    ret = ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, &amp;amp;bits);&#xA;    if (ret == -1)&#xA;        pabort(&amp;quot;can&#39;t set bits per word&amp;quot;);&#xA;&#xA;    ret = ioctl(fd, SPI_IOC_RD_BITS_PER_WORD, &amp;amp;bits);&#xA;    if (ret == -1)&#xA;        pabort(&amp;quot;can&#39;t get bits per word&amp;quot;);&#xA;&#xA;    /*&#xA;     * max speed hz&#xA;     */&#xA;    ret = ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &amp;amp;speed);&#xA;    if (ret == -1)&#xA;        pabort(&amp;quot;can&#39;t set max speed hz&amp;quot;);&#xA;&#xA;    ret = ioctl(fd, SPI_IOC_RD_MAX_SPEED_HZ, &amp;amp;speed);&#xA;    if (ret == -1)&#xA;        pabort(&amp;quot;can&#39;t get max speed hz&amp;quot;);&#xA;&#xA;    printf(&amp;quot;spi mode: %d\n&amp;quot;, mode);&#xA;    printf(&amp;quot;bits per word: %d\n&amp;quot;, bits);&#xA;    printf(&amp;quot;max speed: %d Hz (%d KHz)\n&amp;quot;, speed, speed/1000);&#xA;&#xA;    transfer(fd);&#xA;&#xA;    close(fd);&#xA;&#xA;    return ret;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;用一根杜邦线将Pi的MISO （GPIO 9）和MOSI (GPIO 10)短接，运行上面的代码应该得到如下输出（如果输出不是这样的，那一定是哪里不对了，重启一下看看行不行）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;root@raspberrypi2 ~/projects/spi_test # ./a.out -D /dev/spidev0.0&#xA;spi mode: 0&#xA;bits per word: 8&#xA;max speed: 500000 Hz (500 KHz)&#xA;&#xA;FF FF FF FF FF FF &#xA;40 00 00 00 00 95 &#xA;FF FF FF FF FF FF &#xA;FF FF FF FF FF FF &#xA;FF FF FF FF FF FF &#xA;DE AD BE EF BA AD &#xA;F0 0D &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;wiringpispi&#34; href=&#34;#wiringpispi&#34;&gt;&lt;/a&gt;wiringPiSPI&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://projects.drogon.net/raspberry-pi/wiringpi/&#34;&gt;wiringPi&lt;/a&gt; 软件包提供了SPI使用的帮助类，接口定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;int wiringPiSPISetup  (int channel, int speed) ;&#xA;int wiringPiSPIDataRW (int channel, unsigned char *data, int len) ;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;使用则非常简单，下面的代码每秒从Pi的MOSI针脚（第13号，左边倒数第三个）发送1个字节：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;wiringPi.h&amp;gt;&#xA;#include &amp;lt;wiringPiSPI.h&amp;gt;&#xA;&#xA;int main (void)&#xA;{&#xA;&#xA;    if (wiringPiSPISetup(0, 5000000) == -1) &#xA;    {&#xA;       return -1;&#xA;    }&#xA;    &#xA;    for (;;) &#xA;    {&#xA;        uint8_t c = 0x00&#xA;        wiringPiSPIDataRW(0, &amp;amp;c, 1);&#xA;        delay(1000);&#xA;    }&#xA;    &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;实际应用&#34; href=&#34;#实际应用&#34;&gt;&lt;/a&gt;实际应用&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;前面介绍过的Nokia 5110是采用飞利浦PC8544芯片驱动的，就是采用SPI协议的。&#xA;采用软件模拟的驱动不是很稳定，改成硬件SPI后就好了，&lt;a href=&#34;https://github.com/hugozhu/rpi/tree/master/lib/PCD8544&#34;&gt;基于wiringPi的实现&lt;/a&gt;, &lt;a href=&#34;https://github.com/hugozhu/rpi/tree/master/pcd8544&#34;&gt;Go的封装&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;参考链接&#34; href=&#34;#参考链接&#34;&gt;&lt;/a&gt;参考链接&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.brianhensley.net/2012/07/getting-spi-working-on-raspberry-pi.html&#34;&gt;http://www.brianhensley.net/2012/07/getting-spi-working-on-raspberry-pi.html&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;百度百科 - &lt;a href=&#34;http://baike.baidu.com/view/245026.htm&#34;&gt;http://baike.baidu.com/view/245026.htm&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/zh/串行通信&#34;&gt;https://zh.wikipedia.org/zh/串行通信&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://projects.drogon.net/understanding-spi-on-the-raspberry-pi/&#34;&gt;https://projects.drogon.net/understanding-spi-on-the-raspberry-pi/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>在Raspberry Pi上使用Google Channel服务搭建实时应用</title>
      <link>http://hugozhu.myalert.info/2013/04/03/24-google-channel-service.html</link>
      <pubDate>2013-04-03 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;前面提到了有关个人网站的&lt;a href=&#34;http://hugozhu.myalert.info/2013/03/27/21-realtime-online-user-counter.html&#34;&gt;实时在线人数&lt;/a&gt;问题，本文要讨论的是如何自己来实现一个这样的统计服务。因为网站也同时部署在Github上，海外用户访问Github镜像网站的访问日志Pi是拿不到的，这怎么办？&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;google-channel-service&#34; href=&#34;#google-channel-service&#34;&gt;&lt;/a&gt;Google Channel Service&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://developers.google.com/appengine/docs/go/channel/overview&#34;&gt;Google Channel Service&lt;/a&gt;允许应用和&lt;a href=&#34;http://appengine.google.com/&#34;&gt;GAE (Google App Engine)&lt;/a&gt; 保持一个长连接，允许应用实时发送消息给JavaScript客户端，而不用让客户端用效率很低的定时轮询获取新消息。这个服务是允许有多个发布者和多个订阅者，也能创建多个主题来关联发布者和订阅者。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用这个服务分两步：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;客户端请求服务器端（部署在GAE上）获取一个Channel的Token：&#xA;&lt;img src=&#34;https://developers.google.com/appengine/images/channel_overview01.png&#34;/&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;客户端根据Channel Token和服务器建立长连接，并开始接收消息，这时其它的客户端（或服务器端）可以想这个通道发送消息&#xA;&lt;img src=&#34;https://developers.google.com/appengine/images/channel_overview02.png&#34;/&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;在线人数统计实现&#34; href=&#34;#在线人数统计实现&#34;&gt;&lt;/a&gt;在线人数统计实现&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;在页面上部署beacon&#34; href=&#34;#在页面上部署beacon&#34;&gt;&lt;/a&gt;在页面上部署beacon&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;通常的网站流量统计是依赖部署在页面上的beacon（Javascript或图片标签）来实现的，这样做的好处是可以直接过滤掉一些机器流量，并且可以将日志集中存储在日志收集服务器上，和网站分离开。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;于是可以利用GAE实现一个简单的Beacon服务，这里采用Go语言来实现，用Java或Python也是可以的。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package counter&#xA;&#xA;import (&#xA;    &amp;quot;encoding/base64&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;time&amp;quot;&#xA;    &amp;quot;net/http&amp;quot;&#xA;&#xA;    &amp;quot;appengine&amp;quot;&#xA;    &amp;quot;appengine/channel&amp;quot;&#xA;)&#xA;&#xA;var GIF []byte&#xA;&#xA;const (&#xA;    TOPIC = &amp;quot;counter&amp;quot;&#xA;)&#xA;&#xA;func init() {&#xA;    GIF, _ = base64.StdEncoding.DecodeString(&amp;quot;R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7&amp;quot;)&#xA;    &#xA;    &#xA;    http.HandleFunc(&amp;quot;/beacon.gif&amp;quot;, handler)&#xA;    http.HandleFunc(&amp;quot;/new_token&amp;quot;, handler_new_token)    &#xA;}&#xA;&#xA;func handler(w http.ResponseWriter, r *http.Request) {&#xA;    context := appengine.NewContext(r)&#xA;&#xA;    now := time.Now()&#xA;    expire := now.AddDate(30, 0, 0)&#xA;    zcookie, _ := r.Cookie(&amp;quot;z&amp;quot;)&#xA;    if zcookie == nil {&#xA;        zcookie = &amp;amp;http.Cookie{}&#xA;        zcookie.Name = &amp;quot;z&amp;quot;&#xA;        zcookie.Value = make_hash(&amp;quot;&amp;lt;your_salt&amp;gt;&amp;quot;, r.RemoteAddr, now.UnixNano())&#xA;        zcookie.Expires = expire&#xA;        zcookie.Path = &amp;quot;/&amp;quot;&#xA;        http.SetCookie(w, zcookie)&#xA;    }&#xA;&#xA;    w.Header().Set(&amp;quot;Content-type&amp;quot;, &amp;quot;image/gif&amp;quot;)&#xA;    w.Header().Set(&amp;quot;Cache-control&amp;quot;, &amp;quot;no-cache, must-revalidate&amp;quot;)&#xA;    w.Header().Set(&amp;quot;Expires&amp;quot;, &amp;quot;Sat, 26 Jul 1997 05:00:00 GMT&amp;quot;)&#xA;&#xA;    fmt.Fprintf(w, &amp;quot;%s&amp;quot;, GIF)&#xA;&#xA;    channel.Send(context, TOPIC, zcookie.Value+&amp;quot;\n&amp;quot;+r.RemoteAddr+&amp;quot;\n&amp;quot;+r.Referer()+&amp;quot;\n&amp;quot;+r.UserAgent())&#xA;}&#xA;&#xA;func handler_new_token(w http.ResponseWriter, r *http.Request) {&#xA;    c := appengine.NewContext(r)&#xA;    tok, err := channel.Create(c, TOPIC)    &#xA;    callback := r.FormValue(&amp;quot;callback&amp;quot;) &#xA;    if err != nil {&#xA;        http.Error(w, &amp;quot;Couldn&#39;t create Channel&amp;quot;, http.StatusInternalServerError)&#xA;        c.Errorf(&amp;quot;channel.Create: %v&amp;quot;, err)&#xA;        return&#xA;    }&#xA;    if callback == &amp;quot;&amp;quot; {&#xA;        w.Header().Set(&amp;quot;Content-type&amp;quot;, &amp;quot;text/javascript&amp;quot;)&#xA;        fmt.Fprintf(w, &amp;quot;%s&amp;quot;, tok)&#xA;    } else {&#xA;        fmt.Fprintf(w, callback+&amp;quot;(&#39;%s&#39;)&amp;quot;, tok)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;代码最后一行是将访问日志实时通过Channel发送出去，该通道有一个指定的主题，这样订阅该主题的客户端都可以收到相应的消息。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;app.yaml&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;application: &amp;lt;your_app_name&amp;gt;&#xA;version: 1&#xA;runtime: go&#xA;api_version: go1&#xA;&#xA;handlers:&#xA;- url: /(.*).html&#xA;  static_files: html/\1.html&#xA;  upload: html/(.*\.html)&#xA;&#xA;- url: (/.*)&#xA;  script: _go_app&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;将该应用发布到GAE后，可以通过在页面底部放置&lt;code&gt;&amp;lt;img src=&amp;quot;http://&amp;lt;your_app_name&amp;gt;.appspot.com/beacon.gif/&amp;gt;&amp;quot;&lt;/code&gt;标签来将网站的流量引到GAE，并通过Channel发布出去。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;接收实时消息&#34; href=&#34;#接收实时消息&#34;&gt;&lt;/a&gt;接收实时消息&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;比较遗憾的是Google只提供了Javascript库来供浏览器接收实时消息，相应的使用代码如下。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;&#xA;    &amp;lt;body&amp;gt;&#xA;        &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;/_ah/channel/jsapi&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&#xA;        &amp;lt;script&amp;gt;&#xA;            function onOpened() {&#xA;                alert(&amp;quot;onOpened&amp;quot;)&#xA;            }&#xA;&#xA;            function onMessage(obj) {&#xA;                console.log(obj)&#xA;                alert(&amp;quot;onMessage: &amp;quot; + obj.data)&#xA;            }&#xA;&#xA;            function onError(x) {&#xA;                alert(&amp;quot;onError:&amp;quot;+x)&#xA;            }&#xA;&#xA;            function onClose(x) {&#xA;                alert(&amp;quot;onClose:&amp;quot;+x)&#xA;            }&#xA;&#xA;            function init(token) {            &#xA;                channel = new goog.appengine.Channel(token);&#xA;                socket = channel.open();&#xA;                socket.onopen = onOpened;&#xA;                socket.onmessage = onMessage;&#xA;                socket.onerror = onError;&#xA;                socket.onclose = onClose;&#xA;            }&#xA;        &amp;lt;/script&amp;gt;&#xA;&#xA;        &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;/new_token?callback=init&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;     &#xA;       &#xA;    &amp;lt;/body&amp;gt;&#xA;&amp;lt;/html&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;显然Javascript是不能满足统计网站实时流量的需求，我们需要一个服务器端能接收消息的方法，经过对Javascript的逻辑分析，我实现了一个同样能接收消息的&lt;a href=&#34;https://github.com/hugozhu/gae-channel&#34;&gt;Go语言客户端&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用方法如下：&#xA;&lt;code&gt;go get github.com/hugozhu/gae-channel&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    . &amp;quot;github.com/hugozhu/gae-channel&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    log.Println(&amp;quot;started&amp;quot;)&#xA;    stop_chan := make(chan bool)&#xA;    channel := NewChannel(&amp;quot;http://&amp;lt;your_app_name&amp;gt;.appspot.com/new_token&amp;quot;)&#xA;    socket := channel.Open()&#xA;    socket.OnOpened = func() {&#xA;        log.Println(&amp;quot;socket opened!&amp;quot;)&#xA;    }&#xA;&#xA;    socket.OnClose = func() {&#xA;        log.Println(&amp;quot;socket closed!&amp;quot;)&#xA;        stop_chan &amp;lt;- true&#xA;    }&#xA;&#xA;    socket.OnMessage = func(msg *Message) {&#xA;        log.Println(msg.ToString())&#xA;    }&#xA;&#xA;    socket.OnError = func(err error) {&#xA;        log.Println(&amp;quot;error:&amp;quot;, err)&#xA;    }&#xA;&#xA;    &amp;lt;-stop_chan&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;实时分析日志&#34; href=&#34;#实时分析日志&#34;&gt;&lt;/a&gt;实时分析日志&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;在Pi上利用Channel客户端库，脚本可以实时获取访问日志，可以通过最近15分钟内的日志计算出每分钟独立访客数和PV数，最后可以在Pi的液晶屏幕用柱状图显示出来。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;analytics&amp;quot;&#xA;    &amp;quot;encoding/json&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;strings&amp;quot;&#xA;    &amp;quot;time&amp;quot;&#xA;    &#xA;    . &amp;quot;github.com/hugozhu/gae-channel&amp;quot;&#xA;    . &amp;quot;github.com/hugozhu/rpi&amp;quot;&#xA;    &amp;quot;github.com/hugozhu/rpi/pcd8544&amp;quot;&#xA;)&#xA;&#xA;// pin setup&#xA;const (&#xA;    _din     = 3&#xA;    _sclk    = 5&#xA;    _dc      = 2&#xA;    _rst     = 0&#xA;    _cs      = 1&#xA;    contrast = 43&#xA;)&#xA;&#xA;var pv = analytics.NewPV(5, 60)&#xA;var uv = analytics.NewUV(5 * 60)&#xA;&#xA;&#xA;func init() {&#xA;    //must be called before everything else!&#xA;    WiringPiSetup()&#xA;    pcd8544.LCDInit(_sclk, _din, _dc, _cs, _rst, contrast)&#xA;}&#xA;&#xA;&#xA;func main() {&#xA;&#xA;    log.Println(&amp;quot;started&amp;quot;)&#xA;    stop_chan := make(chan bool)&#xA;&#xA;    channel := NewChannel(&amp;quot;http://&amp;lt;your_app_name&amp;gt;.appspot.com/new_token&amp;quot;)&#xA;    socket := channel.Open()&#xA;    socket.OnOpened = func() {&#xA;        log.Println(&amp;quot;socket opened!&amp;quot;)&#xA;    }&#xA;&#xA;    socket.OnClose = func() {&#xA;        log.Println(&amp;quot;socket closed!&amp;quot;)&#xA;        stop_chan &amp;lt;- true&#xA;    }&#xA;&#xA;    socket.OnMessage = func(msg *Message) {&#xA;        if msg.Level() &amp;gt;= 3 &amp;amp;&amp;amp; msg.Child.Key == &amp;quot;c&amp;quot; {&#xA;            v1 := *msg.Child.Child.Val&#xA;            if len(v1) &amp;gt; 0 {&#xA;                s := &amp;quot;[&amp;quot; + v1[0].Key + &amp;quot;]&amp;quot;&#xA;                var v []string&#xA;                json.Unmarshal([]byte(s), &amp;amp;v)&#xA;                if len(v) == 2 &amp;amp;&amp;amp; v[0] == &amp;quot;ae&amp;quot; {&#xA;                    s = v[1]&#xA;                    v = strings.Split(s, &amp;quot;\n&amp;quot;)&#xA;                    zcookie := v[0]&#xA;                    t := time.Now()&#xA;                    pv.AddOne(t)&#xA;                    uv.AddOne(zcookie, t)&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&#xA;    socket.OnError = func(err error) {&#xA;        log.Println(&amp;quot;error:&amp;quot;, err)&#xA;    }&#xA;&#xA;    go func() {&#xA;        for {&#xA;            pcd8544.LCDclear()&#xA;            pcd8544.LCDdrawstring(0, 0, time.Now().Format(&amp;quot;06-01-02 15:04&amp;quot;))&#xA;            // pcd8544.LCDdrawline(0, 10, 83, 10, pcd8544.BLACK)&#xA;            pcd8544.LCDdrawstring(0, 14, fmt.Sprintf(&amp;quot;UV: %d&amp;quot;, uv.Sum()))&#xA;            pcd8544.LCDdrawstring(0, 24, fmt.Sprintf(&amp;quot;PV: %d&amp;quot;, pv.Sum()))&#xA;            pcd8544.LCDdisplay()&#xA;            time.Sleep(5 * time.Second)&#xA;        }&#xA;    }()&#xA;&#xA;    &amp;lt;-stop_chan&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;实际效果&#34; href=&#34;#实际效果&#34;&gt;&lt;/a&gt;实际效果&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://ww4.sinaimg.cn/bmiddle/6bc40342jw1e3dzagtsl6j.jpg&#34;/&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>并发编程之内存屏障</title>
      <link>http://hugozhu.myalert.info/2013/03/28/22-memory-barriers-or-fences.html</link>
      <pubDate>2013-03-28 12:00:00 +0800</pubDate>
      <description>&#xA;&#xA;&lt;p&gt;原文地址：&lt;a href=&#34;http://mechanical-sympathy.blogspot.com/2011/07/memory-barriersfences.html&#34;&gt;&lt;code&gt;http://mechanical-sympathy.blogspot.com/2011/07/memory-barriersfences.html&lt;/code&gt;&lt;/a&gt; 或 &lt;a href=&#34;http://ifeve.com/memory-barriersfences/&#34;&gt;&lt;code&gt;http://ifeve.com/memory-barriersfences/&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;关键词：Load Barrier, Store Barrier, Full Barrier&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;h1&gt;目录：&lt;/h1&gt;&lt;nav&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_0&#34;&gt;Store Barrier&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_1&#34;&gt;Load Barrier&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_2&#34;&gt;Full Barrier&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_3&#34;&gt;Java内存模型&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_4&#34;&gt;原子指令和Software Locks&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_5&#34;&gt;内存屏障的性能影响&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/nav&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;本文我将和大家讨论并发编程中最基础的一项技术：内存屏障或内存栅栏，也就是让一个CPU处理单元中的内存状态对其它处理单元可见的一项技术。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CPU使用了很多优化技术来达成一个事实：CPU执行单元的速度要远超主存访问速度。在我上一篇文章 &amp;ldquo;Write Combing - 合并写&amp;rdquo;中我已经介绍了其中的一项技术。CPU避免内存访问延迟最常见的技术是将指令管道化，然后尽量重排这些管道的执行以最大利用缓存而把因为缓存未命中引起的延迟降到最小。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当一个程序执行时指令是否被重排并不重要，只要最终的结果是一样的。例如，在一个循环里，如果循环体内没用到这个计数器，循环的计数器什么时候更新（在循环开始，中间还是最后）并不重要。编译器和CPU可以自由的重排指令以最佳的利用CPU，只要下一次循环前更新该计数器即可。并且在循环执行中，这个变量可能一直存在寄存器上，并没有被推到缓存或主存，这样这个变量对其他CPU来说一直都是不可见的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CPU核内部包含了多个执行单元。例如，现代Intel CPU包含了6个执行单元，可以组合进行算术运算，逻辑条件判断及内存操作。每个执行单元可以执行上述任务的某种组合。这些执行单元是并行执行的，这样指令也就是在并行执行。但如果站在另一个CPU角度看，这也就产生了程序顺序的另一种不确定性。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;最后，当一个缓存失效发生时，现代CPU可以先假设一个内存载入的值并根据这个假设值继续执行，直到内存载入返回确切的值。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://ifeve.com/wp-content/uploads/2013/03/cpu.png&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;CPU核&#xA;  |&#xA;  V&#xA;寄存器&#xA;  |&#xA;  V&#xA;执行单元 -&amp;gt; Load/Store缓冲区-&amp;gt;L1 Cache ---&amp;gt;L3 Cache--&amp;gt;内存控制器--&amp;gt;主存&#xA;       |                                   |&#xA;       +-&amp;gt; Write Combine缓冲区-&amp;gt;L2 Cache ---+&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;代码顺序并不是真正的执行顺序，CPU和编译器可以各种优化只要有空间提高性能。缓存和主存的读取会利用load, store和write-combining缓冲区来缓冲和重排。这些缓冲区是查找速度很快的关联队列，当一个后来发生的load需要读取上一个store的值，而该值还没有到达缓存，查找是必需的，上图描绘的是一个简化的现代多核CPU，从上图可以看出执行单元可以利用本地寄存器和缓冲区来管理和缓存子系统的交互。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在多线程环境里需要使用技术来使得程序结果尽快可见。这篇文章里我不会涉及到 Cache Conherence 的概念。请先假定一个事实：一旦内存数据被推送到缓存，就会有消息协议来确保所有的缓存会对所有的共享数据同步并保持一致。这个使内存数据对CPU核可见的技术被称为内存屏障或内存栅栏。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;内存屏障提供了两个功能。首先，它们通过确保从另一个CPU来看屏障的两边的所有指令都是正确的程序顺序，而保持程序顺序的外部可见性；其次它们可以实现内存数据可见性，确保内存数据会同步到CPU缓存子系统。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;大多数的内存屏障都是复杂的话题。在不同的CPU架构上内存屏障的实现非常不一样。相对来说Intel CPU的强内存模型比DEC Alpha的弱复杂内存模型（缓存不仅分层了，还分区了）更简单。因为x86处理器是在多线程编程中最常见的，下面我尽量用x86的架构来阐述。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_0&#34;&gt;Store Barrier&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;Store屏障，是x86的&amp;rdquo;&lt;strong&gt;sfence&lt;/strong&gt;&amp;ldquo;指令，强制所有在store屏障指令之前的store指令，都在该store屏障指令执行之前被执行，并把store缓冲区的数据都刷到CPU缓存。这会使得程序状态对其它CPU可见，这样其它CPU可以根据需要介入。一个实际的好例子是Disruptor中的&lt;a href=&#34;http://code.google.com/p/disruptor/source/browse/trunk/code/src/main/com/lmax/disruptor/BatchEventProcessor.java&#34;&gt;BatchEventProcessor&lt;/a&gt;。当序列Sequence被一个消费者更新时，其它消费者(Consumers)和生产者（Producers）知道该消费者的进度，因此可以采取合适的动作。所以屏障之前发生的内存更新都可见了。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;private volatile long sequence = RingBuffer.INITIAL_CURSOR_VALUE;&#xA; &#xA;// from inside the run() method&#xA; &#xA;T event = null;&#xA;long nextSequence = sequence.get() + 1L;&#xA;while (running)&#xA;{&#xA;    try&#xA;    {&#xA;        final long availableSequence = barrier.waitFor(nextSequence);&#xA; &#xA;        while (nextSequence &amp;lt;= availableSequence)&#xA;        {&#xA;            event = ringBuffer.get(nextSequence);&#xA;            boolean endOfBatch = nextSequence == availableSequence;&#xA;            eventHandler.onEvent(event, nextSequence, endOfBatch);&#xA;            nextSequence++;&#xA;        }&#xA; &#xA;        sequence.set(nextSequence - 1L); &#xA;        // store barrier inserted here !!!&#xA;    }&#xA;    catch (final Exception ex)&#xA;    {&#xA;        exceptionHandler.handle(ex, nextSequence, event);&#xA;        sequence.set(nextSequence);&#xA;        // store barrier inserted here !!!&#xA;        nextSequence++;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_1&#34;&gt;Load Barrier&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;Load屏障，是x86上的&amp;rdquo;&lt;strong&gt;ifence&lt;/strong&gt;&amp;ldquo;指令，强制所有在load屏障指令之后的load指令，都在该load屏障指令执行之后被执行，并且一直等到load缓冲区被该CPU读完才能执行之后的load指令。这使得从其它CPU暴露出来的程序状态对该CPU可见，这之后CPU可以进行后续处理。一个好例子是上面的BatchEventProcessor的sequence对象是放在屏障后被生产者或消费者使用。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_2&#34;&gt;Full Barrier&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;Full屏障，是x86上的&amp;rdquo;&lt;strong&gt;mfence&lt;/strong&gt;&amp;ldquo;指令，复合了load和save屏障的功能。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_3&#34;&gt;Java内存模型&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Java_Memory_Model&#34;&gt;Java内存模型&lt;/a&gt;中&lt;strong&gt;volatile&lt;/strong&gt;变量在写操作之后会插入一个store屏障，在读操作之前会插入一个load屏障。类的&lt;strong&gt;final&lt;/strong&gt;字段会在初始化后插入一个store屏障来确保final字段在构造函数完成可被使用时可见。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_4&#34;&gt;原子指令和Software Locks&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;原子指令，如x86上的&amp;rdquo;lock &amp;hellip;&amp;rdquo; 指令是一个Full Barrier，执行时会锁住内存子系统来确保执行顺序，甚至跨多个CPU。Software Locks通常使用了内存屏障或原子指令来实现变量可见性和保持程序顺序。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_5&#34;&gt;内存屏障的性能影响&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;内存屏障阻碍了CPU采用优化技术来降低内存操作延迟，必须考虑因此带来的性能损失。为了达到最佳性能，最好是把要解决的问题模块化，这样处理器可以按单元执行任务，然后在任务单元的边界放上所有需要的内存屏障。采用这个方法可以让处理器不受限的执行一个任务单元。合理的内存屏障组合还有一个好处是：缓冲区在第一次被刷后开销会减少，因为再填充改缓冲区不需要额外工作了。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Arduino初试</title>
      <link>http://hugozhu.myalert.info/2013/03/28/23-arduino-1st-day.html</link>
      <pubDate>2013-03-28 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;今天拿到一块Arduino UNO R3板，迫不及待就开始试用了。相比Raspberry Pi是一个全能的电脑，Arduino则是个硬件开源的单片机，因为开源，资料和配件网上就很很多了，也就容易让初学者上手了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Arduino特点:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;开源，硬件标准化，配套传感器等模块很多；&lt;/li&gt;&#xA;&lt;li&gt;结构简单&lt;/li&gt;&#xA;&lt;li&gt;实时系统，稳定，启动只要0.5秒&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;arduino-ide&#34; href=&#34;#arduino-ide&#34;&gt;&lt;/a&gt;Arduino IDE&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://arduino.cc/en/Main/Software&#34;&gt;下载Arduino IDE&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;上电测试&#34; href=&#34;#上电测试&#34;&gt;&lt;/a&gt;上电测试&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;用USB线接在电脑USB口，然后在GND和PIN 13上插一个二极管，注意二极管正极插在PIN 13上, 如下图：&#xA;&lt;img src=&#34;http://ww1.sinaimg.cn/bmiddle/6bc40342jw1e35tmsg0tjj.jpg&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(注：还应该串联一个300欧姆的限流电阻才保险！)&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;上传代码&#34; href=&#34;#上传代码&#34;&gt;&lt;/a&gt;上传代码&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;在Arduino IDE编辑好下面的代码，然后点Upload后就会运行了，会看到LED一闪一闪。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/*&#xA;  Blink&#xA;  Turns on an LED on for one second, then off for one second, repeatedly.&#xA; &#xA;  This example code is in the public domain.&#xA; */&#xA; &#xA;// Pin 13 has an LED connected on most Arduino boards.&#xA;// give it a name:&#xA;int led = 13;&#xA;&#xA;// the setup routine runs once when you press reset:&#xA;void setup() {                &#xA;  // initialize the digital pin as an output.&#xA;  pinMode(led, OUTPUT);     &#xA;}&#xA;&#xA;// the loop routine runs over and over again forever:&#xA;void loop() {&#xA;  digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)&#xA;  delay(1000);               // wait for a second&#xA;  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW&#xA;  delay(1000);               // wait for a second&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;参考链接&#34; href=&#34;#参考链接&#34;&gt;&lt;/a&gt;参考链接&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://arduino.cc/en/Tutorial/Blink&#34;&gt;http://arduino.cc/en/Tutorial/Blink&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>个人网站实时在线人数接口</title>
      <link>http://hugozhu.myalert.info/2013/03/27/21-realtime-online-user-counter.html</link>
      <pubDate>2013-03-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;感觉把个人网站正在访问的在线人数显示在Nokia 5110液晶屏挺好玩，就稍微研究了一下如何提取实时在线人数。&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;实现方法&#34; href=&#34;#实现方法&#34;&gt;&lt;/a&gt;实现方法&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;google-analytics&#34; href=&#34;#google-analytics&#34;&gt;&lt;/a&gt;Google Analytics&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Google Analytics具有很强大的实时流量分析功能，不过网站主必须登陆到后台才能看，但并没有提供Open API，所以就不能用这个服务了。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;日志分析&#34; href=&#34;#日志分析&#34;&gt;&lt;/a&gt;日志分析&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;不修改网站通过web服务器的日志分析，用一个脚本统计15分钟内日志的Unique IP可以粗略的获得一个在线人数。&#xA;但多个用户可能通过一个IP过来，这种做法肯定不精确。一般我们可以通过在页面上部署Javascript脚本，由Javascript为每一个浏览器产生一个独特的持久化Cookie，用这个Cookie代替IP来统计。但用Raspberry Pi来做这件事情会拖慢网站，于是一种方案是采用免费的Google App Engine来实现，打算有空来实现一个。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;cnzz&#34; href=&#34;#cnzz&#34;&gt;&lt;/a&gt;CNZZ&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;CNZZ也提供了15分钟内的在线人数统计功能。分析CNZZ的计数器代码后发现如下方法可以提取到在线人数:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;curl -s &amp;quot;http://online.cnzz.com/online/online.php?id=[your_cnzz_id]&amp;amp;h=[your_cnzz_server_id].cnzz.com&amp;amp;on=1&amp;amp;s=line&amp;quot; | sed -e &#39;s/.*当前在线\[\([0-9]\).*/\1/g&#39;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;于是先通过上面的脚本提取在线人数并上传到&lt;a href=&#34;https://cosm.com/feeds/92372&#34;&gt;Cosm&lt;/a&gt;，Cosm有个触发器功能可以当在线人数超过某个值后发Twitter或HTTP Post到指定URL，并通过程序显示在液晶屏上。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>升级版电子钟 - 如何使用Raspberry Pi驱动Nokia 5110液晶屏</title>
      <link>http://hugozhu.myalert.info/2013/03/24/20-raspberry-pi-drive-nokia-5110.html</link>
      <pubDate>2013-03-24 12:00:00 +0800</pubDate>
      <description>&#xA;&#xA;&lt;p&gt;&lt;h1&gt;目录：&lt;/h1&gt;&lt;nav&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_0&#34;&gt;硬件准备&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_1&#34;&gt;电路&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_2&#34;&gt;代码&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_3&#34;&gt;显示字符&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_4&#34;&gt;显示图形-树莓派Logo&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_5&#34;&gt;安装效果&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_6&#34;&gt;参考链接&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/nav&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Nokia 5110屏比前面介绍过的&lt;a href=&#34;http://hugozhu.myalert.info/2013/03/23/19-raspberry-pi-drive-1602-lcd.html&#34;&gt;1602液晶屏&lt;/a&gt;功能好很多，淘宝上买价格相差不大（二手5110 12块左右, 全新1602 8块左右），Nokia 5110最少只需要占用4个GPIO引脚：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;带蓝色背光&lt;/li&gt;&#xA;&lt;li&gt;使用Philips PCD8544 LCD控制器（通过SPI接口）&lt;/li&gt;&#xA;&lt;li&gt;84x48点阵，可显示100多个字符&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_0&#34;&gt;硬件准备&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://detail.tmall.com/item.htm?spm=a220m.1000858.1000725.6.nGxekg&amp;amp;id=17337394004&amp;amp;is_b=1&amp;amp;cat_id=2&amp;amp;q=%CA%F7%DD%AE%C5%C9&amp;amp;rn=4004716f9ba818c1d69b5eb7818891b5&#34;&gt;树莓派&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://item.taobao.com/item.htm?id=3125173573&amp;amp;ali_trackid=2:mm_12926928_3484851_11423954:1364118594_4k1_653822857&amp;amp;clk1=0b755dfca67112cd1b605914b40146e7&amp;amp;spm=a230z.1.5634029.2.foR1Yu&#34;&gt;Nokia 5110 拆机屏&lt;/a&gt; 或 &lt;a href=&#34;http://item.taobao.com/item.htm?spm=a230r.1.10.154.SdjftL&amp;amp;id=13361097288&amp;amp;_u=oqa31997&#34;&gt;焊好的？&lt;/a&gt; 注意不要买裸屏，需要带电路板的&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://list.tmall.com/search_product.htm?q=%B6%C5%B0%EE%CF%DF&amp;amp;user_action=initiative&amp;amp;at_topsearch=1&amp;amp;sort=st&amp;amp;type=p&amp;amp;cat=&amp;amp;style=&#34;&gt;杜邦线&lt;/a&gt; 母对母8条&lt;/li&gt;&#xA;&lt;li&gt;8P排针 用来焊接5110屏幕PCB板&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://detail.tmall.com/item.htm?id=22096296909&amp;amp;ali_trackid=2:mm_12926928_3484851_11423954:1364118800_4k4_1229281314&amp;amp;clk1=c7335b2dcbad93f47eaf5cd4d1cc140b&amp;amp;spm=a230z.1.5634029.66.6xxdfN&#34;&gt;电烙铁&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_1&#34;&gt;电路&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;5110电路板有8个引脚，使用排针（如下图）将其焊上，方便后面用杜邦线连接，如果不会焊也可以买焊接好的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://img01.taobaocdn.com/bao/uploaded/i1/13130028971464406/T1v5oAXd0XXXXXXXXX_!!0-item_pic.jpg_600x600.jpg&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;RST —— 复位 接GPIO 0&lt;/li&gt;&#xA;&lt;li&gt;CE  —— 片选 接GPIO 1 或 不接&lt;/li&gt;&#xA;&lt;li&gt;DC  —— 数据/指令选择 接GPIO 2&lt;/li&gt;&#xA;&lt;li&gt;DIN —— 串行数据线 接GPIO 3&lt;/li&gt;&#xA;&lt;li&gt;CLK —— 串行时钟线 接GPIO 5 （因为我的GPIO 4已经接了一个DHT11传感器）&lt;/li&gt;&#xA;&lt;li&gt;VCC —— 电源输入 接3.3v&lt;/li&gt;&#xA;&lt;li&gt;BL  —— 背光控制端 接3.3v&lt;/li&gt;&#xA;&lt;li&gt;GND —— 地线 接地&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;PS. 编号规范看&lt;a href=&#34;http://hugozhu.myalert.info/2013/03/22/19-raspberry-pi-gpio-port-naming.html&#34;&gt;这里&lt;/a&gt; VCC, BK, GND可以接在面包板电源上&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_2&#34;&gt;代码&lt;/h1&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_3&#34;&gt;显示字符&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;需要安装&lt;a href=&#34;https://pypi.python.org/pypi/RPi.GPIO&#34;&gt;RPi.GPIO&lt;/a&gt;库&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/usr/bin/python&#xA;# -*- coding: utf-8 -*-&#xA;&#xA;import RPi.GPIO as GPIO&#xA;import time&#xA;import sys&#xA;&#xA;#gpio&#39;s :&#xA;SCLK = 18&#xA;DIN = 15&#xA;DC = 13&#xA;RST = 11&#xA;&#xA;font =[&#xA;0x7E, 0x11, 0x11, 0x11, 0x7E, # A&#xA;0x7F, 0x49, 0x49, 0x49, 0x36, # B&#xA;0x3E, 0x41, 0x41, 0x41, 0x22, # C&#xA;0x7F, 0x41, 0x41, 0x22, 0x1C, # D&#xA;0x7F, 0x49, 0x49, 0x49, 0x41, # E&#xA;0x7F, 0x09, 0x09, 0x09, 0x01, # F&#xA;0x3E, 0x41, 0x49, 0x49, 0x7A, # G&#xA;0x7F, 0x08, 0x08, 0x08, 0x7F, # H&#xA;0x00, 0x41, 0x7F, 0x41, 0x00, # I&#xA;0x20, 0x40, 0x41, 0x3F, 0x01, # J&#xA;0x7F, 0x08, 0x14, 0x22, 0x41, # K&#xA;0x7F, 0x40, 0x40, 0x40, 0x40, # L&#xA;0x7F, 0x02, 0x0C, 0x02, 0x7F, # M&#xA;0x7F, 0x04, 0x08, 0x10, 0x7F, # N&#xA;0x3E, 0x41, 0x41, 0x41, 0x3E, # O&#xA;0x7F, 0x09, 0x09, 0x09, 0x06, # P&#xA;0x3E, 0x41, 0x51, 0x21, 0x5E, # Q&#xA;0x7F, 0x09, 0x19, 0x29, 0x46, # R&#xA;0x46, 0x49, 0x49, 0x49, 0x31, # S&#xA;0x01, 0x01, 0x7F, 0x01, 0x01, # T&#xA;0x3F, 0x40, 0x40, 0x40, 0x3F, # U&#xA;0x1F, 0x20, 0x40, 0x20, 0x1F, # V&#xA;0x3F, 0x40, 0x38, 0x40, 0x3F, # W&#xA;0x63, 0x14, 0x08, 0x14, 0x63, # X&#xA;0x07, 0x08, 0x70, 0x08, 0x07, # Y&#xA;0x61, 0x51, 0x49, 0x45, 0x43, # Z&#xA;]&#xA;&#xA;def main():&#xA;  begin(0xbc) # contrast - may need tweaking for each display&#xA;  gotoxy(28,0)&#xA;  text(&amp;quot;HELLO&amp;quot;)&#xA;  gotoxy(8,2)&#xA;  text(&amp;quot;RASPBERRY PI&amp;quot;)&#xA;  gotoxy(6,2)&#xA;  text(&amp;quot;Hugo&amp;quot;)&#xA;&#xA;def gotoxy(x,y):&#xA;  lcd_cmd(x+128)&#xA;  lcd_cmd(y+64)&#xA;&#xA;def text(words):&#xA;  for i in range(len(words)):&#xA;#    print (words[i])&#xA;    display_char(words[i])&#xA;&#xA;def display_char(char):&#xA;  index=(ord(char)-65)*5&#xA;  if ord(char) &amp;gt;=65 and ord(char) &amp;lt;=90:&#xA;    for i in range(5):&#xA;#      print (index+i)&#xA;      lcd_data(font[index+i])&#xA;    lcd_data(0) # space inbetween characters&#xA;  elif ord(char)==32:&#xA;      lcd_data(0)&#xA;      lcd_data(0)&#xA;      lcd_data(0)&#xA;      lcd_data(0)&#xA;      lcd_data(0)&#xA;      lcd_data(0)&#xA;&#xA;def cls():&#xA;  gotoxy(0,0)&#xA;  for i in range(84):&#xA;    for j in range(6):&#xA;      lcd_data(0)&#xA;&#xA;def setup():&#xA;  # set pin directions&#xA;  GPIO.setmode(GPIO.BOARD)&#xA;  GPIO.setup(DIN, GPIO.OUT)&#xA;  GPIO.setup(SCLK, GPIO.OUT)&#xA;  GPIO.setup(DC, GPIO.OUT)&#xA;  GPIO.setup(RST, GPIO.OUT)&#xA;&#xA;def begin(contrast):&#xA;  setup()&#xA;  # toggle RST low to reset&#xA;  GPIO.output(RST, False)&#xA;  time.sleep(0.100)&#xA;  GPIO.output(RST, True)&#xA;  lcd_cmd(0x21) # extended mode&#xA;  lcd_cmd(0x14) # bias&#xA;  lcd_cmd(contrast) # vop&#xA;  lcd_cmd(0x20) # basic mode&#xA;  lcd_cmd(0xc) # non-inverted display&#xA;  cls()&#xA;&#xA;&#xA;def SPI(c):&#xA;  # data = DIN&#xA;  # clock = SCLK&#xA;  # MSB first&#xA;  # value = c&#xA;  for i in xrange(8):&#xA;    GPIO.output(DIN, (c &amp;amp; (1 &amp;lt;&amp;lt; (7-i))) &amp;gt; 0)&#xA;    GPIO.output(SCLK, True)&#xA;    GPIO.output(SCLK, False)&#xA;&#xA;def lcd_cmd(c):&#xA;#  print (&amp;quot;lcd_cmd sent :&amp;quot;,hex(c))&#xA;  GPIO.output(DC, False)&#xA;  SPI(c)&#xA;&#xA;def lcd_data(c):&#xA;#  print (&amp;quot;data sent :&amp;quot;,hex(c))&#xA;  GPIO.output(DC, True)&#xA;  SPI(c)&#xA;&#xA;if __name__ == &amp;quot;__main__&amp;quot;:&#xA;  main()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_4&#34;&gt;显示图形-树莓派Logo&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;需要安装&lt;a href=&#34;https://github.com/WiringPi/WiringPi&#34;&gt;wiringPi&lt;/a&gt;和&lt;a href=&#34;https://github.com/binerry/RaspberryPi/tree/master/libraries/c/PCD8544&#34;&gt;PCD8544&lt;/a&gt;库&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;wiringPi.h&amp;gt;&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;stdlib.h&amp;gt;&#xA;#include &amp;quot;PCD8544.h&amp;quot;&#xA;&#xA;// pin setup&#xA;int _din = 3;&#xA;int _sclk = 5;&#xA;int _dc = 2;&#xA;int _rst = 0;&#xA;int _cs = 1;&#xA;  &#xA;// lcd contrast &#xA;int contrast = 50;&#xA;  &#xA;int main(int argc, char* argv[])&#xA;{&#xA;  // print infos&#xA;  printf(&amp;quot;Raspberry Pi PCD8544 test\n&amp;quot;);&#xA;  printf(&amp;quot;========================================\n&amp;quot;);&#xA;  &#xA;  printf(&amp;quot;CLK on Port %i \n&amp;quot;, _sclk);&#xA;  printf(&amp;quot;DIN on Port %i \n&amp;quot;, _din);&#xA;  printf(&amp;quot;DC on Port %i \n&amp;quot;, _dc);&#xA;  printf(&amp;quot;CS on Port %i \n&amp;quot;, _cs);&#xA;  printf(&amp;quot;RST on Port %i \n&amp;quot;, _rst);  &#xA;  printf(&amp;quot;========================================\n&amp;quot;);&#xA;  &#xA;  // check wiringPi setup&#xA;  if (wiringPiSetup() == -1)&#xA;  {&#xA;    printf(&amp;quot;wiringPi-Error\n&amp;quot;);&#xA;    exit(1);&#xA;  }&#xA;  &#xA;  // init and clear lcd&#xA;  LCDInit(_sclk, _din, _dc, _cs, _rst, contrast);&#xA;  LCDclear();&#xA;&#xA;  // turn all the pixels on (a handy test)&#xA;  printf(&amp;quot;Test: All pixels on.\n&amp;quot;);&#xA;  LCDcommand(PCD8544_DISPLAYCONTROL | PCD8544_DISPLAYALLON);&#xA;  delay(1000);&#xA;  // back to normal&#xA;  printf(&amp;quot;Test: All pixels off.\n&amp;quot;);&#xA;  LCDcommand(PCD8544_DISPLAYCONTROL | PCD8544_DISPLAYNORMAL);&#xA;  LCDclear();&#xA;  &#xA;  // display logo&#xA;  printf(&amp;quot;Test: Display logo.\n&amp;quot;);&#xA;  LCDshowLogo();&#xA;  delay(2000);&#xA;  LCDclear();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_5&#34;&gt;安装效果&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/bmiddle/6bc40342jw1e30zljajskj.jpg&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_6&#34;&gt;参考链接&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://binerry.de/post/25787954149/pcd8544-library-for-raspberry-pi&#34;&gt;http://binerry.de/post/25787954149/pcd8544-library-for-raspberry-pi&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>如何使用Raspberry Pi在1602液晶屏上显示当前时间--电子钟</title>
      <link>http://hugozhu.myalert.info/2013/03/23/19-raspberry-pi-drive-1602-lcd.html</link>
      <pubDate>2013-03-23 12:00:00 +0800</pubDate>
      <description>&#xA;&#xA;&lt;p&gt;&lt;h1&gt;目录：&lt;/h1&gt;&lt;nav&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_0&#34;&gt;硬件准备&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_1&#34;&gt;1602 LCD液晶屏&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_2&#34;&gt;注意事项&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_3&#34;&gt;电路图&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_4&#34;&gt;代码&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_5&#34;&gt;完成后的效果&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_6&#34;&gt;参考链接&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/nav&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_0&#34;&gt;硬件准备&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;需要以下硬件：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://detail.tmall.com/item.htm?spm=a220m.1000858.1000725.6.nGxekg&amp;amp;id=17337394004&amp;amp;is_b=1&amp;amp;cat_id=2&amp;amp;q=%CA%F7%DD%AE%C5%C9&amp;amp;rn=4004716f9ba818c1d69b5eb7818891b5&#34;&gt;树莓派&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://list.tmall.com//search_product.htm?q=%C3%E6%B0%FC%B0%E5&amp;amp;type=p&amp;amp;style=&amp;amp;cat=all&#34;&gt;面包板&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://s.taobao.com/search?spm=a230r.1.8.2.RvXL2p&amp;amp;q=1602+%D2%BA%BE%A7&amp;amp;commend=all&amp;amp;source=haiwaigou&amp;amp;ssid=s5-e&amp;amp;pid=mm_14507416_2297358_8935934&amp;amp;newpre=null&amp;amp;tab=mall&#34;&gt;1602液晶屏&lt;/a&gt;一块&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://s.taobao.com/search?source=suggest&amp;amp;haiwaifrom=1&amp;amp;q=%B5%E7%CE%BB%C6%F7+10k&amp;amp;initiative_id=staobaoz_20130323&amp;amp;suggest_query=%B5%E7%CE%BB%C6%F7+10k&amp;amp;sb_id=10&amp;amp;suggest=0_2&amp;amp;wq=%B5%E7%CE%BB%C6%F7&amp;amp;tab=mall&#34;&gt;10K电位器&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://list.tmall.com/search_product.htm?q=%B6%C5%B0%EE%CF%DF&amp;amp;user_action=initiative&amp;amp;at_topsearch=1&amp;amp;sort=st&amp;amp;type=p&amp;amp;cat=&amp;amp;style=&#34;&gt;杜邦线&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://s.taobao.com/search?source=haiwaigou&amp;amp;haiwaifrom=1&amp;amp;q=%C5%C5%D5%EB&amp;amp;initiative_id=staobaoz_20130323&amp;amp;tab=mall&#34;&gt;排针&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://list.tmall.com//search_product.htm?q=%C3%E6%B0%FC%B0%E5+%B5%E7%D4%B4&amp;amp;type=p&amp;amp;style=&amp;amp;cat=all&#34;&gt;面包板电源&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_1&#34;&gt;1602 LCD液晶屏&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;LCD1602液晶屏提供了16列x2行的ASCII字符显示能力，工作电压5V，提供4位数据与8位数据两种工作模式，因为Raspberry Pi的GPIO口数量很有限，所以使用4位数据模式。LCD1602液晶屏模块提供了16个引脚，我们只需接其中的12个即可&amp;ndash;请参考&lt;a href=&#34;http://hugozhu.myalert.info/2013/03/22/19-raspberry-pi-gpio-port-naming.html&#34;&gt;GPIO命名规则&lt;/a&gt;：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;VSS，接地，RPi PIN 6&lt;/li&gt;&#xA;&lt;li&gt;VDD，接5V电源，PRi PIN 2&lt;/li&gt;&#xA;&lt;li&gt;VO，液晶对比度调节，接电位器中间的引脚&lt;/li&gt;&#xA;&lt;li&gt;RS，寄存器选择，接GPIO 14，RPi PIN 8&lt;/li&gt;&#xA;&lt;li&gt;RW，读写选择，接地，表示写模式，PRi PIN 6&lt;/li&gt;&#xA;&lt;li&gt;EN，使能信号，接GPIO 15，RPi PIN 10&lt;/li&gt;&#xA;&lt;li&gt;D0，数据位0，4位工作模式下不用，不接&lt;/li&gt;&#xA;&lt;li&gt;D1，数据位1，4位工作模式下不用，不接&lt;/li&gt;&#xA;&lt;li&gt;D2，数据位2，4位工作模式下不用，不接&lt;/li&gt;&#xA;&lt;li&gt;D3，数据位3，4位工作模式下不用，不接&lt;/li&gt;&#xA;&lt;li&gt;D4，数据位4，接GPIO 17，RPi PIN 11&lt;/li&gt;&#xA;&lt;li&gt;D5，数据位5，接GPIO 18，RPi PIN 12&lt;/li&gt;&#xA;&lt;li&gt;D6，数据位6，接GPIO 27，RPi PIN 13&lt;/li&gt;&#xA;&lt;li&gt;D7，数据位7，接GPIO 22，RPi PIN 15&lt;/li&gt;&#xA;&lt;li&gt;A，液晶屏背光+，接5V，RPi PIN 2&lt;/li&gt;&#xA;&lt;li&gt;K，液晶屏背光-，接地，RPi PIN 6&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_2&#34;&gt;注意事项&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;电源VDD最后接上&lt;/li&gt;&#xA;&lt;li&gt;排针焊接在液晶屏时注意不要虚焊，也可以用万用表测量一下&lt;/li&gt;&#xA;&lt;li&gt;RW脚注意一定要接地&lt;/li&gt;&#xA;&lt;li&gt;调节电位器可以调节液晶对比度&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_3&#34;&gt;电路图&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://learn.adafruit.com/system/assets/assets/000/001/729/medium640/pi-char-lcd.gif?1345220594&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_4&#34;&gt;代码&lt;/h1&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/usr/bin/python&#xA;&#xA;#&#xA;# based on code from lrvick and LiquidCrystal&#xA;# lrvic - https://github.com/lrvick/raspi-hd44780/blob/master/hd44780.py&#xA;# LiquidCrystal - https://github.com/arduino/Arduino/blob/master/libraries/LiquidCrystal/LiquidCrystal.cpp&#xA;#&#xA;&#xA;from time import sleep&#xA;from datetime import datetime&#xA;from time import sleep&#xA;&#xA;class Adafruit_CharLCD:&#xA;&#xA;    # commands&#xA;    LCD_CLEARDISPLAY        = 0x01&#xA;    LCD_RETURNHOME          = 0x02&#xA;    LCD_ENTRYMODESET        = 0x04&#xA;    LCD_DISPLAYCONTROL      = 0x08&#xA;    LCD_CURSORSHIFT         = 0x10&#xA;    LCD_FUNCTIONSET         = 0x20&#xA;    LCD_SETCGRAMADDR        = 0x40&#xA;    LCD_SETDDRAMADDR        = 0x80&#xA;&#xA;    # flags for display entry mode&#xA;    LCD_ENTRYRIGHT      = 0x00&#xA;    LCD_ENTRYLEFT       = 0x02&#xA;    LCD_ENTRYSHIFTINCREMENT     = 0x01&#xA;    LCD_ENTRYSHIFTDECREMENT     = 0x00&#xA;&#xA;    # flags for display on/off control&#xA;    LCD_DISPLAYON       = 0x04&#xA;    LCD_DISPLAYOFF      = 0x00&#xA;    LCD_CURSORON        = 0x02&#xA;    LCD_CURSOROFF       = 0x00&#xA;    LCD_BLINKON         = 0x01&#xA;    LCD_BLINKOFF        = 0x00&#xA;&#xA;    # flags for display/cursor shift&#xA;    LCD_DISPLAYMOVE         = 0x08&#xA;    LCD_CURSORMOVE      = 0x00&#xA;&#xA;    # flags for display/cursor shift&#xA;    LCD_DISPLAYMOVE         = 0x08&#xA;    LCD_CURSORMOVE      = 0x00&#xA;    LCD_MOVERIGHT       = 0x04&#xA;    LCD_MOVELEFT        = 0x00&#xA;&#xA;    # flags for function set&#xA;    LCD_8BITMODE        = 0x10&#xA;    LCD_4BITMODE        = 0x00&#xA;    LCD_2LINE           = 0x08&#xA;    LCD_1LINE           = 0x00&#xA;    LCD_5x10DOTS        = 0x04&#xA;    LCD_5x8DOTS         = 0x00&#xA;&#xA;&#xA;&#xA;    def __init__(self, pin_rs=8, pin_e=10, pins_db=[11,12,13,15], GPIO = None):&#xA;    # Emulate the old behavior of using RPi.GPIO if we haven&#39;t been given&#xA;    # an explicit GPIO interface to use&#xA;    if not GPIO:&#xA;        import RPi.GPIO as GPIO&#xA;        GPIO.setwarnings(False)&#xA;&#xA;    self.GPIO = GPIO&#xA;        self.pin_rs = pin_rs&#xA;        self.pin_e = pin_e&#xA;        self.pins_db = pins_db&#xA;&#xA;        self.GPIO.setmode(GPIO.BOARD)&#xA;        self.GPIO.setup(self.pin_e, GPIO.OUT)&#xA;        self.GPIO.setup(self.pin_rs, GPIO.OUT)&#xA;&#xA;        for pin in self.pins_db:&#xA;            self.GPIO.setup(pin, GPIO.OUT)&#xA;&#xA;    self.write4bits(0x33) # initialization&#xA;    self.write4bits(0x32) # initialization&#xA;    self.write4bits(0x28) # 2 line 5x7 matrix&#xA;    self.write4bits(0x0C) # turn cursor off 0x0E to enable cursor&#xA;    self.write4bits(0x06) # shift cursor right&#xA;&#xA;    self.displaycontrol = self.LCD_DISPLAYON | self.LCD_CURSOROFF | self.LCD_BLINKOFF&#xA;&#xA;    self.displayfunction = self.LCD_4BITMODE | self.LCD_1LINE | self.LCD_5x8DOTS&#xA;    self.displayfunction |= self.LCD_2LINE&#xA;&#xA;    &amp;quot;&amp;quot;&amp;quot; Initialize to default text direction (for romance languages) &amp;quot;&amp;quot;&amp;quot;&#xA;    self.displaymode =  self.LCD_ENTRYLEFT | self.LCD_ENTRYSHIFTDECREMENT&#xA;    self.write4bits(self.LCD_ENTRYMODESET | self.displaymode) #  set the entry mode&#xA;&#xA;        self.clear()&#xA;&#xA;&#xA;    def begin(self, cols, lines):&#xA;&#xA;    if (lines &amp;gt; 1):&#xA;        self.numlines = lines&#xA;            self.displayfunction |= self.LCD_2LINE&#xA;        self.currline = 0&#xA;&#xA;&#xA;    def home(self):&#xA;&#xA;    self.write4bits(self.LCD_RETURNHOME) # set cursor position to zero&#xA;    self.delayMicroseconds(3000) # this command takes a long time!&#xA;    &#xA;&#xA;    def clear(self):&#xA;&#xA;    self.write4bits(self.LCD_CLEARDISPLAY) # command to clear display&#xA;    self.delayMicroseconds(3000)    # 3000 microsecond sleep, clearing the display takes a long time&#xA;&#xA;&#xA;    def setCursor(self, col, row):&#xA;&#xA;    self.row_offsets = [ 0x00, 0x40, 0x14, 0x54 ]&#xA;&#xA;    if ( row &amp;gt; self.numlines ): &#xA;        row = self.numlines - 1 # we count rows starting w/0&#xA;&#xA;    self.write4bits(self.LCD_SETDDRAMADDR | (col + self.row_offsets[row]))&#xA;&#xA;&#xA;    def noDisplay(self): &#xA;    &amp;quot;&amp;quot;&amp;quot; Turn the display off (quickly) &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    self.displaycontrol &amp;amp;= ~self.LCD_DISPLAYON&#xA;    self.write4bits(self.LCD_DISPLAYCONTROL | self.displaycontrol)&#xA;&#xA;&#xA;    def display(self):&#xA;    &amp;quot;&amp;quot;&amp;quot; Turn the display on (quickly) &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    self.displaycontrol |= self.LCD_DISPLAYON&#xA;    self.write4bits(self.LCD_DISPLAYCONTROL | self.displaycontrol)&#xA;&#xA;&#xA;    def noCursor(self):&#xA;    &amp;quot;&amp;quot;&amp;quot; Turns the underline cursor on/off &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    self.displaycontrol &amp;amp;= ~self.LCD_CURSORON&#xA;    self.write4bits(self.LCD_DISPLAYCONTROL | self.displaycontrol)&#xA;&#xA;&#xA;    def cursor(self):&#xA;    &amp;quot;&amp;quot;&amp;quot; Cursor On &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    self.displaycontrol |= self.LCD_CURSORON&#xA;    self.write4bits(self.LCD_DISPLAYCONTROL | self.displaycontrol)&#xA;&#xA;&#xA;    def noBlink(self):&#xA;    &amp;quot;&amp;quot;&amp;quot; Turn on and off the blinking cursor &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    self.displaycontrol &amp;amp;= ~self.LCD_BLINKON&#xA;    self.write4bits(self.LCD_DISPLAYCONTROL | self.displaycontrol)&#xA;&#xA;&#xA;    def noBlink(self):&#xA;    &amp;quot;&amp;quot;&amp;quot; Turn on and off the blinking cursor &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    self.displaycontrol &amp;amp;= ~self.LCD_BLINKON&#xA;    self.write4bits(self.LCD_DISPLAYCONTROL | self.displaycontrol)&#xA;&#xA;&#xA;    def DisplayLeft(self):&#xA;    &amp;quot;&amp;quot;&amp;quot; These commands scroll the display without changing the RAM &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    self.write4bits(self.LCD_CURSORSHIFT | self.LCD_DISPLAYMOVE | self.LCD_MOVELEFT)&#xA;&#xA;&#xA;    def scrollDisplayRight(self):&#xA;    &amp;quot;&amp;quot;&amp;quot; These commands scroll the display without changing the RAM &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    self.write4bits(self.LCD_CURSORSHIFT | self.LCD_DISPLAYMOVE | self.LCD_MOVERIGHT);&#xA;&#xA;&#xA;    def leftToRight(self):&#xA;    &amp;quot;&amp;quot;&amp;quot; This is for text that flows Left to Right &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    self.displaymode |= self.LCD_ENTRYLEFT&#xA;    self.write4bits(self.LCD_ENTRYMODESET | self.displaymode);&#xA;&#xA;&#xA;    def rightToLeft(self):&#xA;    &amp;quot;&amp;quot;&amp;quot; This is for text that flows Right to Left &amp;quot;&amp;quot;&amp;quot;&#xA;    self.displaymode &amp;amp;= ~self.LCD_ENTRYLEFT&#xA;    self.write4bits(self.LCD_ENTRYMODESET | self.displaymode)&#xA;&#xA;&#xA;    def autoscroll(self):&#xA;    &amp;quot;&amp;quot;&amp;quot; This will &#39;right justify&#39; text from the cursor &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    self.displaymode |= self.LCD_ENTRYSHIFTINCREMENT&#xA;    self.write4bits(self.LCD_ENTRYMODESET | self.displaymode)&#xA;&#xA;&#xA;    def noAutoscroll(self): &#xA;    &amp;quot;&amp;quot;&amp;quot; This will &#39;left justify&#39; text from the cursor &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    self.displaymode &amp;amp;= ~self.LCD_ENTRYSHIFTINCREMENT&#xA;    self.write4bits(self.LCD_ENTRYMODESET | self.displaymode)&#xA;&#xA;&#xA;    def write4bits(self, bits, char_mode=False):&#xA;        &amp;quot;&amp;quot;&amp;quot; Send command to LCD &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    self.delayMicroseconds(1000) # 1000 microsecond sleep&#xA;&#xA;        bits=bin(bits)[2:].zfill(8)&#xA;&#xA;        self.GPIO.output(self.pin_rs, char_mode)&#xA;&#xA;        for pin in self.pins_db:&#xA;            self.GPIO.output(pin, False)&#xA;&#xA;        for i in range(4):&#xA;            if bits[i] == &amp;quot;1&amp;quot;:&#xA;                self.GPIO.output(self.pins_db[::-1][i], True)&#xA;&#xA;    self.pulseEnable()&#xA;&#xA;        for pin in self.pins_db:&#xA;            self.GPIO.output(pin, False)&#xA;&#xA;        for i in range(4,8):&#xA;            if bits[i] == &amp;quot;1&amp;quot;:&#xA;                self.GPIO.output(self.pins_db[::-1][i-4], True)&#xA;&#xA;    self.pulseEnable()&#xA;&#xA;&#xA;    def delayMicroseconds(self, microseconds):&#xA;    seconds = microseconds / float(1000000) # divide microseconds by 1 million for seconds&#xA;    sleep(seconds)&#xA;&#xA;&#xA;    def pulseEnable(self):&#xA;    self.GPIO.output(self.pin_e, False)&#xA;    self.delayMicroseconds(1)       # 1 microsecond pause - enable pulse must be &amp;gt; 450ns &#xA;    self.GPIO.output(self.pin_e, True)&#xA;    self.delayMicroseconds(1)       # 1 microsecond pause - enable pulse must be &amp;gt; 450ns &#xA;    self.GPIO.output(self.pin_e, False)&#xA;    self.delayMicroseconds(1)       # commands need &amp;gt; 37us to settle&#xA;&#xA;&#xA;    def message(self, text):&#xA;        &amp;quot;&amp;quot;&amp;quot; Send string to LCD. Newline wraps to second line&amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;        for char in text:&#xA;            if char == &#39;\n&#39;:&#xA;                self.write4bits(0xC0) # next line&#xA;            else:&#xA;                self.write4bits(ord(char),True)&#xA;&#xA;&#xA;if __name__ == &#39;__main__&#39;:&#xA;&#xA;    lcd = Adafruit_CharLCD()&#xA;    lcd.noBlink()&#xA;&#xA;    while True:&#xA;        sleep(1)&#xA;        lcd.clear()        &#xA;        lcd.message(datetime.now().strftime(&#39;  %I : %M : %S \n%a %b %d %Y&#39;))&#xA;        &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_5&#34;&gt;完成后的效果&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://ww3.sinaimg.cn/mw690/6bc40342jw1e2xngyc634j.jpg&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_6&#34;&gt;参考链接&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://learn.adafruit.com/drive-a-16x2-lcd-directly-with-a-raspberry-pi/wiring&#34;&gt;http://learn.adafruit.com/drive-a-16x2-lcd-directly-with-a-raspberry-pi/wiring&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.freemindworld.com/blog/tag/树莓派&#34;&gt;http://www.freemindworld.com/blog/tag/树莓派&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>Raspberry Pi GPIO的编号规范</title>
      <link>http://hugozhu.myalert.info/2013/03/22/19-raspberry-pi-gpio-port-naming.html</link>
      <pubDate>2013-03-22 12:00:00 +0800</pubDate>
      <description>&#xA;&#xA;&lt;p&gt;&lt;h1&gt;目录：&lt;/h1&gt;&lt;nav&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_0&#34;&gt;GPIO库&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_1&#34;&gt;编号规范&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_2&#34;&gt;GPIO转接板&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_3&#34;&gt;物理左排针脚说明&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_4&#34;&gt;物理左排针脚说明&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_5&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/nav&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;树莓派和普通电脑不一样的地方在于它还带了17个可编程的&lt;a href=&#34;http://en.wikipedia.org/wiki/General_Purpose_Input/Output&#34;&gt;GPIO&lt;/a&gt;（General Purpose Input/Output），可以用来驱动各种外设（如传感器，步进电机等）。但GPIO的编号方法有些混乱，不同的API（如wiringPi，RPi.GPIO等）对GPIO的端口号编号并不一样，下面则用图表标明了对应的叫法，这样在看程序例子的时候可以确定物理是哪个接口。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_0&#34;&gt;GPIO库&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/WiringPi/WiringPi&#34;&gt;wiringPi&lt;/a&gt; C，有Perl, PHP, Ruby, Node.JS和&lt;strong&gt;&lt;a href=&#34;http://github.com/hugozhu/rpi&#34;&gt;Golang&lt;/a&gt;&lt;/strong&gt;的扩展，支持wiringPi Pin和BCM GPIO两种编号&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://pypi.python.org/pypi/RPi.GPIO&#34;&gt;RPi.GPIO&lt;/a&gt; Python，支持Board Pin和BCM GPIO两种编号&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://code.google.com/p/webiopi/&#34;&gt;Webiopi&lt;/a&gt;，Python, 使用BCM GPIO编号&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://github.com/hugozhu/rpi&#34;&gt;WiringPi-Go&lt;/a&gt;, Go语言，支持以上三种编号&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_1&#34;&gt;编号规范&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;第一列是wiringPi API中的缺省编号，&lt;code&gt;wiringPiSetup()&lt;/code&gt;采用这列编号&lt;/li&gt;&#xA;&lt;li&gt;第二列（Name）往往是转接板的编号&lt;/li&gt;&#xA;&lt;li&gt;第三列是树莓派板子上的自然编号（左边引脚为1-15，右边引脚为2-26），&lt;code&gt;RPi.GPIO.setmode(GPIO.BOARD)&lt;/code&gt;采用这列编号&lt;/li&gt;&#xA;&lt;li&gt;树莓派主芯片提供商Broadcom的编号方法，相当于调用了&lt;code&gt;WiringPiSetupGpio()&lt;/code&gt;或&lt;code&gt;RPi.GPIO.setmode(GPIO.BCM)&lt;/code&gt;采用这列编号&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;wiringPi Pin&lt;/td&gt;&#xA;&lt;td&gt;Name&lt;/td&gt;&#xA;&lt;td&gt;Board Pin&lt;/td&gt;&#xA;&lt;td&gt;BCM GPIO&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;0&lt;/td&gt;&#xA;&lt;td&gt;GPIO 0&lt;/td&gt;&#xA;&lt;td&gt;11&lt;/td&gt;&#xA;&lt;td&gt;17&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;1&lt;/td&gt;&#xA;&lt;td&gt;GPIO 1&lt;/td&gt;&#xA;&lt;td&gt;12&lt;/td&gt;&#xA;&lt;td&gt;18&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;2&lt;/td&gt;&#xA;&lt;td&gt;GPIO 2&lt;/td&gt;&#xA;&lt;td&gt;13&lt;/td&gt;&#xA;&lt;td&gt;21&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;3&lt;/td&gt;&#xA;&lt;td&gt;GPIO 3&lt;/td&gt;&#xA;&lt;td&gt;15&lt;/td&gt;&#xA;&lt;td&gt;22&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;4&lt;/td&gt;&#xA;&lt;td&gt;GPIO 4&lt;/td&gt;&#xA;&lt;td&gt;16&lt;/td&gt;&#xA;&lt;td&gt;23&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;5&lt;/td&gt;&#xA;&lt;td&gt;GPIO 5&lt;/td&gt;&#xA;&lt;td&gt;18&lt;/td&gt;&#xA;&lt;td&gt;24&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;6&lt;/td&gt;&#xA;&lt;td&gt;GPIO 6&lt;/td&gt;&#xA;&lt;td&gt;22&lt;/td&gt;&#xA;&lt;td&gt;25&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;7&lt;/td&gt;&#xA;&lt;td&gt;GPIO 7&lt;/td&gt;&#xA;&lt;td&gt;7&lt;/td&gt;&#xA;&lt;td&gt;4&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;8&lt;/td&gt;&#xA;&lt;td&gt;SDA&lt;/td&gt;&#xA;&lt;td&gt;3&lt;/td&gt;&#xA;&lt;td&gt;0&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;9&lt;/td&gt;&#xA;&lt;td&gt;SCL&lt;/td&gt;&#xA;&lt;td&gt;5&lt;/td&gt;&#xA;&lt;td&gt;1&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;10&lt;/td&gt;&#xA;&lt;td&gt;CE0&lt;/td&gt;&#xA;&lt;td&gt;24&lt;/td&gt;&#xA;&lt;td&gt;8&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;11&lt;/td&gt;&#xA;&lt;td&gt;CE1&lt;/td&gt;&#xA;&lt;td&gt;26&lt;/td&gt;&#xA;&lt;td&gt;7&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;12&lt;/td&gt;&#xA;&lt;td&gt;MOSI&lt;/td&gt;&#xA;&lt;td&gt;19&lt;/td&gt;&#xA;&lt;td&gt;10&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;13&lt;/td&gt;&#xA;&lt;td&gt;MISO&lt;/td&gt;&#xA;&lt;td&gt;21&lt;/td&gt;&#xA;&lt;td&gt;9&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;14&lt;/td&gt;&#xA;&lt;td&gt;SCLK&lt;/td&gt;&#xA;&lt;td&gt;23&lt;/td&gt;&#xA;&lt;td&gt;11&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;15&lt;/td&gt;&#xA;&lt;td&gt;TXD&lt;/td&gt;&#xA;&lt;td&gt;8&lt;/td&gt;&#xA;&lt;td&gt;14&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;16&lt;/td&gt;&#xA;&lt;td&gt;RXD&lt;/td&gt;&#xA;&lt;td&gt;10&lt;/td&gt;&#xA;&lt;td&gt;15&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;Rev.2 新增的引脚：&lt;/p&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;wiringPi Pin&lt;/td&gt;&#xA;&lt;td&gt;Name&lt;/td&gt;&#xA;&lt;td&gt;Board Pin&lt;/td&gt;&#xA;&lt;td&gt;BCM GPIO&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;17&lt;/td&gt;&#xA;&lt;td&gt;GPIO 8&lt;/td&gt;&#xA;&lt;td&gt;&lt;/td&gt;&#xA;&lt;td&gt;28&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;18&lt;/td&gt;&#xA;&lt;td&gt;GPIO 9&lt;/td&gt;&#xA;&lt;td&gt;&lt;/td&gt;&#xA;&lt;td&gt;29&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;19&lt;/td&gt;&#xA;&lt;td&gt;GPIO10&lt;/td&gt;&#xA;&lt;td&gt;&lt;/td&gt;&#xA;&lt;td&gt;30&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;20&lt;/td&gt;&#xA;&lt;td&gt;GPIO11&lt;/td&gt;&#xA;&lt;td&gt;&lt;/td&gt;&#xA;&lt;td&gt;31&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://pbs.twimg.com/media/BGBhJ4LCAAA50eS.jpg:large&#34;  width=&#34;600&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_2&#34;&gt;GPIO转接板&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;GPIO转接板通过彩虹排线可将树莓派的GPIO引脚转接到面包板上，方便试验，下图是一个相应的产品，可以看到每个引脚标都已标注好了名称，查上表就知道代码里该用哪个编号做参数了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://img03.taobaocdn.com/imgextra/i3/21288305/T23BjrXfJaXXXXXXXX_!!21288305.jpg&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_3&#34;&gt;物理左排针脚说明&lt;/h2&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;Pin&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;Raspberry Pi&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;Broadcom names&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;1&lt;/td&gt;&#xA;&lt;td&gt;3.3V&lt;/td&gt;&#xA;&lt;td&gt;3.3V&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;3&lt;/td&gt;&#xA;&lt;td&gt;SDA0&lt;/td&gt;&#xA;&lt;td&gt;I2C0 SDA&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;5&lt;/td&gt;&#xA;&lt;td&gt;SCL0&lt;/td&gt;&#xA;&lt;td&gt;I2C0 SCL&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;7&lt;/td&gt;&#xA;&lt;td&gt;GPIO 7&lt;/td&gt;&#xA;&lt;td&gt;GPIO 4&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;9&lt;/td&gt;&#xA;&lt;td&gt;DNC&lt;/td&gt;&#xA;&lt;td&gt;DNC&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;11&lt;/td&gt;&#xA;&lt;td&gt;GPIO 0&lt;/td&gt;&#xA;&lt;td&gt;GPIO 17&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;13&lt;/td&gt;&#xA;&lt;td&gt;GPIO 2&lt;/td&gt;&#xA;&lt;td&gt;GPIO 21 (rev2) / GPIO 27 (rev1)&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;15&lt;/td&gt;&#xA;&lt;td&gt;GPIO 3&lt;/td&gt;&#xA;&lt;td&gt;GPIO 22&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;17&lt;/td&gt;&#xA;&lt;td&gt;DNC&lt;/td&gt;&#xA;&lt;td&gt;DNC&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;19&lt;/td&gt;&#xA;&lt;td&gt;SPI MOSI&lt;/td&gt;&#xA;&lt;td&gt;SPI MOSI&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;21&lt;/td&gt;&#xA;&lt;td&gt;SPI MOSO&lt;/td&gt;&#xA;&lt;td&gt;SPI MOSO&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;23&lt;/td&gt;&#xA;&lt;td&gt;SPI SCLK&lt;/td&gt;&#xA;&lt;td&gt;SPI SCLK&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;25&lt;/td&gt;&#xA;&lt;td&gt;DNC&lt;/td&gt;&#xA;&lt;td&gt;DNC&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_4&#34;&gt;物理左排针脚说明&lt;/h2&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;Pin&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;Raspberry Pi&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;Broadcom names&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;2&lt;/td&gt;&#xA;&lt;td&gt;5V&lt;/td&gt;&#xA;&lt;td&gt;5V&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;4&lt;/td&gt;&#xA;&lt;td&gt;DNC&lt;/td&gt;&#xA;&lt;td&gt;DNC&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;6&lt;/td&gt;&#xA;&lt;td&gt;GND&lt;/td&gt;&#xA;&lt;td&gt;GND&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;8&lt;/td&gt;&#xA;&lt;td&gt;TX&lt;/td&gt;&#xA;&lt;td&gt;UART TxD&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;10&lt;/td&gt;&#xA;&lt;td&gt;RX&lt;/td&gt;&#xA;&lt;td&gt;UART RxD&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;12&lt;/td&gt;&#xA;&lt;td&gt;GPIO 1&lt;/td&gt;&#xA;&lt;td&gt;GPIO 18&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;14&lt;/td&gt;&#xA;&lt;td&gt;DNC&lt;/td&gt;&#xA;&lt;td&gt;DNC&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;16&lt;/td&gt;&#xA;&lt;td&gt;GPIO 4&lt;/td&gt;&#xA;&lt;td&gt;GPIO 23&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;18&lt;/td&gt;&#xA;&lt;td&gt;GPIO 5&lt;/td&gt;&#xA;&lt;td&gt;GPIO 24&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;20&lt;/td&gt;&#xA;&lt;td&gt;DNC&lt;/td&gt;&#xA;&lt;td&gt;DNC&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;22&lt;/td&gt;&#xA;&lt;td&gt;GPIO 6&lt;/td&gt;&#xA;&lt;td&gt;GPIO 25&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;24&lt;/td&gt;&#xA;&lt;td&gt;SP10 CEO N&lt;/td&gt;&#xA;&lt;td&gt;SP10 CEO N&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;26&lt;/td&gt;&#xA;&lt;td&gt;SP10 CE1 N&lt;/td&gt;&#xA;&lt;td&gt;SP10 CE1 N&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;Notes:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;all the UART, SPI and I2C pins can be reconfigured as GPIO if needed.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_5&#34;&gt;参考&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://elinux.org/RPi_Low-level_peripherals&#34;&gt;http://elinux.org/RPi_Low-level_peripherals&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://projects.drogon.net/raspberry-pi/wiringpi/pins/&#34;&gt;https://projects.drogon.net/raspberry-pi/wiringpi/pins/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>如何使用Raspberry Pi测量室内温度和湿度并绘制曲线</title>
      <link>http://hugozhu.myalert.info/2013/03/17/03-17-interfacing-temperature-and-humidity-sensor-with-raspberry-pi.html</link>
      <pubDate>2013-03-17 12:00:00 +0800</pubDate>
      <description>&#xA;&#xA;&lt;p&gt;&lt;h1&gt;目录：&lt;/h1&gt;&lt;nav&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_0&#34;&gt;硬件准备&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_1&#34;&gt;传感器电路及原理&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_2&#34;&gt;DHT11传感器外观&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_3&#34;&gt;参数&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_4&#34;&gt;电路图&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_5&#34;&gt;安装好的样子：&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_6&#34;&gt;读取温度和湿度的代码&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_7&#34;&gt;记录曲线图&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_8&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/nav&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_0&#34;&gt;硬件准备&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;需要以下硬件：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;可以工作的&lt;a href=&#34;http://s.click.taobao.com/t?e=zGU34CA7K%2BPkqB07S4%2FK0CITy7klxxrJ35Nnc0iO6niAHo44Chb01aWIu4ho12MwdcCLV6ff8kJMg0iz0FTGXaJAqMvt94sTe0NIrCAdd8LW&#34;&gt;树莓派&lt;/a&gt;一个&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://list.tmall.com/search_product.htm?q=%C3%E6%B0%FC%B0%E5&amp;amp;type=p&amp;amp;style=&amp;amp;cat=all&amp;amp;ali_trackid=2:mm_12926928_3484851_11423971:1364041941_4k1_1171281511&amp;amp;upsid=8daf4a561f161cd669d949c6bf367733&amp;amp;clk1=8daf4a561f161cd669d949c6bf367733&#34;&gt;面包板&lt;/a&gt;和&lt;a href=&#34;http://list.tmall.com//search_product.htm?q=%B6%C5%B0%EE%CF%DF&amp;amp;type=p&amp;amp;style=&amp;amp;cat=all&#34;&gt;公对母杜邦线&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://list.tmall.com/search_product.htm?q=10K+%B5%E7%CE%BB%C6%F7&amp;amp;user_action=initiative&amp;amp;at_topsearch=1&amp;amp;sort=st&amp;amp;type=p&amp;amp;cat=&amp;amp;style=&#34;&gt;10K 电位器&lt;/a&gt;一个&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://list.tmall.com//search_product.htm?q=DHT11&amp;amp;type=p&amp;amp;style=&amp;amp;cat=all&#34;&gt;DHT11&lt;/a&gt;温度和湿度传感器一个或&lt;a href=&#34;http://s.taobao.com/search?q=DHT22&amp;amp;keyword=&amp;amp;commend=all&amp;amp;ssid=s5-e&amp;amp;search_type=item&amp;amp;atype=&amp;amp;tracelog=&amp;amp;sourceId=tb.index&amp;amp;rt=1364041904459&amp;amp;source=haiwaigou&amp;amp;pid=mm_14507416_2297358_8935934&amp;amp;unid=&#34;&gt;DHT22&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_1&#34;&gt;传感器电路及原理&lt;/h1&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_2&#34;&gt;DHT11传感器外观&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://learn.adafruit.com/system/products/images/000/000/386/medium225/dht11_MED.jpg?1342023044&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_3&#34;&gt;参数&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;湿度测量范围：20％～90%RH(0－50℃温度补偿）；&lt;/li&gt;&#xA;&lt;li&gt;温度测量范围：0～+50℃；&lt;/li&gt;&#xA;&lt;li&gt;湿度测量精度：±5.0%RH&lt;/li&gt;&#xA;&lt;li&gt;温度测量精度：±2.0℃&lt;/li&gt;&#xA;&lt;li&gt;响应时间：&amp;lt;5s；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_4&#34;&gt;电路图&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;DHT11一共4根引脚，左边第一根接电源5V (Pin 1)，第二根为数据接口，接 Pin 7，第三根不接，第四根接地；在Pin 1和Pin7 之间还需要并联10K的电阻，以保持读数稳定。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://learn.adafruit.com/system/assets/assets/000/001/860/original/dht11wiring.gif?1345831788&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_5&#34;&gt;安装好的样子：&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://ww3.sinaimg.cn/bmiddle/6bc40342jw1e2rx17tlckj.jpg&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_6&#34;&gt;读取温度和湿度的代码&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;数据读取流图：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://1.bp.blogspot.com/-_sMwYSZMGLw/UJpY2RYIA9I/AAAAAAAAAS0/rJ9ZQwZ3IfM/s640/DHT11+timing+diagram.jpg&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;wiringPi.h&amp;gt;  &#xA;#include &amp;lt;stdio.h&amp;gt;  &#xA;#include &amp;lt;stdlib.h&amp;gt;  &#xA;#include &amp;lt;stdint.h&amp;gt;  &#xA;#define MAX_TIME 85  &#xA;#define DHT11PIN 7  &#xA;&#xA;int dht11_val[5]={0,0,0,0,0};  &#xA;int errors=0;&#xA;&#xA;  &#xA;void dht11_read_val()  &#xA;{  &#xA;  uint8_t lststate=HIGH;  &#xA;  uint8_t counter=0;  &#xA;  uint8_t j=0,i;  &#xA;  float farenheit;  &#xA;  for(i=0;i&amp;lt;5;i++)  &#xA;     dht11_val[i]=0;  &#xA;  pinMode(DHT11PIN,OUTPUT);  &#xA;  digitalWrite(DHT11PIN,LOW);  &#xA;  delay(18);  &#xA;  digitalWrite(DHT11PIN,HIGH);  &#xA;  delayMicroseconds(40);  &#xA;  pinMode(DHT11PIN,INPUT);  &#xA;  for(i=0;i&amp;lt;MAX_TIME;i++)  &#xA;  {  &#xA;    counter=0;  &#xA;    while(digitalRead(DHT11PIN)==lststate){  &#xA;      counter++;  &#xA;      delayMicroseconds(1);  &#xA;      if(counter==255)  &#xA;        break;  &#xA;    }  &#xA;    lststate=digitalRead(DHT11PIN);  &#xA;    if(counter==255)  &#xA;       break;  &#xA;    // top 3 transistions are ignored  &#xA;    if((i&amp;gt;=4)&amp;amp;&amp;amp;(i%2==0)){  &#xA;      dht11_val[j/8]&amp;lt;&amp;lt;=1;  &#xA;      if(counter&amp;gt;16)  &#xA;        dht11_val[j/8]|=1;  &#xA;      j++;  &#xA;    }  &#xA;  }  &#xA;  // verify cheksum and print the verified data  &#xA;  if((j&amp;gt;=40)&amp;amp;&amp;amp;(dht11_val[4]==((dht11_val[0]+dht11_val[1]+dht11_val[2]+dht11_val[3])&amp;amp; 0xFF)))  &#xA;  {  &#xA;    //farenheit=dht11_val[2]*9./5.+32;  &#xA;    printf(&amp;quot;%d.%d\t%d.%d\n&amp;quot;, dht11_val[0],dht11_val[1],dht11_val[2],dht11_val[3]);    &#xA;    exit(1);&#xA;  }  &#xA;  else { &#xA;    errors = errors + 1;&#xA;    if (errors &amp;gt; 5) {&#xA;      printf(&amp;quot;0.0\t0.0&amp;quot;);&#xA;      exit(2);&#xA;    }&#xA;  }&#xA;}  &#xA;  &#xA;int main(void)  &#xA;{  &#xA;  if(wiringPiSetup()==-1)  &#xA;    exit(1);  &#xA;  while(1)  &#xA;  {  &#xA;     dht11_read_val();  &#xA;     delay(3000);  &#xA;  }  &#xA;  return 0;  &#xA;}  &#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;执行&lt;code&gt;gcc sensor.c -o sensor -lwiringPi&lt;/code&gt; ，运行&lt;code&gt;sensor&lt;/code&gt;后输出：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;root@raspberrypi2 /home/hugo/projects/dht11 # ./sensor &#xA;44.0    18.0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_7&#34;&gt;记录曲线图&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;这里我使用&lt;a href=&#34;http://cosm.com/&#34;&gt;cosm.com&lt;/a&gt;的服务，注册申请好账号后，可以建立一个data feed和两个data stream，分别是温度和湿度，相应的Tag ID为1，和2,利用下来的脚本就可以上传数据了&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/bin/bash&#xA;####################################################&#xA;LOCATION=&amp;lt;填你的程序路径&amp;gt; #home/hugo/projects/dht11&#xA;API_KEY=&#39;&amp;lt;填你的api_key&amp;gt;&#39;&#xA;FEED_ID=&#39;&amp;lt;填你的feed_id&amp;gt;&#39;&#xA;####################################################&#xA;COSM_URL=http://api.cosm.com/v2/feeds/$FEED_ID?timezone=+8&#xA;&#xA;VAL=`$LOCATION/sensor`&#xA;t=`echo $VAL|awk &#39;{print $2}&#39;`&#xA;h=`echo $VAL|awk &#39;{print $1}&#39;`&#xA;&#xA;STR=`awk &#39;BEGIN{printf &amp;quot;{\&amp;quot;datastreams\&amp;quot;:[ {\&amp;quot;id\&amp;quot;:\&amp;quot;1\&amp;quot;,\&amp;quot;current_value\&amp;quot;:\&amp;quot;%.1f\&amp;quot;}, {\&amp;quot;id\&amp;quot;:\&amp;quot;2\&amp;quot;,\&amp;quot;current_value\&amp;quot;:\&amp;quot;%.1f\&amp;quot;} ] } &amp;quot;,&#39;$t&#39;, &#39;$h&#39;}&#39;`&#xA;&#xA;echo $STR&#xA;echo $STR &amp;gt; $LOCATION/cosm.json&#xA;curl -v --request PUT --header &amp;quot;X-ApiKey: $API_KEY&amp;quot; --data-binary @$LOCATION/cosm.json $COSM_URL&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后可以使用如下格式的图片引用把曲线图嵌入任何网页：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;https://api.cosm.com/v2/feeds/119331/datastreams/2.png?width=340&amp;amp;height=180&amp;amp;colour=%23f15a24&amp;amp;duration=2days&amp;amp;title=室内湿度&amp;amp;show_axis_labels=false&amp;amp;detailed_grid=true&amp;amp;scale=&amp;amp;timezone=8&amp;quot;/&amp;gt;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;下面是我的曲线图：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://api.cosm.com/v2/feeds/119331/datastreams/2.png?width=340&amp;height=180&amp;colour=%23f15a24&amp;duration=2days&amp;title=室内湿度&amp;show_axis_labels=false&amp;detailed_grid=true&amp;scale=&amp;timezone=8&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://api.cosm.com/v2/feeds/119331/datastreams/1.png?width=340&amp;height=180&amp;colour=%23f15a24&amp;duration=2days&amp;title=室内温度&amp;show_axis_labels=false&amp;detailed_grid=true&amp;scale=&amp;timezone=8&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_8&#34;&gt;参考&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.rpiblog.com/2012/11/interfacing-temperature-and-humidity.html&#34;&gt;http://www.rpiblog.com/2012/11/interfacing-temperature-and-humidity.html&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://learn.adafruit.com/dht-humidity-sensing-on-raspberry-pi-with-gdocs-logging/wiring&#34;&gt;http://learn.adafruit.com/dht-humidity-sensing-on-raspberry-pi-with-gdocs-logging/wiring&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>如何使用Raspberry Pi控制步进电机旋转高清摄像头并拍照</title>
      <link>http://hugozhu.myalert.info/2013/03/16/03-16-use-raspberry-pi-control-step-motor-rotate-webcam.html</link>
      <pubDate>2013-03-16 12:00:00 +0800</pubDate>
      <description>&#xA;&#xA;&lt;p&gt;&lt;h1&gt;目录：&lt;/h1&gt;&lt;nav&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_0&#34;&gt;硬件准备&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_1&#34;&gt;安装&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_2&#34;&gt;步进电机电源&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_3&#34;&gt;步进电机驱动线路&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_4&#34;&gt;安装摄像头&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_5&#34;&gt;驱动示例代码&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_6&#34;&gt;转动效果视频&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_7&#34;&gt;连续转动拍摄代码实现&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_8&#34;&gt;拍摄图片效果&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/nav&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_0&#34;&gt;硬件准备&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;需要以下硬件：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;可以工作的&lt;a href=&#34;http://s.click.taobao.com/t?e=zGU34CA7K%2BPkqB07S4%2FK0CITy7klxxrJ35Nnc0iO6niAHo44Chb01aWIu4ho12MwdcCLV6ff8kJMg0iz0FTGXaJAqMvt94sTe0NIrCAdd8LW&#34;&gt;树莓派&lt;/a&gt;一个&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://s.click.taobao.com/t?e=zGU34CA7K%2BPkqB07S4%2FK0CITy7klxxrJ35Nnc0iO6niAHoWKV0kwS8Wy16Cg6qBM%2BZAOnJCqNG%2BPJAy9U15g8TwJiq5U3GGcJ8eTvC7%2F6APShw%3D%3D&#34;&gt;母对母1P杜邦线&lt;/a&gt;6根&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://s.click.taobao.com/t?e=zGU34CA7K%2BPkqB07S4%2FK0CFcRfH0GoT805sipKjxjSLt%2BsmFEpvY8zQ4WXjoTHsLWTKD4gnL0sndE3qVPXd4UC6NUEZOQAryYUWhO7gt10i%2FUQ%3D%3D&#34;&gt;DC 5V4相28YBJ-48步进电机&lt;/a&gt;一个&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://s.click.taobao.com/t?e=zGU34CA7K%2BPkqB07S4%2FK0CFcRfH0GoT805sipKjxjSLuXQmw2TUIlWTNRCvS2wo483pjZyXspPuvkTH5pg4vQUqrztOAoNz2Gfp8MmwKPg%2FbQb8%3D&#34;&gt;UL2003芯片步进电机驱动板&lt;/a&gt;一块&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_1&#34;&gt;安装&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;按下图将步进电机接到驱动板上，也就是白色的接口&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://img04.taobaocdn.com/bao/uploaded/i4/T10lS4XnXfXXaZhKrX_115008.jpg_310x310.jpg&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://img02.taobaocdn.com/imgextra/i2/49873130/T2534HXoBXXXXXXXXX_!!49873130.jpg&#34; width=&#34;600&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_2&#34;&gt;步进电机电源&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;步进电机需要5V电压驱动，而树莓派的&lt;a href=&#34;http://elinux.org/RPi_Low-level_peripherals&#34;&gt;GPIO接口&lt;/a&gt;中已有5V输出，将图中的Pin 2（最右上角那个）5V，接到驱动板的5V正极，Pin 6接到5V负级，电源部分则搞定。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://trouch.com/wp-content/uploads/2012/08/webiopi-chrome.png&#34; width=&#34;600&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_3&#34;&gt;步进电机驱动线路&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;驱动板上有IN1, IN2, IN3, IN4四个接口，根据资料得知这四个接口依次设置为低电平就可以驱动，我们分别用杜邦线将GPIO 17（Pin 11），GPIO 18（Pin 12）, GPIO 21（Pin 13）, GPIO 22（Pin 15）和IN1，IN2，IN3，IN4一一相连。 &lt;strong&gt;注意不同的GPIO驱动程序对端口的编号不一定一样（至少有三种叫法：Board，Broadcom，GPIO）&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;驱动原理：（每次将四个GPIO端口按下表依次设置好电平后，可以sleep几十毫秒来控制转速）&lt;/p&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;序列&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;GPIO 17&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;GPIO 18&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;GPIO 21&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;GPIO 22&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;0&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;LOW&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;HIGH&lt;/td&gt;&#xA;&lt;td&gt;HIGH&lt;/td&gt;&#xA;&lt;td&gt;HIGH&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;1&lt;/td&gt;&#xA;&lt;td&gt;HIGH&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;LOW&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;HIGH&lt;/td&gt;&#xA;&lt;td&gt;HIGH&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;2&lt;/td&gt;&#xA;&lt;td&gt;HIGH&lt;/td&gt;&#xA;&lt;td&gt;HIGH&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;LOW&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;HIGH&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;3&lt;/td&gt;&#xA;&lt;td&gt;HIGH&lt;/td&gt;&#xA;&lt;td&gt;HIGH&lt;/td&gt;&#xA;&lt;td&gt;HIGH&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;LOW&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;4&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;LOW&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;HIGH&lt;/td&gt;&#xA;&lt;td&gt;HIGH&lt;/td&gt;&#xA;&lt;td&gt;HIGH&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;…&lt;/td&gt;&#xA;&lt;td&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_4&#34;&gt;安装摄像头&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;本来是希望用3D打印机来制作齿轮和支架来完成这部分工作的，但因为打印机还没到货，所以先用乐高积木来做了, 刚好乐高积木可以插在步进电机中轴上，而且很牢靠，还不用密封带了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;摄像头如下图用两根导线固定在乐高积木上：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/bmiddle/6bc40342jw1e2rqxrtrd2j.jpg&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后用各种积木搭个底座把电机固定起来，并留两个洞口可以将驱动线和摄像头的USB线穿出，这样表面上比较整齐，USB线也不会因为牵扯影响转动。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://ww4.sinaimg.cn/bmiddle/6bc40342jw1e2rqt5b23rj.jpg&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://photo.weibo.com/1808008002/wbphotos/large/photo_id/3556528869320348?refer=weibofeedv5&#34;&gt;点击看大图&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_5&#34;&gt;驱动示例代码&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;这里使用的是Python GPIO库，注意这里的端口命名是按树莓派的Board叫法（Pin 11, 12, 13, 15）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;root@raspberrypi2 ~/projects/step_motor # cat motor.py&#xA;import RPi.GPIO as GPIO&#xA;import time&#xA;import sys&#xA;from array import *&#xA;&#xA;GPIO.setwarnings(False) &#xA;GPIO.setmode(GPIO.BOARD)&#xA;&#xA;steps    = int(sys.argv[1]);&#xA;clockwise = int(sys.argv[2]);&#xA;&#xA;arr = [0,1,2,3];&#xA;if clockwise!=1:&#xA;    arr = [3,2,1,0];&#xA;&#xA;ports = [11,12,13,15]&#xA;&#xA;for p in ports:&#xA;    GPIO.setup(p,GPIO.OUT)&#xA;&#xA;for x in range(0,steps):&#xA;    for j in arr:&#xA;        time.sleep(0.01)&#xA;        for i in range(0,4):&#xA;            if i == j:            &#xA;                GPIO.output(ports[i],True)&#xA;            else:&#xA;                GPIO.output(ports[i],False)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;执行&lt;code&gt;python motor.py  90 0&lt;/code&gt; 可以顺时针转动大约80度。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;执行&lt;code&gt;python motor.py  90 1&lt;/code&gt; 则可逆时针转动大约80度。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_6&#34;&gt;转动效果视频&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;embed src=&#34;http://player.youku.com/player.php/sid/XNTI3MzU1MjIw/v.swf&#34; allowFullScreen=&#34;true&#34; quality=&#34;high&#34; width=&#34;480&#34; height=&#34;400&#34; align=&#34;middle&#34; allowScriptAccess=&#34;always&#34; type=&#34;application/x-shockwave-flash&#34;&gt;&lt;/embed&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_7&#34;&gt;连续转动拍摄代码实现&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;这次使用&lt;a href=&#34;http://code.google.com/p/webiopi/&#34;&gt;webiopi&lt;/a&gt;把控制程序转换成REST API，这样方便网页调用。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;root@raspberrypi2 ~/projects/gpio_server # cat webiopi_custom.py&#xA;# Imports&#xA;import webiopi&#xA;import time&#xA;&#xA;# Retrieve GPIO lib&#xA;GPIO = webiopi.GPIO&#xA;&#xA;# -------------------------------------------------- #&#xA;# Macro definition part                              #&#xA;# -------------------------------------------------- #&#xA;&#xA;# A custom macro which prints out the arg received and return OK&#xA;def myMacroWithArgs(arg1, arg2, arg3):&#xA;    print(&amp;quot;myMacroWithArgs(%s, %s, %s)&amp;quot; % (arg1, arg2, arg3))&#xA;    return &amp;quot;OK&amp;quot;&#xA;&#xA;# A custom macro without args which return nothing&#xA;def myMacroWithoutArgs():&#xA;    print(&amp;quot;myMacroWithoutArgs()&amp;quot;)&#xA;&#xA;# Example loop which toggle GPIO 7 each 5 seconds&#xA;def loop():&#xA;    time.sleep(5)        &#xA;&#xA;&#xA;def turnLed(port_str, ms):&#xA;    port = int(port_str)&#xA;    GPIO.setFunction(port,GPIO.OUT)    &#xA;    GPIO.output(port,GPIO.LOW)&#xA;    time.sleep(float(ms)/1000)&#xA;    GPIO.output(port,GPIO.HIGH)&#xA;&#xA;def turnWebcam(steps_str, clockwise_str):&#xA;    steps = int(steps_str);&#xA;    clockwise = int(clockwise_str);&#xA;    arr = [0,1,2,3];&#xA;    if clockwise!=1:&#xA;        arr = [3,2,1,0];&#xA;&#xA;    ports = [17,18,27,22]&#xA;&#xA;    for p in ports:&#xA;        GPIO.setFunction(p,GPIO.OUT)&#xA;&#xA;    for x in range(0,steps):&#xA;        for j in arr:&#xA;            time.sleep(0.01)&#xA;            for i in range(0,4):&#xA;                if i == j:            &#xA;                    GPIO.output(ports[i],GPIO.LOW)&#xA;                else:&#xA;                    GPIO.output(ports[i],GPIO.HIGH)&#xA;&#xA;# -------------------------------------------------- #&#xA;# Initialization part                                #&#xA;# -------------------------------------------------- #&#xA;&#xA;# Setup GPIOs&#xA;&#xA;# -------------------------------------------------- #&#xA;# Main server part                                   #&#xA;# -------------------------------------------------- #&#xA;&#xA;# Instantiate the server on the port 8000, it starts immediately in its own thread&#xA;server = webiopi.Server(port=8001, login=&amp;quot;pi&amp;quot;, password=&amp;quot;pi&amp;quot;)&#xA;# or     webiopi.Server(port=8000, passwdfile=&amp;quot;/etc/webiopi/passwd&amp;quot;)&#xA;&#xA;# Register the macros so you can call it with Javascript and/or REST API&#xA;server.addMacro(turnWebcam)&#xA;server.addMacro(turnLed)&#xA;&#xA;&#xA;# -------------------------------------------------- #&#xA;# Loop execution part                                #&#xA;# -------------------------------------------------- #&#xA;&#xA;# Run our loop until CTRL-C is pressed or SIGTERM received&#xA;webiopi.runLoop()&#xA;&#xA;# If no specific loop is needed and defined above, just use &#xA;# webiopi.runLoop()&#xA;# here instead&#xA;&#xA;# -------------------------------------------------- #&#xA;# Termination part                                   #&#xA;# -------------------------------------------------- #&#xA;&#xA;# Cleanly stop the server&#xA;server.stop()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;执行&lt;code&gt;python webiopi_custom.py&lt;/code&gt; 后启动GPIO REST API服务器&lt;/p&gt;&#xA;&#xA;&lt;p&gt;转动命令是：&lt;code&gt;curl --data &amp;quot;&amp;quot; &amp;quot;http://pi:pi@raspberrypi2:8001/macros/turnWebcam/90,0&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;拍照命令是：&lt;code&gt;/usr/bin/fswebcam -v -r 640x480 --no-banner /var/www/fswebcam/foo.jpg&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;于是我们可以用以下方法来实现连续拍摄：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;执行拍照命令, 生成right.jpg&lt;/li&gt;&#xA;&lt;li&gt;顺时转80度&lt;/li&gt;&#xA;&lt;li&gt;执行拍照命令, 生成middle.jpg&lt;/li&gt;&#xA;&lt;li&gt;顺时转80度&lt;/li&gt;&#xA;&lt;li&gt;执行拍照命令, 生成left.jpg&lt;/li&gt;&#xA;&lt;li&gt;逆时针转160度归位&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;将命令通过网页执行后，就可以在外面看房间里的情况了，今天出去外面采草莓在iPhone上试了一下，结果符合预期。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_8&#34;&gt;拍摄图片效果&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;在手机上看到的页面：点Reload会重新连拍三张&#xA;&lt;img src=&#34;http://ww3.sinaimg.cn/large/6bc40342jw1e2r069hyhsj.jpg&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;总共花了不到2小时就可以搞定这个了，还是非常好玩的~ 后面还可以用OpenCV库来合成照片到真正的全景图&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>如何在Raspberry Pi上用LED闪烁提示网站首页新访客</title>
      <link>http://hugozhu.myalert.info/2013/03/13/vistor-on-homepage-led-indicator.html</link>
      <pubDate>2013-03-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;本方法只适合小网站，主要是好玩。Raspberry Pi不是很合适需要实时控制的系统（比如，飞行器，遥控小车），因为Linux内核要多任务，应用程序的优先级不能保持最高，会带来延时，但做些实时性要求不高的系统还是可以的。&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;硬件安装&#34; href=&#34;#硬件安装&#34;&gt;&lt;/a&gt;硬件安装&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;需要以下硬件：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;可以工作的&lt;a href=&#34;http://s.click.taobao.com/t?e=zGU34CA7K%2BPkqB07S4%2FK0CITy7klxxrJ35Nnc0iO6niAHo44Chb01aWIu4ho12MwdcCLV6ff8kJMg0iz0FTGXaJAqMvt94sTe0NIrCAdd8LW&#34;&gt;树莓派&lt;/a&gt;一个&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://s.click.taobao.com/t?e=zGU34CA7K%2BPkqB07S4%2FK0CITy7klxxrJ35Nnc0iO6niAHoWKV0kwS8Wy16Cg6qBM%2BZAOnJCqNG%2BPJAy9U15g8TwJiq5U3GGcJ8eTvC7%2F6APShw%3D%3D&#34;&gt;1P杜邦线2条&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://s.click.taobao.com/t?e=zGU34CA7K%2BPkqB07S4%2FK0CFcRfH0GoT805sipKjxiNm9RKSkRargJCPYP6KVEIQUWKzMUFn1hvlcbkMSKk3m2pVJo%2BqQDYKVz%2Bt1%2FjL7Iywe7g%3D%3D&#34;&gt;面包板&lt;/a&gt;一个&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://s.click.taobao.com/t?e=zGU34CA7K%2BPkqB07S4%2FK0CITy7klxxrJ35Nnc0iO6niAHKxVk7v382jKYSyD7qi5ltcqvLWmWBL7lxLB2%2BsaWLuet8Ik65QHyGWV5mRTheUA&#34;&gt;面包板跳线&lt;/a&gt; 或 &lt;a href=&#34;http://detail.tmall.com/item.htm?spm=a220m.1000858.1000725.166.XlEzyw&amp;amp;id=15208013820&amp;amp;_u=nqa35596&amp;amp;is_b=1&amp;amp;cat_id=2&amp;amp;q=%C5%C5%D5%EB&amp;amp;rn=bb53adf333ca7517208da34346ac3ffb&#34;&gt;单排针&lt;/a&gt; 两根&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://detail.tmall.com/item.htm?spm=a220m.1000858.1000725.30.wnPTNf&amp;amp;id=14576731464&amp;amp;_u=nqa35af3&amp;amp;is_b=1&amp;amp;cat_id=2&amp;amp;q=%B7%A2%B9%E2%B6%FE%BC%AB%B9%DC&amp;amp;rn=b12ffd48699547ed9cb982a88014a0aa&#34;&gt;发光二极管&lt;/a&gt;一个&lt;/li&gt;&#xA;&lt;li&gt;300欧姆的&lt;a href=&#34;http://s.click.taobao.com/t?e=zGU34CA7K%2BPkqB07S4%2FK0CFcRfH0GoT805sipKjxiNm80QgaIDkojjQIBhc4L8WmRpaGVVBVD9DpAt8wKPZTmbzvVp4EIdCD2Ow2DOQmdPtlV8g%3D&#34;&gt;电阻&lt;/a&gt;一个&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;gpio接口&#34; href=&#34;#gpio接口&#34;&gt;&lt;/a&gt;GPIO接口&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/6bc40342gw1e2o2uls7wlj.jpg&#34; width=&#34;630&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;用杜邦线将上图的3.3V输出和GPIO 23引出（板子正面朝上，GPIO引脚在左上角），将电阻和LED串联起来（电阻防止LED电流过大烧掉），注意二极管的两根脚不一样长，长脚的接正级，这样GPIO 23如果输出高电平，二极管就不发光了，输出低电平就亮啦！&lt;/p&gt;&#xA;&#xA;&lt;p&gt;都接好了后的样子如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://ww3.sinaimg.cn/bmiddle/6bc40342jw1e2ni9esb2uj.jpg&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;gpio接口编程&#34; href=&#34;#gpio接口编程&#34;&gt;&lt;/a&gt;GPIO接口编程&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;wiringpi&#34; href=&#34;#wiringpi&#34;&gt;&lt;/a&gt;WiringPi&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;An implementation of most of the Arduino Wiring functions for the Raspberry Pi。&#xA;代码地址在： &lt;a href=&#34;https://github.com/wiringPi&#34;&gt;https://github.com/wiringPi&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;安装：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/WiringPi/WiringPi&#xA;cd WiringPi/wiringPi&#xA;sudo make install   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;让二极管闪一下的示例代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;wiringPi.h&amp;gt;&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;stdlib.h&amp;gt;&#xA;&#xA;int main (int argc, char* argv[])&#xA;{&#xA;    int pinNumber = 4;&#xA;    if (-1 == wiringPiSetup()) {&#xA;        printf(&amp;quot;failed to setup wiringPi&amp;quot;);&#xA;        return 1;&#xA;    }   &#xA;    pinMode(pinNumber, OUTPUT);&#xA;    digitalWrite(pinNumber, 1);&#xA;    delay(200);&#xA;    digitalWrite(pinNumber, 0);&#xA;    delay(200);&#xA;    return 0;   &#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;WiringPi也有Python, Perl, PHP, Ruby的接口包装，按&lt;a href=&#34;https://github.com/wiringPi&#34;&gt;这里&lt;/a&gt;，怎么没有Go的呢。。。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;rpi.gpio&#34; href=&#34;#rpi.gpio&#34;&gt;&lt;/a&gt;RPi.GPIO&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;这是GPIO的Python库，地址在：&lt;a href=&#34;https://pypi.python.org/pypi/RPi.GPIO&#34;&gt;https://pypi.python.org/pypi/RPi.GPIO&lt;/a&gt;&#xA;这里建议用python2，原因是web.py还不支持python 3 &amp;hellip;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;pacman -S python2&#xA;pacman -S python2-distribute&#xA;easy_install RPi.GPIO&#xA;    &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;让二极管一直闪的示例代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import RPi.GPIO as GPIO&#xA;import time&#xA;&#xA;PORT = 16&#xA;&#xA;GPIO.setwarnings(False) &#xA;GPIO.setmode(GPIO.BOARD)&#xA;&#xA;GPIO.setup(PORT,GPIO.OUT)&#xA;&#xA;while True:&#xA;    GPIO.output(PORT,True)&#xA;    time.sleep(0.2)&#xA;    GPIO.output(PORT,False)&#xA;    time.sleep(0.2)&#xA;    &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;webiopi&#34; href=&#34;#webiopi&#34;&gt;&lt;/a&gt;Webiopi&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;项目地址： &lt;a href=&#34;http://code.google.com/p/webiopi/&#34;&gt;http://code.google.com/p/webiopi/&lt;/a&gt; 这是一个使用RESTful API控制Pi的GPIO接口，文档丰富，使用起来非常简单。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;安装好后，用命令&lt;code&gt;python -m webiopi&lt;/code&gt;启动，用浏览器打开 &lt;a href=&#34;http://webiopi:raspberry@raspberrypi2:8000/webiopi/&#34;&gt;http://webiopi:raspberry@raspberrypi2:8000/webiopi/&lt;/a&gt; 可以看到控制界面，其中有GPIO 26个引脚的状态（输入输出，高电平或低电平），用鼠标点端口还可以修改数据：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://trouch.com/wp-content/uploads/2012/08/webiopi-chrome.png&#34; width=&#34;630&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;完成的代码&#34; href=&#34;#完成的代码&#34;&gt;&lt;/a&gt;完成的代码&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;最后用一小段代码来实现最初的想法，这段代码可以较实时的处理QPS&amp;lt;=3的网站流量，如果流量较大则会滞后反应。。。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;hugo@raspberrypi ~/bin $ cat traffic_led.sh &#xA;#!/bin/sh&#xA;&#xA;tail -F /mnt/usb/logs/nginx/access.log  | grep --line-buffered &amp;quot;GET / HTTP&amp;quot; | while read LINE; do  {&#xA;   #echo $LINE&#xA;   curl -s --data &amp;quot;&amp;quot; &amp;quot;http://webiopi:raspberry@raspberrypi2:8000/GPIO/23/value/0&amp;quot;&#xA;   sleep 0.2&#xA;   curl -s --data &amp;quot;&amp;quot; &amp;quot;http://webiopi:raspberry@raspberrypi2:8000/GPIO/23/value/1&amp;quot;&#xA;   sleep 0.1&#xA;}&#xA;done&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;类似的还可以用这个方法来提醒：来自某某某的新邮件到了，Github有Pull Requests了。。。,或者网站挂了。。。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>在Raspberry Pi上安装ArchLinux</title>
      <link>http://hugozhu.myalert.info/2013/03/09/setup-archliunx-on-raspberry-pi.html</link>
      <pubDate>2013-03-09 12:00:00 +0800</pubDate>
      <description>&#xA;&#xA;&lt;p&gt;&lt;h1&gt;目录：&lt;/h1&gt;&lt;nav&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_0&#34;&gt;介绍&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_1&#34;&gt;增加sudo用户&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_2&#34;&gt;USB盘&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_3&#34;&gt;Pacman&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_4&#34;&gt;UnixBench&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_5&#34;&gt;无线网络&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_6&#34;&gt;Samba&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_7&#34;&gt;注意事项&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/nav&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_0&#34;&gt;介绍&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;之前买的Raspberry Pi因为要跑&lt;a href=&#34;http://hugozhu.myalert.info&#34;&gt;这个网站&lt;/a&gt;，不能经常拔下来玩别的，所以又买了一个，这次安装的是&lt;a href=&#34;https://www.archlinux.org&#34;&gt;Arch Linux&lt;/a&gt;。这个发行版安装好后非常基础，占用的空间也只有600M不到，比较合适已有Linux基础的同学玩。初学者可以玩官方推荐的&lt;a href=&#34;http://www.raspbian.org&#34;&gt;Raspbian&lt;/a&gt;。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Arch Linux特点：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;启动快，上电后只要3s完成启动&lt;/li&gt;&#xA;&lt;li&gt;安装完没有图形界面，干净&lt;/li&gt;&#xA;&lt;li&gt;面向开发者的系统&lt;/li&gt;&#xA;&lt;li&gt;包管理系统pacman很好用，一个命令就可以完成各种操作&lt;/li&gt;&#xA;&lt;li&gt;ArchLinux缺省账号和密码是root/root，弄好了后要记得修改root密码&lt;/li&gt;&#xA;&lt;li&gt;从中国用下载包很快，比Raspbian的源快多了&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_1&#34;&gt;增加sudo用户&lt;/h1&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;   useradd hugo&#xA;   passwd hugo&#xA;   mkdir /home/hugo&#xA;   chown hugo:hugo /home/hugo   &#xA;   pacman -S sudo&#xA;   visudo   &#xA;   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;执行&lt;code&gt;visudo&lt;/code&gt;把新用户设置成管理员（增加sudo权限），最后面增加下面一行：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    hugo ALL=(ALL) NOPASSWD: ALL&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_2&#34;&gt;USB盘&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;插上USB盘后，ArchLinux并不会自动mount，手动mount的过程如下:&#xA;插上USB前后执行两次 &lt;code&gt;lsblk -o name,kname,uuid&lt;/code&gt;，那么输出上多出的那行就是该USB的设备名，或UUID，找到该行后就可以执行mount命令了（注意sda这个符号不同机器可能不一样）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    [root@raspberrypi2 ~]# lsblk -o name,kname,uuid   &#xA;    NAME        KNAME     UUID&#xA;    sda         sda       001B-9622&#xA;    mmcblk0     mmcblk0   &#xA;    ├─mmcblk0p1 mmcblk0p1 44C8-CEF1&#xA;    └─mmcblk0p2 mmcblk0p2 fcee8534-f5f0-42ee-83ac-f943f878ee67&#xA;    &#xA;    mkdir /mnt/usb&#xA;    mount /dev/sda /mnt/usb &#xA;    或 &#xA;    mount -U 001B-9622 /mnt/usb&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;格式化整个USB盘可以用&lt;code&gt;mkfs.ext4 /dev/sda&lt;/code&gt;&#xA;然后在/etc/fstab里增加一行，以后重启就会自动mount了：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/dev/sda       /mnt/usb        ext4    defaults,noatime  0       0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;还可以测试一下SD卡和USB盘的读写性能：&#xA;&#xA;[root@raspberrypi2 ~]# hdparm -Tt /dev/mmcblk0&lt;/p&gt;&#xA;&#xA;&lt;p&gt;/dev/mmcblk0:&#xA; Timing cached reads:   292 MB in  2.00 seconds = 145.73 MB/sec&#xA; Timing buffered disk reads:  48 MB in  3.12 seconds =  15.38 MB/sec&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[root@raspberrypi2 ~]# hdparm  -Tt /dev/sda&lt;/p&gt;&#xA;&#xA;&lt;p&gt;/dev/sda:&#xA; Timing cached reads:   280 MB in  2.00 seconds = 139.80 MB/sec&#xA; Timing buffered disk reads:  50 MB in  3.01 seconds =  16.61 MB/sec&#xA; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;等多信息可参考&lt;a href=&#34;https://wiki.archlinux.org/index.php/USB_Storage_Devices#Auto-mounting_with_udev&#34;&gt;Wiki&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_3&#34;&gt;Pacman&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;ArchLinux的包管理软件是pacman，类似apt-get, yum等，这里有所有的包：&lt;a href=&#34;http://archlinuxarm.org/packages&#34;&gt;http://archlinuxarm.org/packages&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Pacman&#34;&gt;使用方法&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;pacman -Syu &amp;amp;&amp;amp; sync #更新整个系统，&lt;strong&gt;新安装好要运行一次&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;pacman -S gcc make git #安装gcc, make等，作为程序员必须的&lt;/li&gt;&#xA;&lt;li&gt;pacman -R package_name &amp;ndash;nosave #删除干净某个包&lt;/li&gt;&#xA;&lt;li&gt;pacman -Scc #完全清理包缓存&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_4&#34;&gt;UnixBench&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;了解一下性能基准测试非常有必要。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;curl http://byte-unixbench.googlecode.com/files/unixbench-5.1.2.tar.gz -o unixbench-5.1.2.tar.gz&#xA;tar zxvf unixbench-5.1.2.tar.gz&#xA;cd unixbench-5.1.2&#xA;make&#xA;./Run&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果没有X，要在Makefile里注释掉X的测试，结果如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;========================================================================&#xA;   BYTE UNIX Benchmarks (Version 5.1.2)&#xA;&#xA;   System: raspberrypi: GNU/Linux&#xA;   OS: GNU/Linux -- 3.2.27+ -- #250 PREEMPT Thu Oct 18 19:03:02 BST 2012&#xA;   Machine: armv6l (unknown)&#xA;   Language: en_US.utf8 (charmap=&amp;quot;ANSI_X3.4-1968&amp;quot;, collate=&amp;quot;ANSI_X3.4-1968&amp;quot;)&#xA;   23:12:18 up 63 days, 22:35,  2 users,  load average: 0.27, 0.28, 0.23; runlevel 2&#xA;&#xA;------------------------------------------------------------------------&#xA;Benchmark Run: Sat Mar 09 2013 23:12:18 - 23:41:57&#xA;0 CPUs in system; running 1 parallel copy of tests&#xA;&#xA;Dhrystone 2 using register variables        1686980.7 lps   (10.0 s, 7 samples)&#xA;Double-Precision Whetstone                      269.9 MWIPS (10.0 s, 7 samples)&#xA;Execl Throughput                                256.8 lps   (29.7 s, 2 samples)&#xA;File Copy 1024 bufsize 2000 maxblocks         43489.0 KBps  (30.0 s, 2 samples)&#xA;File Copy 256 bufsize 500 maxblocks           14568.0 KBps  (30.0 s, 2 samples)&#xA;File Copy 4096 bufsize 8000 maxblocks         96518.7 KBps  (30.0 s, 2 samples)&#xA;Pipe Throughput                              172158.1 lps   (10.0 s, 7 samples)&#xA;Pipe-based Context Switching                  24098.7 lps   (10.0 s, 7 samples)&#xA;Process Creation                                772.2 lps   (30.0 s, 2 samples)&#xA;Shell Scripts (1 concurrent)                    462.6 lpm   (60.1 s, 2 samples)&#xA;Shell Scripts (8 concurrent)                     59.0 lpm   (60.5 s, 2 samples)&#xA;System Call Overhead                         396466.7 lps   (10.0 s, 7 samples)&#xA;&#xA;System Benchmarks Index Values               BASELINE       RESULT    INDEX&#xA;Dhrystone 2 using register variables         116700.0    1686980.7    144.6&#xA;Double-Precision Whetstone                       55.0        269.9     49.1&#xA;Execl Throughput                                 43.0        256.8     59.7&#xA;File Copy 1024 bufsize 2000 maxblocks          3960.0      43489.0    109.8&#xA;File Copy 256 bufsize 500 maxblocks            1655.0      14568.0     88.0&#xA;File Copy 4096 bufsize 8000 maxblocks          5800.0      96518.7    166.4&#xA;Pipe Throughput                               12440.0     172158.1    138.4&#xA;Pipe-based Context Switching                   4000.0      24098.7     60.2&#xA;Process Creation                                126.0        772.2     61.3&#xA;Shell Scripts (1 concurrent)                     42.4        462.6    109.1&#xA;Shell Scripts (8 concurrent)                      6.0         59.0     98.3&#xA;System Call Overhead                          15000.0     396466.7    264.3&#xA;                                                                   ========&#xA;System Benchmarks Index Score                                          99.9&#xA;&#xA;&#xA;========================================================================&#xA;   BYTE UNIX Bench  marks (Version 5.1.2)&#xA;&#xA;   System: raspberrypi2: GNU/Linux&#xA;   OS: GNU/Linux -- 3.6.11-8-ARCH+ -- #1 PREEMPT Sat Mar 9 00:38:58 UTC 2013&#xA;   Machine: armv6l (unknown)&#xA;   Language: en_US.utf8 (charmap=&amp;quot;UTF-8&amp;quot;, collate=&amp;quot;ANSI_X3.4-1968&amp;quot;)&#xA;   23:11:34 up 40 min,  2 users,  load average: 0.32, 0.56, 0.40; runlevel 5&#xA;&#xA;------------------------------------------------------------------------&#xA;Benchmark Run: Sat Mar 09 2013 23:11:34 - 23:40:13&#xA;0 CPUs in system; running 1 parallel copy of tests&#xA;&#xA;Dhrystone 2 using register variables        1686859.5 lps   (10.1 s, 7 samples)&#xA;Double-Precision Whetstone                      240.0 MWIPS (10.0 s, 7 samples)&#xA;Execl Throughput                                235.9 lps   (29.8 s, 2 samples)&#xA;File Copy 1024 bufsize 2000 maxblocks         36862.7 KBps  (30.0 s, 2 samples)&#xA;File Copy 256 bufsize 500 maxblocks           11351.7 KBps  (30.0 s, 2 samples)&#xA;File Copy 4096 bufsize 8000 maxblocks         79915.7 KBps  (30.0 s, 2 samples)&#xA;Pipe Throughput                              127650.5 lps   (10.1 s, 7 samples)&#xA;Pipe-based Context Switching                  18840.9 lps   (10.1 s, 7 samples)&#xA;Process Creation                                779.2 lps   (30.1 s, 2 samples)&#xA;Shell Scripts (1 concurrent)                    193.1 lpm   (60.3 s, 2 samples)&#xA;Shell Scripts (8 concurrent)                     26.7 lpm   (60.7 s, 2 samples)&#xA;System Call Overhead                         314659.8 lps   (10.1 s, 7 samples)&#xA;&#xA;System Benchmarks Index Values               BASELINE       RESULT    INDEX&#xA;Dhrystone 2 using register variables         116700.0    1686859.5    144.5&#xA;Double-Precision Whetstone                       55.0        240.0     43.6&#xA;Execl Throughput                                 43.0        235.9     54.9&#xA;File Copy 1024 bufsize 2000 maxblocks          3960.0      36862.7     93.1&#xA;File Copy 256 bufsize 500 maxblocks            1655.0      11351.7     68.6&#xA;File Copy 4096 bufsize 8000 maxblocks          5800.0      79915.7    137.8&#xA;Pipe Throughput                               12440.0     127650.5    102.6&#xA;Pipe-based Context Switching                   4000.0      18840.9     47.1&#xA;Process Creation                                126.0        779.2     61.8&#xA;Shell Scripts (1 concurrent)                     42.4        193.1     45.6&#xA;Shell Scripts (8 concurrent)                      6.0         26.7     44.5&#xA;System Call Overhead                          15000.0     314659.8    209.8&#xA;                                                                   ========&#xA;System Benchmarks Index Score                                          76.3&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;看上去ArchLinux性能差了一节，看来官方推荐Raspian确实做了不少优化，我觉得介绍一下系统方面的优化，也是非常不错的内容。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_5&#34;&gt;无线网络&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;我买的是基于RT5370芯片组的腾达W311MI，Raspberry Pi支持的很好。&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;确认系统已经识别USB网卡，如下&lt;code&gt;RT5370 Wireless Adapter&lt;/code&gt;就代表已经识别成功&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[root@raspberrypi2 ~]# lsusb&#xA;Bus 001 Device 002: ID 0424:9512 Standard Microsystems Corp. LAN9500 Ethernet 10/100 Adapter&#xA;Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub&#xA;Bus 001 Device 003: ID 0424:ec00 Standard Microsystems Corp. &#xA;Bus 001 Device 004: ID 148f:5370 Ralink Technology, Corp. RT5370 Wireless Adapter&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;安装无线工具&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;pacman -S wireless_tools&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;设置开机启动无线网络&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用&lt;code&gt;wifi-menu&lt;/code&gt;手动连上wifi ap，可以连多个，相应的输入会保存在：/etc/network.d/，在下面的文件里输入相应的文件名&lt;/p&gt;&#xA;&#xA;&lt;p&gt;修改/etc/conf.d/netcfg&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;DHCP_TIMEOUT=30 &#xA;AUTO_PROFILES=(&amp;quot;wlan0-Hugo2&amp;quot; &amp;quot;wlan0-hugo&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果是隐藏SSID的要加一行&amp;rdquo;HIDDEN=YES&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;执行一下命令在重启时自动连上wifi&#xA;&lt;code&gt;&#xA;systemctl enable net-auto-wireless&#xA;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;有条件的可以在路由器里设置好根据MAC地址总是分配同一个ip给Pi，这样就可以拔掉网线的束缚了~&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;测试了断开后可以自动重连&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;用scp测试从Mac通过无线传大文件到Raspberry Pi，传输速度只有1.6MB/s，如果通过网线传则有4MB/s&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_6&#34;&gt;Samba&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;安装相关包： &lt;code&gt;pacman -S samba&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;生成一个配置文件： &lt;code&gt;cp /etc/samba/smb.conf.default /etc/samba/smb.conf&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;加到启动脚本里： &lt;code&gt;systemctl enable smbd.service&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;增加一个samba用户： &lt;code&gt;smbpasswd -a hugo&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_7&#34;&gt;注意事项&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;因为Pi没有实时时钟，ntpd 或 openntpd在无线网络下可能先于wifi开始工作启动，造成服务不工作，系统日期未初始化成功。我的解决方案是系统启动完成后延时10s执行ntpdate设置时间（期望这个时候wifi已经工作了），并且重启samba服务（好像日期不正常samba也不正常，这块还没仔细研究）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>如何封杀尝试Raspberry Pi SSH密码的来源IP</title>
      <link>http://hugozhu.myalert.info/2013/03/08/block_failed_ssh_attempts_with_iptable.html</link>
      <pubDate>2013-03-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Raspberry Pi整天开着，如果用缺省SSH端口对外开放，就会经常遇到扫描SSH密码的肉鸡。虽然密码不是很简单，但还是感觉很不安全的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;系统的ssh登录日志文件在：/var/log/auth.log，登录失败时会记录以下格式的日志：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Mar  7 10:31:51 raspberrypi sshd[24510]: Failed password for root from 221.8.19.129 port 4066 ssh2&#xA;Mar  7 10:31:55 raspberrypi sshd[24514]: Failed password for root from 221.8.19.129 port 4079 ssh2&#xA;Mar  7 10:31:56 raspberrypi sshd[24518]: Failed password for sshd from 221.8.19.129 port 4080 ssh2&#xA;Mar  7 10:32:26 raspberrypi sshd[24522]: Failed password for sshd from 221.8.19.129 port 4149 ssh2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;用最简单的Shell脚本来解决这个问题：&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;guard.sh&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/bin/bash&#xA;&#xA;last_ip=&amp;quot;&amp;quot;&#xA;tail -f /var/log/auth | while read LINE; do&#xA;{&#xA;    if [[ &amp;quot;${LINE}&amp;quot; =~ &amp;quot;Failed&amp;quot; ]]; then            &#xA;        ip=&amp;quot;$(echo ${LINE} | awk &#39;{print $(NF-3)}&#39;)&amp;quot;&#xA;        if [[ &amp;quot;$last_ip&amp;quot; == &amp;quot;$ip&amp;quot; ]]; then&#xA;             echo &amp;quot;block $ip&amp;quot;&#xA;             #curl -s --data-ascii &amp;quot;uuid=&amp;lt;my iphone&#39;s uuid&amp;gt;&amp;quot; --data &amp;quot;body=${LINE}&amp;quot; http://raspberrypi/pushme                 &#xA;             iptables -A INPUT -s &amp;quot;$ip&amp;quot; -j DROP&#xA;        fi&#xA;        last_ip=$ip&#xA;        echo $LINE&#xA;    fi&#xA;}&#xA;done&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;用root用户执行以下命令，也可以放到启动脚本里：/etc/rc.local&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;nohup /root/bin/guard.sh &amp;gt; /var/logs/guard.log 2&amp;gt;&amp;amp;1 &amp;amp;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果连续两次输错密码，那ip就会被封，我另外加了一个报警，会通知到我的手机，这下感觉安全了些。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;登录Pi用&lt;code&gt;iptables -L&lt;/code&gt;可以看到被封杀的IP列表，如果需要解封这些IP，可以用命令&lt;code&gt;iptables -F&lt;/code&gt;，也可以用crontjob每天定时运行一次&lt;code&gt;iptables -F&lt;/code&gt;来清除&lt;/p&gt;&#xA;&#xA;&lt;p&gt;脚本还很简单，还可以有不少改进，可以在评论里讨论。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Raspberry Pi做BT下载机+高清播放器</title>
      <link>http://hugozhu.myalert.info/2013/03/06/raspberry-pi-with-xmbc.html</link>
      <pubDate>2013-03-06 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;介绍&#34; href=&#34;#介绍&#34;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;首先高清播放器功能只是Raspberry Pi的一个小功能，如果你只需要高清播放功能又不想折腾，那还是买个&lt;a href=&#34;http://s.taobao.com/search?q=%B8%DF%C7%E5%B2%A5%B7%C5%C6%F7&amp;amp;commend=all&amp;amp;ssid=s5-e&amp;amp;search_type=item&amp;amp;sourceId=tb.index&amp;amp;initiative_id=tbindexz_20130306&#34;&gt;山寨的&lt;/a&gt;的更简单。。。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Raspberry Pi的图形处理器规格：Broadcom VideoCore IV, OpenGL ES 2.0, 1080p 30 h.264/MPEG-4 AVC 高清解码器，内存和CPU共享（可设置成256M），性能还是很强劲的。HDMI支持640x350和1920×1200（1080P）的分辨率。安装了&lt;a href=&#34;http://xbmc.org&#34;&gt;XBMC&lt;/a&gt;，基本上可以实现包括Airplay在内的Apple TV上的大部分功能，但价格只有其一半不到，可以播放下载的视频或观看在线视频，如&lt;a href=&#34;http://yisou.com&#34;&gt;一搜&lt;/a&gt;，优酷，搜狐视频，奇艺等。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;外设&#34; href=&#34;#外设&#34;&gt;&lt;/a&gt;外设&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;除了Pi单片机外，你还需要以下外设附件：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;5V-1A左右的电源，可以用iPhone或iPad的充电电源，或手机的充电器，电流最少要800毫安&lt;/li&gt;&#xA;&lt;li&gt;micro USB线一根，和Kindle以及大多数android手机充电USB线一样&lt;/li&gt;&#xA;&lt;li&gt;HDMI线一根，接电视机&lt;/li&gt;&#xA;&lt;li&gt;SD卡一张，最少2G&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;raspbmc&#34; href=&#34;#raspbmc&#34;&gt;&lt;/a&gt;Raspbmc&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.raspbmc.com/&#34;&gt;Raspbmc&lt;/a&gt; 是专为在Raspberry Pi上运行&lt;a href=&#34;http://xbmc.org&#34;&gt;XBMC&lt;/a&gt;的定制Linux。最小化的安装，减少了不必要的软件和资源占用，简化了安装和配置，没有Linux知识也可以上手。这个版本的维护者是一个19岁的小朋友Sam Nazarko。有时间折腾的同学可以自己编译XMBC安装。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;特点：&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;免费，开源&lt;/li&gt;&#xA;&lt;li&gt;支持多语言&lt;/li&gt;&#xA;&lt;li&gt;支持1080P回放&lt;/li&gt;&#xA;&lt;li&gt;支持直接播放NFS，SMB，FTP,HTTP或USB硬盘的有视频文件，支持大多数格式&lt;/li&gt;&#xA;&lt;li&gt;支持AirPlay或AirTune功能，可以把iPhone/iPad上的视频或音乐通过Pi投放到电视上，这点和Apple TV功能一样&lt;/li&gt;&#xA;&lt;li&gt;支持GPIO&lt;/li&gt;&#xA;&lt;li&gt;基于Debian，可以从Debian的软件源安装其它软件&lt;/li&gt;&#xA;&lt;li&gt;支持1080P DTS软解，这个不少播放器是不支持的，需要额外License&lt;/li&gt;&#xA;&lt;li&gt;内置了以下服务:&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Samba&lt;/li&gt;&#xA;&lt;li&gt;TVHeadend Server&lt;/li&gt;&#xA;&lt;li&gt;FTP Server&lt;/li&gt;&#xA;&lt;li&gt;SSH Server&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;安装&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Windows下载&lt;a href=&#34;http://download.raspbmc.com/downloads/bin/installers/raspbmc-win32.zip&#34;&gt;安装程序&lt;/a&gt;，运行即可。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.raspbmc.com/wp-content/uploads/2012/06/ins-300x165.jpg&#34; alt=&#34;image&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Linux/Mac:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;curl -O http://svn.stmlabs.com/svn/raspbmc/testing/installers/python/install.py&#xA;chmod +x install.py&#xA;sudo python install.py&#xA;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.raspbmc.com/wp-content/uploads/2012/06/installPython.png&#34; alt=&#34;image&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;或直接下载&lt;a href=&#34;http://download.raspbmc.com/downloads/bin/ramdistribution/installer.img.gz&#34;&gt;安装包&lt;/a&gt;安装&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;下载&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;你可以在Pi上外接一个USB移动硬盘，但要注意硬盘要有自己电源，也可以mount网络上的硬盘分区。然后运行transmission软件下载视频。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;Transmission&lt;/h4&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;安装&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install transmission-daemon&#xA;sudo /etc/init.d/transmission-daemon stop&#xA;sudo nano /etc/transmission-daemon/settings.json&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;配置&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    “rpc-whitelist”: “127.0.0.1″, to “rpc-whitelist”: “*.*.*.*”,&#xA;    “rpc-password”: “password”, to “rpc-password”: “替换成管理密码“,&#xA;    “rpc-username”: “username”, to “rpc-username”: “替换成管理用户“,   &#xA;    “download-dir”：“\/home\/xbmc\/Videos\/Downloads”,&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    sudo chmod g+rw /home/xbmc/Videos/Downloads&#xA;    sudo chgrp -R debian-transmission /home/xbmc/Videos/Downloads   &#xA;    sudo /etc/init.d/transmission-daemon start&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;24x7开始下载，耗电量很低的，这是下载界面：&#xA;&lt;img src=&#34;https://pbs.twimg.com/media/BErnJ-6CcAEVYsV.jpg:large&#34; alt=&#34;image&#34; /&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;遥控和播放&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;遥控方案有两种：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;红外接收器 + 电视/DVD/VCD/EVD等已有遥控器，&lt;a href=&#34;http://forum.stmlabs.com/showthread.php?tid=5549&#34;&gt;这里&lt;/a&gt;有一个实现方案&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;通过网络用手机来遥控，其实就是用任何一个xmbc的客户端&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;iPhone: &lt;a href=&#34;https://itunes.apple.com/us/app/unofficial-official-xbmc-remote/id520480364?ls=1&amp;amp;mt=8&#34;&gt;Offical XBMC Remote&lt;/a&gt; 免费的&lt;/li&gt;&#xA;&lt;li&gt;Android: &lt;a href=&#34;http://code.google.com/p/android-xbmcremote/&#34;&gt;Android XBMC Remote&lt;/a&gt; 免费的&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;参考文章:&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.raspbmc.com/about/&#34;&gt;http://www.raspbmc.com/about/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>Java并发包中的同步队列SynchronousQueue实现原理</title>
      <link>http://hugozhu.myalert.info/2013/03/05/java-SynchronousQueue-notes.html</link>
      <pubDate>2013-03-05 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;介绍&#34; href=&#34;#介绍&#34;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Java 6的并发编程包中的&lt;a href=&#34;http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/SynchronousQueue.html&#34;&gt;SynchronousQueue&lt;/a&gt;是一个没有数据缓冲的&lt;a href=&#34;http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/BlockingQueue.html&#34;&gt;BlockingQueue&lt;/a&gt;，生产者线程对其的插入操作put必须等待消费者的移除操作take，反过来也一样。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不像ArrayBlockingQueue或LinkedListBlockingQueue，SynchronousQueue内部并没有数据缓存空间，你不能调用peek()方法来看队列中是否有数据元素，因为数据元素只有当你试着取走的时候才可能存在，不取走而只想偷窥一下是不行的，当然遍历这个队列的操作也是不允许的。队列头元素是第一个排队要插入数据的&lt;strong&gt;线程&lt;/strong&gt;，而不是要交换的数据。数据是在配对的生产者和消费者线程之间直接传递的，并不会将数据缓冲数据到队列中。可以这样来理解：生产者和消费者互相等待对方，握手，然后&lt;strong&gt;一起&lt;/strong&gt;离开。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;SynchronousQueue的一个使用场景是在线程池里。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;实现原理&#34; href=&#34;#实现原理&#34;&gt;&lt;/a&gt;实现原理&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;同步队列的实现方法有许多：&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;阻塞算法实现&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;阻塞算法实现通常在内部采用一个锁来保证多个线程中的put()和take()方法是串行执行的。采用锁的开销是比较大的，还会存在一种情况是线程A持有线程B需要的锁，B必须一直等待A释放锁，即使A可能一段时间内因为B的优先级比较高而得不到时间片运行。所以在高性能的应用中我们常常希望规避锁的使用。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class NativeSynchronousQueue&amp;lt;E&amp;gt; {&#xA;    boolean putting = false;&#xA;    E item = null;&#xA;&#xA;    public synchronized E take() throws InterruptedException {&#xA;        while (item == null)&#xA;            wait();&#xA;        E e = item;&#xA;        item = null;&#xA;        notifyAll();&#xA;        return e;&#xA;    }&#xA;&#xA;    public synchronized void put(E e) throws InterruptedException {&#xA;        if (e==null) return;&#xA;        while (putting)&#xA;            wait();&#xA;        putting = true;&#xA;        item = e;&#xA;        notifyAll();&#xA;        while (item!=null)&#xA;            wait();&#xA;        putting = false;&#xA;        notifyAll();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;信号量实现&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;经典同步队列实现采用了三个信号量，代码很简单，比较容易理解：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class SemaphoreSynchronousQueue&amp;lt;E&amp;gt; {&#xA;    E item = null;&#xA;    Semaphore sync = new Semaphore(0);&#xA;    Semaphore send = new Semaphore(1);&#xA;    Semaphore recv = new Semaphore(0);&#xA;&#xA;    public E take() throws InterruptedException {&#xA;        recv.acquire();&#xA;        E x = item;&#xA;        sync.release();&#xA;        send.release();&#xA;        return x;&#xA;    }&#xA;&#xA;    public void put (E x) throws InterruptedException{&#xA;        send.acquire();&#xA;        item = x;&#xA;        recv.release();&#xA;        sync.acquire();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在多核机器上，上面方法的同步代价仍然较高，操作系统调度器需要上千个时间片来阻塞或唤醒线程，而上面的实现即使在生产者put()时已经有一个消费者在等待的情况下，阻塞和唤醒的调用仍然需要。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Java 5实现&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class Java5SynchronousQueue&amp;lt;E&amp;gt; {&#xA;    ReentrantLock qlock = new ReentrantLock();&#xA;    Queue waitingProducers = new Queue();&#xA;    Queue waitingConsumers = new Queue();&#xA;    &#xA;    static class Node extends AbstractQueuedSynchronizer {&#xA;        E item;&#xA;        Node next;&#xA;        &#xA;        Node(Object x) { item = x; }&#xA;        void waitForTake() { /* (uses AQS) */ }&#xA;           E waitForPut() { /* (uses AQS) */ }&#xA;    }&#xA;    &#xA;    public E take() {&#xA;        Node node;&#xA;        boolean mustWait;&#xA;        qlock.lock();&#xA;        node = waitingProducers.pop();&#xA;        if(mustWait = (node == null))&#xA;           node = waitingConsumers.push(null);&#xA;         qlock.unlock();&#xA;    &#xA;        if (mustWait)&#xA;           return node.waitForPut();&#xA;        else&#xA;            return node.item;&#xA;    }&#xA;    &#xA;    public void put(E e) {&#xA;         Node node;&#xA;         boolean mustWait;&#xA;         qlock.lock();&#xA;         node = waitingConsumers.pop();&#xA;         if (mustWait = (node == null))&#xA;             node = waitingProducers.push(e);&#xA;         qlock.unlock();&#xA;        &#xA;         if (mustWait)&#xA;             node.waitForTake();&#xA;         else&#xA;            node.item = e;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Java 5的实现相对来说做了一些优化，只使用了一个锁，使用队列代替信号量也可以允许发布者直接发布数据，而不是要首先从阻塞在信号量处被唤醒。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Java6实现&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Java 6的SynchronousQueue的实现采用了一种性能更好的&lt;strong&gt;无锁算法&lt;/strong&gt; &amp;ndash; 扩展的“&lt;a href=&#34;http://www.cs.rochester.edu/research/synchronization/pseudocode/duals.html&#34;&gt;Dual stack and Dual queue&lt;/a&gt;”算法。性能比Java5的实现有较大提升。竞争机制支持公平和非公平两种：非公平竞争模式使用的数据结构是后进先出栈(Lifo Stack)；公平竞争模式则使用先进先出队列（Fifo Queue），性能上两者是相当的，一般情况下，Fifo通常可以支持更大的吞吐量，但Lifo可以更大程度的保持线程的本地化。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码实现里的Dual Queue或Stack内部是用链表(LinkedList)来实现的，其节点状态为以下三种情况：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;持有数据 - put()方法的元素&lt;/li&gt;&#xA;&lt;li&gt;持有请求 - take()方法&lt;/li&gt;&#xA;&lt;li&gt;空&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;这个算法的特点就是任何操作都可以根据节点的状态判断执行，而不需要用到锁。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其核心接口是Transfer，生产者的put或消费者的take都使用这个接口，根据第一个参数来区别是入列（栈）还是出列（栈）。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    /**&#xA;     * Shared internal API for dual stacks and queues.&#xA;     */&#xA;    static abstract class Transferer {&#xA;        /**&#xA;         * Performs a put or take.&#xA;         *&#xA;         * @param e if non-null, the item to be handed to a consumer;&#xA;         *          if null, requests that transfer return an item&#xA;         *          offered by producer.&#xA;         * @param timed if this operation should timeout&#xA;         * @param nanos the timeout, in nanoseconds&#xA;         * @return if non-null, the item provided or received; if null,&#xA;         *         the operation failed due to timeout or interrupt --&#xA;         *         the caller can distinguish which of these occurred&#xA;         *         by checking Thread.interrupted.&#xA;         */&#xA;        abstract Object transfer(Object e, boolean timed, long nanos);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;TransferQueue实现如下(摘自Java 6源代码)，入列和出列都基于Spin和CAS方法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;        /**&#xA;         * Puts or takes an item.&#xA;         */&#xA;        Object transfer(Object e, boolean timed, long nanos) {&#xA;            /* Basic algorithm is to loop trying to take either of&#xA;             * two actions:&#xA;             *&#xA;             * 1. If queue apparently empty or holding same-mode nodes,&#xA;             *    try to add node to queue of waiters, wait to be&#xA;             *    fulfilled (or cancelled) and return matching item.&#xA;             *&#xA;             * 2. If queue apparently contains waiting items, and this&#xA;             *    call is of complementary mode, try to fulfill by CAS&#39;ing&#xA;             *    item field of waiting node and dequeuing it, and then&#xA;             *    returning matching item.&#xA;             *&#xA;             * In each case, along the way, check for and try to help&#xA;             * advance head and tail on behalf of other stalled/slow&#xA;             * threads.&#xA;             *&#xA;             * The loop starts off with a null check guarding against&#xA;             * seeing uninitialized head or tail values. This never&#xA;             * happens in current SynchronousQueue, but could if&#xA;             * callers held non-volatile/final ref to the&#xA;             * transferer. The check is here anyway because it places&#xA;             * null checks at top of loop, which is usually faster&#xA;             * than having them implicitly interspersed.&#xA;             */&#xA;&#xA;            QNode s = null; // constructed/reused as needed&#xA;            boolean isData = (e != null);&#xA;&#xA;            for (;;) {&#xA;                QNode t = tail;&#xA;                QNode h = head;&#xA;                if (t == null || h == null)         // saw uninitialized value&#xA;                    continue;                       // spin&#xA;&#xA;                if (h == t || t.isData == isData) { // empty or same-mode&#xA;                    QNode tn = t.next;&#xA;                    if (t != tail)                  // inconsistent read&#xA;                        continue;&#xA;                    if (tn != null) {               // lagging tail&#xA;                        advanceTail(t, tn);&#xA;                        continue;&#xA;                    }&#xA;                    if (timed &amp;amp;&amp;amp; nanos &amp;lt;= 0)        // can&#39;t wait&#xA;                        return null;&#xA;                    if (s == null)&#xA;                        s = new QNode(e, isData);&#xA;                    if (!t.casNext(null, s))        // failed to link in&#xA;                        continue;&#xA;&#xA;                    advanceTail(t, s);              // swing tail and wait&#xA;                    Object x = awaitFulfill(s, e, timed, nanos);&#xA;                    if (x == s) {                   // wait was cancelled&#xA;                        clean(t, s);&#xA;                        return null;&#xA;                    }&#xA;&#xA;                    if (!s.isOffList()) {           // not already unlinked&#xA;                        advanceHead(t, s);          // unlink if head&#xA;                        if (x != null)              // and forget fields&#xA;                            s.item = s;&#xA;                        s.waiter = null;&#xA;                    }&#xA;                    return (x != null)? x : e;&#xA;&#xA;                } else {                            // complementary-mode&#xA;                    QNode m = h.next;               // node to fulfill&#xA;                    if (t != tail || m == null || h != head)&#xA;                        continue;                   // inconsistent read&#xA;&#xA;                    Object x = m.item;&#xA;                    if (isData == (x != null) ||    // m already fulfilled&#xA;                        x == m ||                   // m cancelled&#xA;                        !m.casItem(x, e)) {         // lost CAS&#xA;                        advanceHead(h, m);          // dequeue and retry&#xA;                        continue;&#xA;                    }&#xA;&#xA;                    advanceHead(h, m);              // successfully fulfilled&#xA;                    LockSupport.unpark(m.waiter);&#xA;                    return (x != null)? x : e;&#xA;                }&#xA;            }&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;参考文章&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/SynchronousQueue.html&#34;&gt;Javadoc of SynchronousQueue&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.cs.rochester.edu/u/scott/papers/2009_Scherer_CACM_SSQ.pdf&#34;&gt;Scalable Synchronous Queues&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.cs.rochester.edu/research/synchronization/pseudocode/duals.html&#34;&gt;Nonblocking Concurrent Data Structures with Condition Synchronization&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>OpenVPN使用多个端口</title>
      <link>http://hugozhu.myalert.info/2013/03/02/openvpn-multiple-ports.html</link>
      <pubDate>2013-03-02 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Openvpn本身不能设置多个端口，使用iptables可以解决这个问题 （假设openvpn本来56788端口）：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;for port in {56780..56787}&#xA;do &#xA;    iptables -t nat -A PREROUTING -p tcp -d &amp;lt;your_external_ip&amp;gt; --dport $port -j REDIRECT --to-port 56788&#xA;done&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Java的资源管理</title>
      <link>http://hugozhu.myalert.info/2013/03/01/resource-management-in-java.html</link>
      <pubDate>2013-03-01 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;overview&#34; href=&#34;#overview&#34;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Java程序中的常见的资源有：文件，Socket，数据库连接。在使用这些资源时候要分外小心，因为操作系统可同时操作的资源是有限的，比如默认情况下系统允许同时打开的文件数为1024个，Mysql服务器默认允许的最大连接数是100，所以操作这些资源时候要注意即使在遇到错误时也要让系统能正确回收资源。如果发生错误时候，打开的文件描述符没关闭或数据库连接没关闭，积累到一定程度后，应用将会变得不可用，只能重启。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;try-catch-finally&#34; href=&#34;#try-catch-finally&#34;&gt;&lt;/a&gt;try-catch-finally&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Java提供了try-catch-finally来保证程序遇到异常时总是有机会可以处理资源的关闭 &amp;ndash; 调用资源对象的close()方法。但经验不足的Java程序员还是会错误的管理资源，而造成资源的泄露，静态代码分析工具，如&lt;a href=&#34;http://findbugs.sourceforge.net&#34;&gt;&lt;strong&gt;FindBugs&lt;/strong&gt;&lt;/a&gt;可以帮助发现此类问题。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先我们来看一段文件操作代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;private void copy(String from, String to) throws IOException {&#xA;    FileInputStream in = null;  &#xA;    FileOutputStream out = null;  &#xA;    in = new FileInputStream(from);  &#xA;    out = new FileOutputStream(to);  &#xA;    int c;  &#xA;    while ((c = in.read()) != -1)&#xA;        out.write(c);  &#xA;    in.close();&#xA;    out.close();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;一眼看上去，代码挺整齐的，逻辑也容易理解。但其中有一个很大的问题是，如果out.write调用失败（比如磁盘空间满了）方法异常退出，in.close()和out.close()就不会被调用，而in和out对象内部都引用了系统资源-&lt;a href=&#34;http://zh.wikipedia.org/wiki/文件描述符&#34;&gt;文件描述符&lt;/a&gt;，这样会导致文件描述符没有关闭，不能被重新使用而直到整个Java进程退出。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/File_descriptor&#34;&gt;File descriptor&lt;/a&gt;&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;Linux的每个进程（如：Java进程）都有一个文件描述符表管理当前进程访问的所有的文件，文件描述符关联了系统文件表中的file entry，系统能容纳多少file entry是有限制的，如果超过限制系统会拒绝访问，抛出Too many opened files错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://pbs.twimg.com/media/BEUt3v3CEAAeP-m.jpg:large&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;较为正确的代码应该是：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;private void copy(String src, String dest) throws IOException {&#xA;    FileInputStream in = null;  &#xA;    FileOutputStream out = null;  &#xA;    try {&#xA;        in = new FileInputStream(src);  &#xA;        out = new FileOutputStream(dest);  &#xA;        int c;  &#xA;        while ((c = in.read()) != -1)&#xA;            out.write(c);&#xA;    } finally {&#xA;         try {&#xA;             if (in!=null) {&#xA;                in.close();&#xA;             }&#xA;         } finally {&#xA;             if (out!=null) {&#xA;                out.close();&#xA;             }&#xA;         }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;但是这样的代码写起来是不是让人有点沮丧？这样写代码犯错的可能性确实比较大。&#xA;改良过后的代码阅读性好一些：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;private void copy(String src, String dest) throws IOException {&#xA;    FileInputStream in = null;  &#xA;    FileOutputStream out = null;  &#xA;    try {&#xA;        in = new FileInputStream(src);  &#xA;        out = new FileOutputStream(dest);  &#xA;        int c;  &#xA;        while ((c = in.read()) != -1)&#xA;            out.write(c);  &#xA;    } finally {&#xA;        FileUtils.close(in);&#xA;        FileUtils.close(out);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;让我们也看看在其他语言里是怎么实现的：&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Ruby：&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;def copy(src, dest)&#xA;    File.open(dest, &#39;w&#39;) do |f|  &#xA;        f.write(File.read(src))&#xA;    end  &#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Ruby的File.open 方法接受一个函数作为参数，执行该函数后，会保证打开的文件被关闭，即使在执行函数过程中有异常。相比之下这种代码优美多了有没有？&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Golang：&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func copy(src string, dest string) {&#xA;    src_file, err := os.Open(src)&#xA;    if err != nil { panic(err) }&#xA;    defer src_file.Close()&#xA;&#xA;    dest_file, err := os.Open(dest)&#xA;    if err != nil { panic(err) }&#xA;    defer dest_file.Close() &#xA;&#xA;    buf := make([]byte,1024)&#xA;&#xA;    for {&#xA;        n, err := src_file.Read(buf)&#xA;        if err != nil &amp;amp;&amp;amp; err != io.EOF { panic(err) }&#xA;        if n == 0 {break}&#xA;&#xA;        if _, err:= dest_file.Write(buf[:n]); err != nil {&#xA;           panic(err)&#xA;        } &#xA;    }       &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Go语言通过defer关键词来保证程序结束时相应的方法会被调用，嗯，你还是要显示的写Close()方法，但有一点改进就是你可以在打开后立刻写关闭语句，只要加上defer关键词。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Clojure：&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;defn copy[src dest] ( &#xA;   (with-open [rdr (reader src)&#xA;               wrtr (writer dest)]&#xA;      (doseq [line (line-seq rdr)]&#xA;          (.write wrtr line))))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Clojure通过with-open函数来保证打开的文件在异常情况下也会被关闭&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Java 7：&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;private void copy(String src, String dest) throws IOException {&#xA;    FileInputStream in = null;  &#xA;    FileOutputStream out = null;  &#xA;    try (FileInputStream in = new FileInputStream(src);  &#xA;         FileOutputStream out = new FileOutputStream(dest)) {            &#xA;        int c;  &#xA;        while ((c = in.read()) != -1)&#xA;            out.write(c);  &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;终于Java 7通过自动资源管理较好的解决了这个问题，try()代码块内的变量在离开时候会自动调用AutoCloseable接口必须实现的close()方法。java.lang.AutoCloseable接口是在Java 7内新增的。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;独占资源和并发访问&#34; href=&#34;#独占资源和并发访问&#34;&gt;&lt;/a&gt;独占资源和并发访问&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;锁&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;读写锁&lt;/h4&gt;&#xA;&#xA;&lt;h3&gt;信号量&lt;/h3&gt;&#xA;&#xA;&lt;h3&gt;连接池&lt;/h3&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;作业&#34; href=&#34;#作业&#34;&gt;&lt;/a&gt;作业&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;TODO：&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;参考链接&#34; href=&#34;#参考链接&#34;&gt;&lt;/a&gt;参考链接&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.oracle.com/technetwork/articles/java/trywithresources-401775.html&#34;&gt;Better Resource Management with Java SE 7: Beyond Syntactic Sugar&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>在Ubuntu上配置L2TP，PPTP和OpenVPN服务</title>
      <link>http://hugozhu.myalert.info/2013/03/01/setup-l2tp-pptp-openvpn-on-ubuntu.html</link>
      <pubDate>2013-03-01 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;overview&#34; href=&#34;#overview&#34;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;MacOS, Windows, iOS都内置支持PPTP，L2TP；OpenVPN需要安装客户端，手机上一般不支持。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;先打开内核的IP转发，修改 /etc/sysctl.conf&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;net.ipv4.ip_forward=1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;执行下面命令以生效&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo sysctl -p&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;pptp&#34; href=&#34;#pptp&#34;&gt;&lt;/a&gt;PPTP&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;安装pptpd&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;apt-get install pptpd&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;编辑 /etc/pptpd.conf，下面两行取消注释&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;localip 192.168.0.1&#xA;remoteip 192.168.0.234-238,192.168.0.245&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这行注释掉&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#logwtmp &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;从文件 /etc/pptpd.conf 中找到配置选项文件，如下为：/etc/ppp/pptpd-options&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;grep options /etc/pptpd.conf&#xA;#       Specifies the location of the PPP options file.&#xA;#       By default PPP looks in &#39;/etc/ppp/options&#39;&#xA;option /etc/ppp/pptpd-options&#xA;#       option in the pppd options file, or run bcrelay.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;编辑 /etc/ppp/pptpd-options，增加以下内容，最后两项为推给VPN客户端的DNS服务器IP&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;mtu 1492&#xA;name pptpd&#xA;refuse-pap&#xA;refuse-chap&#xA;refuse-mschap&#xA;require-mschap-v2&#xA;require-mppe-128&#xA;proxyarp&#xA;lock&#xA;nobsdcomp&#xA;novj&#xA;novjccomp&#xA;nologfd &#xA;ms-dns 8.8.8.8&#xA;ms-dns 8.8.4.4&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 /etc/ppp/chap-secrets， 增加一个VPN用户: foo ，密码设置为: bar&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# Secrets for authentication using CHAP&#xA;# client        server  secret                  IP addresses     &#xA;foo    pptpd   bar   *&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 iptable，注意eth0可能要修改成实际的网络接口名（用 ifconfig 可以列出）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;iptables -F&#xA;iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE&#xA;iptables -A INPUT -i lo -j ACCEPT&#xA;iptables -A INPUT -i tap+ -j ACCEPT&#xA;iptables -A INPUT -i tun+ -j ACCEPT&#xA;iptables -A FORWARD -i tap+ -j ACCEPT&#xA;iptables -A FORWARD -i tun+ -j ACCEPT&#xA;iptables -P FORWARD ACCEPT    &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;l2tp-over-ipsec&#34; href=&#34;#l2tp-over-ipsec&#34;&gt;&lt;/a&gt;L2TP Over IPSec&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;假设你的服务器IP是：&lt;strong&gt;1.2.3.4&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先更新一下源&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get update&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;安装openswan&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install openswan&#xA;&#xA;sudo cp /etc/ipsec.d/examples/l2tp-psk.conf /etc/ipsec.d/l2tp-psk.conf&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改文件 /etc/ipsec.d/l2tp-psk.conf&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;left=1.2.3.4 #机器的外部IP&#xA;leftnexthop=1.2.3.1 #机器的Gateway&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 /etc/ipsec.conf，在文件最后增加：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;include /etc/ipsec.d/l2tp-psk.conf&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 /etc/ipsec.secrets&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1.2.3.4 %any: &amp;quot;yourSharedPSK!&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;安装 xl2tpd&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;apt-get install xl2tpd&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 /etc/xl2tpd/xl2tpd.conf , 其中1.2.3.4改成服务器的外部IP&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[global]&#xA;ipsec saref = yes&#xA;listen-addr = 1.2.3.4&#xA;&#xA;[lns default]&#xA;ip range = 192.168.1.10-192.168.1.20&#xA;local ip = 192.168.1.1&#xA;;require chap = yes&#xA;refuse chap = yes&#xA;refuse pap = yes&#xA;require authentication = yes&#xA;ppp debug = yes&#xA;pppoptfile = /etc/ppp/xl2tpd-options&#xA;length bit = yes    &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;配置 /etc/ppp/xl2tpd-options&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cp /etc/ppp/options /etc/ppp/xl2tpd-options&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 /etc/ppp/xl2tpd-options&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;asyncmap 0&#xA;auth&#xA;crtscts&#xA;lock&#xA;hide-password&#xA;modem&#xA;mru 1280&#xA;netmask 255.255.255.0&#xA;mtu 1280&#xA;name l2tpd&#xA;proxyarp&#xA;lcp-echo-interval 30&#xA;lcp-echo-failure 4&#xA;noipx&#xA;ms-dns 8.8.8.8&#xA;ms-dns 8.8.4.4&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 /etc/ppp/chap-secrets， 增加一个VPN用户: foo ，密码设置为: bar&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# Secrets for authentication using CHAP&#xA;# client        server  secret                  IP addresses     &#xA;foo    l2tpd   bar   *&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 iptable，注意eth0可能要修改成实际的网络接口名（用 ifconfig 可以列出）, 其中1.2.3.4改成服务器的外部IP&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;iptables -F&#xA;iptables -A INPUT -p 50 -j ACCEPT&#xA;iptables -A INPUT -p udp -d 1.2.3.4 --dport 500 -j ACCEPT&#xA;iptables -A INPUT -p udp -d 1.2.3.4 --dport 4500 -j ACCEPT&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;openvpn&#34; href=&#34;#openvpn&#34;&gt;&lt;/a&gt;OpenVPN&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;安装Openvpn&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install openvpn    &#xA;&#xA;cp -r /usr/share/doc/openvpn/examples/easy-rsa/ /etc/openvpn/&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;生成CA证书&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cd /etc/openvpn/easy-rsa/2.0&#xA;source vars&#xA;./clean-all&#xA;./build-ca&#xA;./build-key-server server&#xA;./build-key client&#xA;./build-dh&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;编辑/etc/openvpn/server.conf&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;local 116.251.211.71    &#xA;port 56788    &#xA;proto tcp    &#xA;dev tun&#xA;ca /etc/openvpn/easy-rsa/2.0/keys/ca.crt&#xA;cert /etc/openvpn/easy-rsa/2.0/keys/server.crt&#xA;key /etc/openvpn/easy-rsa/2.0/keys/server.key      &#xA;dh  /etc/openvpn/easy-rsa/2.0/keys/dh1024.pem    &#xA;server 10.8.0.0 255.255.255.0    &#xA;ifconfig-pool-persist ipp.txt&#xA;push &amp;quot;redirect-gateway def1&amp;quot;    &#xA;push &amp;quot;dhcp-option DNS 8.8.8.8&amp;quot;&#xA;push &amp;quot;dhcp-option DNS 8.8.4.4&amp;quot;    &#xA;client-to-client&#xA;keepalive 10 120&#xA;comp-lzo    &#xA;max-clients 50    &#xA;user nobody&#xA;group nogroup    &#xA;persist-key&#xA;persist-tun    &#xA;status openvpn-status.log    &#xA;log-append  openvpn.log    &#xA;verb 3    &#xA;mute 20    &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;设置iptable，其中1.2.3.4改成服务器的外部IP&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;iptables -F&#xA;iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o venet0 -j MASQUERADE&#xA;&#xA;iptables -A INPUT -p tcp -m state --state NEW --dport 22 -j ACCEPT&#xA;iptables -t nat -A PREROUTING -p udp -m udp --dport 53 -j DNAT --to-destination 8.8.8.8&#xA;&#xA;iptables -A INPUT -p udp --dport 1194 -j ACCEPT&#xA;iptables -A INPUT -s 10.8.0.0/24 -p all -j ACCEPT&#xA;iptables -A FORWARD -d 10.8.0.0/24 -j ACCEPT&#xA;&#xA;iptables -A INPUT -i tun+ -j ACCEPT&#xA;iptables -A FORWARD -i tun+ -j ACCEPT&#xA;iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -j SNAT --to-source 1.2.3.4&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>在线广告系统架构变迁</title>
      <link>http://hugozhu.myalert.info/2013/02/28/the-evolution-of-online-advertsing-system.html</link>
      <pubDate>2013-02-28 12:00:00 +0800</pubDate>
      <description>&#xA;&#xA;&lt;p&gt;&lt;h1&gt;目录：&lt;/h1&gt;&lt;nav&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_0&#34;&gt;Overview&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_1&#34;&gt;从展示广告到搜索广告再到社会化广告&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_2&#34;&gt;广告系统的架构变迁&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_3&#34;&gt;接入大型广告网络&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_4&#34;&gt;Google AdSense&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_5&#34;&gt;阿里妈妈&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_6&#34;&gt;百度联盟&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_7&#34;&gt;使用第三方广告托管系统&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_8&#34;&gt;百度广告管家&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_9&#34;&gt;部署开源广告系统&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_10&#34;&gt;OpenX&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_11&#34;&gt;自主开发&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_12&#34;&gt;广告系统模块&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_13&#34;&gt;广告投放服务器&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_14&#34;&gt;K/V内存数据库&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_15&#34;&gt;关系数据库&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_16&#34;&gt;消息中间件&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_17&#34;&gt;CDN&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_18&#34;&gt;RPC框架&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_19&#34;&gt;流式分布式计算平台&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_20&#34;&gt;离线分布式计算平台&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/nav&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_0&#34;&gt;Overview&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;（未完）&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;广告按业务划分有以下几类：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;展示广告（Banner广告）&lt;/li&gt;&#xA;&lt;li&gt;搜索广告（关键词广告）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;按计费模式有：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;CPT: 按有效广告展示天数计费，可定价或竞价；&lt;/li&gt;&#xA;&lt;li&gt;CPM: 按有效广告展现次数计费，可定价或竞价；&lt;/li&gt;&#xA;&lt;li&gt;CPC: 按有效点击次数计费；&lt;/li&gt;&#xA;&lt;li&gt;CPS: 按效果计费，如，按成交订单额，按流量带来的有效下载或安装次数计费；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;广告系统按结构可划分为以下子系统：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;广告投送服务器&lt;/li&gt;&#xA;&lt;li&gt;广告数据库及业务系统&lt;/li&gt;&#xA;&lt;li&gt;用户行为跟踪系统&lt;/li&gt;&#xA;&lt;li&gt;日志传输系统&lt;/li&gt;&#xA;&lt;li&gt;流式数据分析和计算平台&lt;/li&gt;&#xA;&lt;li&gt;离线数据分析和计算平台&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_1&#34;&gt;从展示广告到搜索广告再到社会化广告&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;早期的互联网广告以展示广告为主，业务模式和在报纸，期刊上刊登广告相似，广告主按其广告的展现次数或时长来付费。直到1998年有个叫GoTo的公司（后公司改名为Overture，2005年被Yahoo收购）开始提供关键词广告，这是一种简单高效的定向广告，广告主可以按与其业务相关的关键词购买搜索流量，按访客的点击计费，和早期的展示广告相比这无疑是一个巨大的进步，通过关键词将用户和广告关联起来，而不是在广告位上一直展现同样的广告或随机的展现。随后Google迅速的采用了这个方法将自身的搜索流量变现，并不断优化和壮大，最终形成了Google的Adword产品，早期Google并不为搜索用户建立个性化数据，因此可用于定向的数据比较有限，于是Google又推出了AdSense产品，将触角伸向了全网，通过AdSense的合作网站，Google可以采集到访客在这些网站的访问足迹，并利用这些数据提高其广告的相关性；随着以Facebook为代表的社交网络的兴起，这些网站有个特点就是自身就具备了比较完善的用户个性化数据，利用这些数据，网站可以将定向技术使用到展示广告，这使展示广告迎来了第二春，广告产业对数据的应用价值有了极大的兴趣，也催化了大数据的技术广泛应用。近年来一种新的广告业务模式&amp;ndash;“实时竞价广告交易系统”也逐渐被网站主和广告主接受，其核心目的是让每次广告展现都创造出尽可能多的回报，以自动化的方式系统使用实时数据和竞价信息将广告空间分配给那一时刻出价最高的销售渠道。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_2&#34;&gt;广告系统的架构变迁&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;早期的展示广告系统因为业务数据量不大，广告位按时长售卖。系统架构上比较简单。系统核心为关系数据库，广告主通过业务系统管理广告数据：账户设置，广告计划，预算，推广单元，广告创意等；通过审核后可以投放的数据进入广告投放服务器。简单的广告系统可以完全围绕数据库来实现。投放服务器直接访问数据库获取需要投放的广告数据，并通过缓存来提高性能，减少对数据库的压力。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;图[简单的广告系统架构]&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当广告系统里的广告主越来越多，广告位的流量越来越大，直接访问数据库的做法不能满足性能和扩展性的要求，主要原因是传统的关系数据库的设计目标是通用的需求。这种情况下广告系统可以定时将广告数据从数据库中导出，生成的数据文件通过网络传到投放服务器，投放服务器将数据文件载入内存供快速访问，当用户打开网站页面时候，部署在广告位的代码（可部署在客户端或服务器端）将参数传给广告投放服务器，投放服务器按一定策略和逻辑取出需要展现给用户的广告数据，按接口规范直接返回给用户浏览器渲染，或返回给调用广告引擎的服务器端程序，再由服务器端程序将广告嵌入内容页面。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;图[改进后的简单的广告系统架构]&lt;/p&gt;&#xA;&#xA;&lt;p&gt;对于大多数中小网站，广告是其运营收入重要的一部分，在网站上部署广告一般有下面几种方法：&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_3&#34;&gt;接入大型广告网络&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;这是最简单的一种方式，不占用网站的服务器资源，只需要在网站广告位嵌入广告网络提供的广告代码即可。&lt;/p&gt;&#xA;&#xA;&lt;h3 id=&#34;toc_4&#34;&gt;Google AdSense&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Google AdSense 是一种获取收入的快速简便的方法，适合于各种规模的网站发布商。它可以在网站的内容网页上展示相关性较高的 Google广告，并且这些广告不会过分夸张醒目。由于这些所展示的广告内容同用户在您的网站上查找的内容相关，因此，最终您的内容网页不仅仅会为您带来很好的经济效益，还能够得以充实网站内容页面。google根据网站上显示的广告被点击的次数支付佣金，当某个月底佣金累计达到100美元时即可向发布商支付广告佣金。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Google AdSense开创了一个新的广告模式吧。以前的很多广告商，主要靠在各种页面，高频率的轰炸网友的眼球，而不管这个网友对广告内容是不是感兴趣。但是AdSense却通过分析网页内容后，提供一些和内容相关的文字广告（也会有个别图片广告），因为内容相关的广告更容易引起读者的兴趣，使广告成为一种真正有用的信息，而且也不会给网友太多的骚扰。&lt;/p&gt;&#xA;&#xA;&lt;h3 id=&#34;toc_5&#34;&gt;阿里妈妈&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;阿里妈妈是阿里巴巴集团旗下的网站联盟，将网站主与淘宝卖家之间搭起了一座桥梁，依托自身强大的技术研发能力，对商品实现今精准投放，不断改进投放内容与形式，让双方利益都得到最大化，营造了一个良性循环的生态圈。&lt;/p&gt;&#xA;&#xA;&lt;h3 id=&#34;toc_6&#34;&gt;百度联盟&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;百度联盟隶属于全球最大的中文搜索引擎百度。一直致力于帮助合作伙伴挖掘互联网流量的媒体价值，帮助推广客户拓展精准有效的投放通路，是现今国内颇具规模的广告联盟。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_7&#34;&gt;使用第三方广告托管系统&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;使用第三方广告托管系统相对于接入一个广告网络相比还可以展现自身的广告。&lt;/p&gt;&#xA;&#xA;&lt;h3 id=&#34;toc_8&#34;&gt;百度广告管家&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;百度广告管家是在线媒体广告管理系统，提供了广告投放管理、收益优化、定向投放、广告托管、广告数据统计报告等功能，几乎涵盖了目前所有网站站长的广告管理需求。登录百度广告管家，看到广告投放管理可以支持对固定、弹窗、漂浮三种类型的广告位投放的管理操作，并支持提供按地域、接入方式、日期、浏览器、浏览器语言、操作系统、来源域、分辨率、被访URL等定向投放方式的管理。广告计费方式提供按日、按展现、按点击三大主流计费方式。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_9&#34;&gt;部署开源广告系统&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;通过部署开源的广告系统可以对广告投放有较大的控制权，但为此需要消耗带宽和服务器成本，以及广告系统二次开发和维护成本。&lt;/p&gt;&#xA;&#xA;&lt;h3 id=&#34;toc_10&#34;&gt;OpenX&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;OpenX是一个用PHP开发的开源广告管理与跟踪系统，适合各类网站使用，能够管理每个广告主拥有的多种任何尺寸横幅广告，按天查看，详细和概要统计并通过电子邮件发送报表给广告主。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_11&#34;&gt;自主开发&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;大型的互联网公司一般会选择自主开发广告系统与自身业务相结合，如百度，淘宝。也有一些独立的广告联盟或新创的广告公司（如在无线广告领域）会选择自主开发。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_12&#34;&gt;广告系统模块&lt;/h1&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_13&#34;&gt;广告投放服务器&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;广告投放服务器的规模是和流量以及广告数据量成正比的。当广告数据规模较小时，一台服务器的内存就能放下所有数据，如果同时这台服务器也能承担所有广告请求流量，那投放系统就能简化到一台机器；如果一台服务器不能承担所有流量，那么可以复制出同样的多台服务器共同承担广告请求流量，并在这个集群前使用负载均衡设备将流量均匀的分配给集群内的服务器；如果数据量太大以致于单机存不下所有数据，那么可以将广告数据按一定维度分区，存在一组服务器上，这组服务器提供不同分区的访问，对外则通过统一的接口供访问，调用者首先根据分区维度的参数值确定该分区的服务器，再向该服务器直接调用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;随着软硬件的不断升级和优化，现代的普通商用服务器单台每秒可处理几千次的广告请求。在实现上选用高性能的Web服务器，如Nginx或Lighttpd，可以支撑大量并发连接，降低处理每个广告请求的系统消耗。如果对性能的有极端的要求，有些广告系统甚至会自主开发Web服务器（如采用Erlang，C语言等），或裁剪通用开源Web服务器不需要的功能，而只保留核心功能。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_14&#34;&gt;K/V内存数据库&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;广告投放服务器对性能要求非常高，从收到广告请求到返回广告数据只有十几毫秒的时间完成决策和数据封装，而数据在内存中的读取速度相对最快，所以在广告投放服务器中，需要投放的广告数据都会保存在基于K/V的内存数据库中供快速读取。内存数据库和关系数据库中的数据通过消息队列保持同步，开源的K/V数据库有Memcache和Redis等。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_15&#34;&gt;关系数据库&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;广告系统需要采用关系数据库来存储结构化的数据，如：广告计划，推广单元，创意等。这些是至关重要的核心数据，对数据安全性要求很高，要求即使在出现硬件损坏的情况下，客户的数据仍然能保证完整。业界一般采用两种方法存储这些核心数据：采用商业关系数据库如：Oracle，或采用开源数据库如：Mysql或Postgresql。商业数据库功能完善，但价格往往不菲，当广告系统规模变大后，成比例上升的软件成本不可小觑，所以会逐渐转向采用开源的Mysql，其高可用性则通过多个集群及实时复制技术来保证。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在广告系统中对广告数据的管理会通过一个或多个基于Web的应用来实现。通常采用J2EE或LAMP开发框架来开发。随着互联网广告的广泛和深入使用，广告的业务系统功能也越来越多且复杂，从架构上广告业务系统也朝着服务化和开放方向发展。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_16&#34;&gt;消息中间件&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;广告数据在关系数据库的更新需要反应到投放服务器中的内存数据库，从而更新访客看到的广告。一般来说广告主对数据同步的延迟是有一定要求的，现代的广告系统也越来越往实时同步方向发展。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_17&#34;&gt;CDN&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;对于带有图片或视频等富媒体内容的广告创意，为了让访客的浏览器能较快的下载广告内容，需要将这些内容文件放在离访客地理位置较近的服务器上，这正是CDN系统的优势，广告系统往往需要租用或自己搭建CDN系统。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_18&#34;&gt;RPC框架&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;大型广告系统在实现服务化后，需要进行分布式通信的服务器越来越多，采用较好的RPC框架，可使得系统各个模块之间的通信方法标准化, 简化业务开发。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;介绍一下Facebook开源的Thrift框架。Thrift是一种高效的、支持多种编程语言的远程服务调用的框架。互联网上比较流行的服务调用方式有很多种，例如基于 SOAP 消息格式的 Web Service，基于 JSON 消息格式的 RESTful 服务等。其中所用到的数据传输方式包括 XML，JSON 等，然而 XML 相对体积太大，传输效率低，JSON 体积较小，新颖，但还不够完善。Thrift则采用接口描述语言定义并创建服务，支持可扩展的跨语言服务开发，所包含的代码生成引擎可以在多种语言中，如 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, Smalltalk 等创建高效的、无缝的服务，其传输数据采用二进制格式，相对 XML 和 JSON 体积更小，对于高并发、大数据量和多语言的环境更有优势。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_19&#34;&gt;流式分布式计算平台&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Storm是Twitter开源出来的实时计算框架。可用于广告的防作弊，过滤无效展现PV和点击，也可用于实时广告费用结算等业务。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_20&#34;&gt;离线分布式计算平台&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;大型广告平台的数据量非常大，受众用户和网页都在亿级，广告量级在百万，而且数据之间还有各种关联关系，必须能通过一个分布式计算平台才能处理。Hadoop是Apache开源组织的一个大数据分布式计算框架，在很多大型网站上都已经得到了广泛的应用：如Amazon，Facebook和Yahoo，国内的阿里巴巴也建有节点超过千台的Hadoop集群，用于淘宝，支付宝，阿里金融等业务数据的分析。广告系统可以利用Hadoop分析广告展现日志和点击日志，计算每个广告在一定时间跨度内的展现量，点击量，有效展现，有效点击，平均点击消耗费用，转化率等广告主报表数据；有很多的算法计算都可以采用Hadoop平台来实现。Hadoop的核心思想是Map/Reduce模型，其计算流程类似于Unix的Pipe:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;input | map | shuffle &amp;amp; sort | reduce | output&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在Hadoop之上有Hive，Pig等简易数据分析接口，还有类Google Bigtable的开源实现HBase&amp;ndash;高可靠、高性能、面向列、可伸缩的分布式存储系统。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Java程序的日志</title>
      <link>http://hugozhu.myalert.info/2013/02/28/logging-in-java.html</link>
      <pubDate>2013-02-28 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;overview&#34; href=&#34;#overview&#34;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;一个在生产环境里运行的程序如果没有日志是很让维护者提心吊胆的，有太多杂乱又无意义的日志也是令人伤神。程序出现问题时候，从日志里如果发现不了问题可能的原因是很令人受挫的。本文想讨论的是如何在Java程序里写好日志。大多数的Web服务器（如Apache，Nginx）都有access日志和error日志，分别记录在不同的文件内；我们使用的服务器操作系统Linux有Syslog日志, /var/log目录下也有很多基础应用和服务的日志文件；桌面Windows有事件查看器, Mac有Console应用可以查看和管理日志；这些成熟的系统及工具方法都值得我们学习并在自己的项目中应用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一般来说日志分为两种：业务日志和异常日志。使用日志我们希望能达到以下目标：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;对程序运行情况的记录和监控；&lt;/li&gt;&#xA;&lt;li&gt;在必要时可详细了解程序内部的运行状态；&lt;/li&gt;&#xA;&lt;li&gt;对系统性能的影响尽量小；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;日志规范&#34; href=&#34;#日志规范&#34;&gt;&lt;/a&gt;日志规范&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;程序框架应该提供统一的日志记录接口，日志格式也需要有一定的规范，方便利用日志工具来分析日志。&#xA;首先我们有必要了解一下Linux普遍使用的&lt;a href=&#34;http://en.wikipedia.org/wiki/Syslog&#34;&gt;Syslog&lt;/a&gt;标准协议，协议规定日志中应包含产生日志的模块(Facility)，严重性（Severity Level），时间，主机名或IP，进程名，进程ID和日志内容，根据模块和严重性可以配置相应的动作：是否需要记录，日志存储路径（文件或网络）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面是部分常见的Syslog模块类型：&lt;/p&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;模块ID&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;关键词&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;0&lt;/td&gt;&#xA;&lt;td&gt;kern&lt;/td&gt;&#xA;&lt;td&gt;内核消息&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;1&lt;/td&gt;&#xA;&lt;td&gt;user&lt;/td&gt;&#xA;&lt;td&gt;用户级别消息&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;2&lt;/td&gt;&#xA;&lt;td&gt;mail&lt;/td&gt;&#xA;&lt;td&gt;邮件系统&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;3&lt;/td&gt;&#xA;&lt;td&gt;daemon&lt;/td&gt;&#xA;&lt;td&gt;系统后台守护程序&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;4&lt;/td&gt;&#xA;&lt;td&gt;auth&lt;/td&gt;&#xA;&lt;td&gt;安全/鉴权消息&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;5&lt;/td&gt;&#xA;&lt;td&gt;syslog&lt;/td&gt;&#xA;&lt;td&gt;syslogd内部产生的日志消息&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;…&lt;/td&gt;&#xA;&lt;td&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;以及Syslog严重程度划分：&lt;/p&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;严重程度&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;关键词&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;0&lt;/td&gt;&#xA;&lt;td&gt;Emergency&lt;/td&gt;&#xA;&lt;td&gt;emerg(panic)&lt;/td&gt;&#xA;&lt;td&gt;紧急，系统已经不稳定了&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;1&lt;/td&gt;&#xA;&lt;td&gt;Alert&lt;/td&gt;&#xA;&lt;td&gt;alert&lt;/td&gt;&#xA;&lt;td&gt;需要立刻采取措施&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;2&lt;/td&gt;&#xA;&lt;td&gt;Critical&lt;/td&gt;&#xA;&lt;td&gt;crit&lt;/td&gt;&#xA;&lt;td&gt;严重情况&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;3&lt;/td&gt;&#xA;&lt;td&gt;Error&lt;/td&gt;&#xA;&lt;td&gt;err (error)&lt;/td&gt;&#xA;&lt;td&gt;系统出错&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;4&lt;/td&gt;&#xA;&lt;td&gt;Warning&lt;/td&gt;&#xA;&lt;td&gt;warning(warn)&lt;/td&gt;&#xA;&lt;td&gt;系统警告&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;5&lt;/td&gt;&#xA;&lt;td&gt;Notice&lt;/td&gt;&#xA;&lt;td&gt;notice&lt;/td&gt;&#xA;&lt;td&gt;系统仍然正常，但值得注意&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;6&lt;/td&gt;&#xA;&lt;td&gt;Informational&lt;/td&gt;&#xA;&lt;td&gt;info&lt;/td&gt;&#xA;&lt;td&gt;正常系统通告&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;7&lt;/td&gt;&#xA;&lt;td&gt;Debug&lt;/td&gt;&#xA;&lt;td&gt;debug&lt;/td&gt;&#xA;&lt;td&gt;系统调试信息&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;在你的Java程序里日志也可以参考Syslog的设计，根据业务对程序的模块和日志级别做一定的规划和设计。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;java日志框架&#34; href=&#34;#java日志框架&#34;&gt;&lt;/a&gt;Java日志框架&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Java的日志框架太多了。。。&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://logging.apache.org&#34;&gt;&lt;strong&gt;Log4j&lt;/strong&gt;&lt;/a&gt; 或 &lt;a href=&#34;http://logging.apache.org/log4j/2.x/&#34;&gt;&lt;strong&gt;Log4j 2&lt;/strong&gt;&lt;/a&gt; - Apache的开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件、甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；用户也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，用户能够更加细致地控制日志的生成过程。这些可以通过一个配置文件（XML或Properties文件）来灵活地进行配置，而不需要修改程序代码。Log4j 2则是前任的一个升级，参考了Logback的许多特性；&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://logback.qos.ch&#34;&gt;&lt;strong&gt;Logback&lt;/strong&gt;&lt;/a&gt; - Logback是由log4j创始人设计的又一个开源日记组件。logback当前分成三个模块：logback-core,logback- classic和logback-access。logback-core是其它两个模块的基础模块。logback-classic是log4j的一个改良版本。此外logback-classic完整实现SLF4J API使你可以很方便地更换成其它日记系统如log4j或JDK14 Logging；&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/javase/6/docs/api/java/util/logging/package-summary.html&#34;&gt;&lt;strong&gt;java.util.logging&lt;/strong&gt;&lt;/a&gt; - JDK内置的日志接口和实现，功能比较简单&amp;hellip;；&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.slf4j.org&#34;&gt;&lt;strong&gt;Slf4j&lt;/strong&gt;&lt;/a&gt; - SLF4J是为各种Logging API提供一个简单统一的接口），从而使用户能够在部署的时候配置自己希望的Logging API实现；&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://commons.apache.org/proper/commons-logging/&#34;&gt;&lt;strong&gt;Apache Commons Logging&lt;/strong&gt;&lt;/a&gt; - Apache Commons Logging （JCL）希望解决的问题和Slf4j类似。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;选项太多了的后果就是选择困难症，我的看法是没有最好的，只有最合适的。在比较关注性能的地方，选择Logback或自己实现高性能Logging API可能更合适；在已经使用了Log4j的项目中，如果没有发现问题，继续使用可能是更合适的方式；我一般会在项目里选择使用Slf4j, 如果不想有依赖则使用java.util.logging或框架容器已经提供的日志接口。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;java日志最佳实践&#34; href=&#34;#java日志最佳实践&#34;&gt;&lt;/a&gt;Java日志最佳实践&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;定义日志变量&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;日志变量往往不变，最好定义成final static，变量名用大写。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;日志分级&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Java的日志框架一般会提供以下日志级别，缺省打开info级别，也就是debug，trace级别的日志在生产环境不会输出，在开发和测试环境可以通过不同的日志配置文件打开debug级别。&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;fatal&lt;/strong&gt; - 严重的，造成服务中断的错误；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;error&lt;/strong&gt; - 其他错误运行期错误；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;warn&lt;/strong&gt; -  警告信息，如程序调用了一个即将作废的接口，接口的不当使用，运行状态不是期望的但仍可继续处理等；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;info&lt;/strong&gt; -  有意义的事件信息，如程序启动，关闭事件，收到请求事件等；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;debug&lt;/strong&gt; - 调试信息，可记录详细的业务处理到哪一步了，以及当前的变量状态；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;trace&lt;/strong&gt; - 更详细的跟踪信息；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;在程序里要合理使用日志分级:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//调试的时候可以知道进入了方法&#xA;LOGGER.debug(&amp;quot;entering getting content&amp;quot;);&#xA;String content = CacheManager.getCachedContent();&#xA;if (content == null) {&#xA;&#xA;    //使用warn，因为程序还可以继续执行，但类似警告太多可能说明缓存服务不可用了，值得引起注意&#xA;    LOGGER.warn(&amp;quot;Got empty content from cache, need perform database lookup&amp;quot;); &#xA;&#xA;    Connection conn = ConnectionFactory.getConnection();&#xA;    if (conn == null) {&#xA;        LOGGER.error(&amp;quot;Can&#39;t get database connection, failed to return content&amp;quot;); //尽量提供详细的信息，知道错误的原因，而不能简单的写logger.error(&amp;quot;failed&amp;quot;)&#xA;    } else {&#xA;        try {&#xA;            content = conn.query(...);&#xA;        } catch (IOException e) {&#xA;            //异常要记录错误堆栈&#xA;            LOGGER.error(&amp;quot;Failed to perform database lookup&amp;quot;, e);&#xA;        } finally {&#xA;            ConnectionFactory.releaseConnection(conn);&#xA;        }&#xA;    }&#xA;}&#xA;//调试的时候可以知道方法返回了&#xA;LOGGER.debug(&amp;quot;returning content: &amp;quot;+ content);&#xA;return content;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上面这段示范代码演示了各种级别的使用，但其中有个问题是debug日志太多后可能会影响性能？有一种改进方法是：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if (LOGGER.isDebugEnabled()) {&#xA;    LOGGER.debug(&amp;quot;returning content: &amp;quot;+ content);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;但更好的方法是Slf4j提供的&lt;a href=&#34;http://www.slf4j.org/faq.html#logging_performance&#34;&gt;最佳实践&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;LOGGER.debug(&amp;quot;returning content: {}&amp;quot;, content);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;一方面可以减少参数构造的开销，另一方面也不用多写两行代码；&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;有意义的日志&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;通常情况下在程序日志里记录一些比较有意义的状态数据：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;程序启动，退出的时间点；&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;程序运行消耗时间；&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;long startTime = System.currentTime();          &#xA;// business logical          &#xA;LOGGER.info(&amp;quot;execution cost : &amp;quot; + (System.currentTime() - startTime) + &amp;quot;ms&amp;quot;);　      &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;耗时程序的执行进度，不然程序开始运行后半天没一点输出挺让人着急啊~&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;重要变量的状态变化。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;日志安全&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;日志中尽量不要包含敏感信息，对于敏感信息如用户身份证号码，密码可以加密后存储；以防止日志文件不慎外泄时保全用户的数据安全；日志通常不允许修改，必要时还可以通过校验位来鉴别日志是否正确。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;日志监控方法&#34; href=&#34;#日志监控方法&#34;&gt;&lt;/a&gt;日志监控方法&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;错误日志需要设置监控才能及时发现问题，所以在程序里记录日志的时候也需要考虑这点。&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;错误次数&lt;/li&gt;&#xA;&lt;li&gt;错误等级&lt;/li&gt;&#xA;&lt;li&gt;错误关联的数据&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;应用名&lt;/li&gt;&#xA;&lt;li&gt;用户ID&lt;/li&gt;&#xA;&lt;li&gt;时间&lt;/li&gt;&#xA;&lt;li&gt;IP&lt;/li&gt;&#xA;&lt;li&gt;发生错误的页面&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;作业&#34; href=&#34;#作业&#34;&gt;&lt;/a&gt;作业&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;TODO：&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;参考链接&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.slf4j.org/manual.html&#34;&gt;http://www.slf4j.org/manual.html&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://commons.apache.org/proper/commons-logging//guide.html#JCL_Best_Practices&#34;&gt;http://commons.apache.org/proper/commons-logging//guide.html#JCL_Best_Practices&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://wikipedia.org/wiki/syslog&#34;&gt;http://wikipedia.org/wiki/syslog&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>使用Github合作开发项目</title>
      <link>http://hugozhu.myalert.info/2013/02/27/collaborating-development-with-github.html</link>
      <pubDate>2013-02-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;本文大部分内容来自： &lt;a href=&#34;https://help.github.com/categories/63/articles&#34;&gt;https://help.github.com/categories/63/articles&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Github上合作开发最好的方式是“&lt;strong&gt;Fork + Pull Request&lt;/strong&gt;”。比如我最近需要一个静态Blog生成器，市面上有很多Ruby实现的，但我想要一个Go语言的实现，Github上找到了一个 &lt;a href=&#34;https://github.com/wendal/gor&#34;&gt;https://github.com/wendal/gor&lt;/a&gt; ，测试了一下已有的功能基本能满足了，就用上了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但实际使用过程中发现了一个问题，如果在URL中有中文，生成的URL如下没有做URL安全编码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;http://hugozhu.myalert.info/2013/02/27/在Pi和Github上搭建自己的个人博客.html&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;还有一种情况是如果URL中有空格，如：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;http://hugozhu.myalert.info//2013//02/25/Java properties to enviorment variables.html&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;浏览器遇到这种URL时，会主动进行编码，但这里有两个问题：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;遇到中文时，浏览器是用GBK还是UTF-8还是其它字符集编码后再发送给服务器呢？&lt;/li&gt;&#xA;&lt;li&gt;遇到空格时，编码成+还是%20呢？&#xA;不同浏览器实现可能不一样，在不同操作系统上也可能不一样（可能和用户设置的缺省语言有关），这样有些用户可能会遭遇404错误了，实际上我在服务器的错误日志上的确看到这样的错误&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;日志：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;2013/02/27 20:41:33 [error] 7791#0: *3285 open() &amp;quot;.../2013/02/25/Java+properties+to+enviorment+variables.html&amp;quot; failed (2: No such file or directory), client: 221.179.193.78, server: hugozhu.myalert.info, request: &amp;quot;GET /2013/02/25/Java+properties+to+enviorment+variables.html HTTP/1.1&amp;quot;, host: &amp;quot;hugozhu.myalert.info&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;于是我需要动手修改代码：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;首先需要做的就是Fork一下原项目到自己的代码仓库： &lt;a href=&#34;https://github.com/hugozhu/gor&#34;&gt;https://github.com/hugozhu/gor&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;修改好代码并提交到自己的仓库： &lt;a href=&#34;https://github.com/hugozhu/gor/commit/db2784623d9df4d0652436efdbfbb9caccdc1e1d&#34;&gt;https://github.com/hugozhu/gor/commit/db2784623d9df4d0652436efdbfbb9caccdc1e1d&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;在你的代码仓库页面上点Pull Request:&#xA;&lt;img src=&#34;https://pbs.twimg.com/media/BEH7V0vCYAAMgcl.jpg:large&#34;/&gt;&lt;/li&gt;&#xA;&lt;li&gt;选择好你刚提交好的Commits，然后点发送;&lt;/li&gt;&#xA;&lt;li&gt;原项目的维护者就会收到这个Pull Request: &lt;a href=&#34;https://github.com/wendal/gor/pull/14&#34;&gt;https://github.com/wendal/gor/pull/14&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;如果你提交的代码足够好，维护者可以合并到项目主干上；&lt;/li&gt;&#xA;&lt;li&gt;记住下一次本地修改代码前要先Merge一下原作者新提交的改动;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git remote add upstream https://github.com/wendal/gor&#xA;git fetch upstream&#xA;git checkout master&#xA;git merge upstream/master &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;到此为止就完成了一次合作开发。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;==&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;我们日常的项目开发中也可以采用这种思路，代码Review也可以增加Pull Request，对项目的迭代速度会有很大帮助。&lt;/h1&gt;&#xA;</description>
    </item>
    <item>
      <title>在Pi和Github上搭建自己的个人博客</title>
      <link>http://hugozhu.myalert.info/2013/02/27/%E5%9C%A8Pi%E5%92%8CGithub%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html</link>
      <pubDate>2013-02-27 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;方法如下：&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;本站同时托管在家里的&lt;a href=&#34;http://www.raspberrypi.org&#34;&gt;Raspberry Pi&lt;/a&gt;和&lt;a href=&#34;http://pages.github.com/&#34;&gt;Github Pages&lt;/a&gt;上，并同步保持更新，海外用户会访问Github，国内用户则会访问Pi，不同线路解析域名&lt;strong&gt;hugozhu.myalert.info&lt;/strong&gt;到不同的服务器是通过&lt;a href=&#34;http://dnspod.cn&#34;&gt;DnsPod&lt;/a&gt;的服务实现的，这么好的服务还是免费的，这里推荐一下。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因为Github Pages只能支持静态网页，你需要一个能生成静态网页的博客生成引擎。我使用的是&lt;a href=&#34;http://github.com/wendal/gor&#34;&gt;gor&lt;/a&gt; ， 也可以使用&lt;a href=&#34;http://ruhoh.com&#34;&gt;ruhoh&lt;/a&gt;，&lt;a href=&#34;https://www.google.com/search?q=static+blog+generator&amp;amp;hl=en&amp;amp;newwindow=1&amp;amp;client=safari&amp;amp;rls=en&amp;amp;biw=1238&amp;amp;bih=868&amp;amp;ei=msAuUY-vDMKO2AWQ7IHoBQ&amp;amp;sqi=2&amp;amp;start=10&amp;amp;sa=N&#34;&gt;Google一下还有很多&lt;/a&gt;。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;静态页面博客的好处：&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;性能是最好的，很合适用Raspberry Pi来做服务器，节省资源；&lt;/li&gt;&#xA;&lt;li&gt;文章可以用Markdown格式来编写，采用Github来做版本控制，我的Blog仓库在 &lt;a href=&#34;http://github.com/hugozhu/blog&#34;&gt;http://github.com/hugozhu/blog&lt;/a&gt; ，数据安全很好，误删除也不担心了；&lt;/li&gt;&#xA;&lt;li&gt;很容易找到托管环境，方便迁移；&lt;/li&gt;&#xA;&lt;li&gt;用Gor在Pi上生成速度很快；再用Nginx提供Web服务，可以直接在Pi上写Blog；&lt;/li&gt;&#xA;&lt;li&gt;大繁至简&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;Github设置&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在你的仓库里增加一个your_github_id.github.com，比如我的github ID是hugozhu，相应的仓库名就是&lt;a href=&#34;https://github.com/hugozhu/hugozhu.github.com&#34;&gt;hugozhu.github.com&lt;/a&gt;，这个仓库也就是网站的根目录了，在这里放生成好的静态文件&lt;/li&gt;&#xA;&lt;li&gt;如果你需要用自己的域名，而不是Github提供的，可以在根目录下增加一个&lt;a href=&#34;https://github.com/hugozhu/hugozhu.github.com/blob/master/CNAME&#34;&gt;CNAME&lt;/a&gt;文件,文件内容则是你的域名，在DnsPod上需要建一个CNAME记录，将你的域名指向your_github_id.github.com. 也就是github原来分配给你的，完成这个设置后，访问your_github_id.github.com会跳转到你的域名；&lt;/li&gt;&#xA;&lt;li&gt;每次更新后，Github会在10分钟内生效。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;更新博客&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Gor的使用详细说明可见 &lt;a href=&#34;https://github.com/wendal/gor&#34;&gt;https://github.com/wendal/gor&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;我的整个网站的内容也通过Github开源了: &lt;a href=&#34;https://github.com/hugozhu/blog&#34;&gt;https://github.com/hugozhu/blog&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;以我的网站为例：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/hugozhu/blog&#xA;    Cloning into &#39;blog&#39;...&#xA;    remote: Counting objects: 190, done.&#xA;    remote: Compressing objects: 100% (146/146), done.&#xA;    remote: Total 190 (delta 81), reused 132 (delta 23)&#xA;    Receiving objects: 100% (190/190), 155.48 KiB | 171 KiB/s, done.&#xA;    Resolving deltas: 100% (81/81), done.&#xA;cd blog&#xA;gor compile&#xA;    2013/02/27 13:17:19 gor.go:21: gor ver 2.1&#xA;    2013/02/27 13:17:19 payload.go:572: Load Layout : default&#xA;    2013/02/27 13:17:19 payload.go:572: Load Layout : page&#xA;    2013/02/27 13:17:19 payload.go:572: Load Layout : post&#xA;    2013/02/27 13:17:19 config.go:61: Look lile a Json, try it&#xA;    2013/02/27 13:17:19 config.go:64: It is Json Map&#xA;    2013/02/27 13:17:19 widgets.go:111: Load widget from  widgets/analytics/config.yml&#xA;    2013/02/27 13:17:19 widgets.go:111: Load widget from  widgets/comments/config.yml&#xA;    2013/02/27 13:17:19 widgets.go:111: Load widget from  widgets/google_prettify/config.yml&#xA;    2013/02/27 13:17:19 compile.go:125: Done&#xA;cd compiled&#xA;git init&#xA;git add -A &#xA;git commit -m &amp;quot;update website&amp;quot; .&#xA;git remote add origin hugozhu@github.com:hugozhu/hugozhu.github.com&#xA;git push -u origin master&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;最后等待10分钟，再打开 &lt;a href=&#34;http://hugozhu.github.com&#34;&gt;http://hugozhu.github.com&lt;/a&gt; 就好了。。。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Raspberry Pi设置&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;安装nginx&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install nginx&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改文件：/etc/nginx/sites-enabled/default，增加下面内容&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;server {&#xA;    server_name hugozhu.myalert.info;&#xA;&#xA;    root /home/pi/blog/compiled;&#xA;&#xA;    location / {&#xA;        ssi on;&#xA;    }     &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;重新启动nginx，这样在Pi上也有一个你的个人博客了，方便自己访问，这里有个小小的技巧是可以通过server side include给静态页面增加动态内容，上面的配置在首页上打开了此功能，这样我可以在页底加上如下代码来显示访问者的IP&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;!--# echo var=&amp;quot;remote_addr&amp;quot; default=&amp;quot;no&amp;quot; --&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;最后重启Nginx生效&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo /etc/init.d/nginx restart&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;TODO:&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;实现一个简单的Web界面，可以通个Web界面来保存Blog，并重现编译和更新到Github；&#xA;&amp;gt; 已部分实现：在Github的博客仓库里可以直接创建或修改文件，用Go写了一个HTTP接口，curl一下后可更新，&lt;/li&gt;&#xA;&lt;li&gt;微博到博客的快速发布；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>系统调试和分析工具</title>
      <link>http://hugozhu.myalert.info/2013/02/26/linux_perf_tools.html</link>
      <pubDate>2013-02-26 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Linux下的调试和分析工具集&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/tools.jpg&#34; width=&#34;600&#34;/&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>动态DNS程序</title>
      <link>http://hugozhu.myalert.info/2013/02/26/dynamic-dns-script.html</link>
      <pubDate>2013-02-26 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;动态根据宽带public ip更新dnspod登记的域名&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;按照 &lt;a href=&#34;https://gist.github.com/833369&#34;&gt;https://gist.github.com/833369&lt;/a&gt; 逻辑重新用Go实现了，用更少的内存开销在Raspberry Pi上跑。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;替换上你的Email，密码，域名ID，记录ID等参数，就可以运行了。 会在后台一直运行，每隔30秒检查一遍IP，如果修改了就更新IP。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;获得domain_id可以用：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;curl curl -k https://dnsapi.cn/Domain.List -d &amp;quot;login_email=xxx&amp;amp;login_password=xxx&amp;quot; &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;获得record_id：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;curl -k https://dnsapi.cn/Record.List -d &amp;quot;login_email=xxx&amp;amp;login_password=xxx&amp;amp;domain_id=xxx&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;script src=&#34;https://gist.github.com/hugozhu/6506189.js&#34;&gt;&lt;/script&gt;&#xA;</description>
    </item>
    <item>
      <title>将Java的Properties文件转换成环境变量</title>
      <link>http://hugozhu.myalert.info/2013/02/25/Java%20properties%20to%20enviorment%20variables.html</link>
      <pubDate>2013-02-25 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;overview&#34; href=&#34;#overview&#34;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;在Java程序中使用properties文件很方便，但有时候需要和脚本配合使用时，需要把properties文件内的多个变量转换成环境变量，本文提供一个转换脚本示范：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;比如env.properties如下（=附近可以有空格，也可以有空行）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;MYSQL_URL = jdbc:mysql://localhost:3306/test?autoReconnect=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=gbk&#xA;MYSQL_USER = root&#xA;MYSQL_PASS = &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;执行下面的脚本后就相当于&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;export MYSQL_URL=&amp;quot;//localhost:3306/test?autoReconnect=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=gbk&amp;quot;&#xA;export MYSQL_USER=&amp;quot;root&amp;quot;&#xA;export MYSQL_PASS=&amp;quot;&amp;quot; &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;env.sh脚本代码&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/bin/bash&#xA;&#xA;property_file=env.properties&#xA;&#xA;get_prop(){&#xA;    propfile=$1&#xA;    key=$2&#xA;    grep  &amp;quot;^${2}=&amp;quot; ${1}| sed &amp;quot;s%${2}=\(.*\)%\1%&amp;quot;&#xA;}&#xA;&#xA;trim() {&#xA;    trimmed=$1&#xA;    trimmed=${trimmed%% }&#xA;    trimmed=${trimmed## }&#xA;    echo &amp;quot;$trimmed&amp;quot;&#xA;}&#xA;&#xA;`grep -v &amp;quot;^#&amp;quot; $property_file | sed -e &#39;/^$/d&#39; | while read line&#xA;do&#xA;    key=$(echo $line | awk -F &amp;quot;=&amp;quot; &#39;{print $1}&#39;)&#xA;    trimmed_key=$(trim $key)&#xA;    trimmed_val=$(trim $(get_prop $property_file &amp;quot;$key&amp;quot;)&#xA;    echo &amp;quot;export $trimmed_key=\&amp;quot;$trimmed_val\&amp;quot;)&amp;quot;&#xA;done`&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>我的第一篇博客</title>
      <link>http://hugozhu.myalert.info/2012/new-born.html</link>
      <pubDate>2012-12-22 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;感谢使用Gor编写博客&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;本文位于 posts/first-blog.md , 你可以任何删掉,修改这个文件&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;文件开头是当前文章的元数据&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;date为自动生成, 当然,你可以修改,这是你的自由&lt;/li&gt;&#xA;&lt;li&gt;permalink 可以是固定地址,也可以由gor为你自动生成&lt;/li&gt;&#xA;&lt;li&gt;categories 就是分类, 可以多个&lt;/li&gt;&#xA;&lt;li&gt;tags 同理,多个标签也是很常见的&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;请确保文件使用UTF8 without BOM编码&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;你可以通过执行下面的语句来新建一篇博客:&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gor post 文章标题&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;编译你的博客,并预览之&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gor compile #编译&#xA;gor http&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后打开你的浏览器,访问 &lt;a href=&#34;http://127.0.0.1:8080&#34;&gt;http://127.0.0.1:8080&lt;/a&gt; 来预览&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;你将使用Markdown来编写博客&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://wowubuntu.com/markdown/&#34;&gt;Markdown 语法中文版&lt;/a&gt; 能让你快速入门其语法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相信&lt;a href=&#34;http://markdownpad.com&#34;&gt;MarkdownPad&lt;/a&gt;或&lt;a href=&#34;http://code.google.com/p/liteide/&#34;&gt;liteide&lt;/a&gt;会是你的编写博客的好帮手&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;如果你打算部署到github的pages上&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;申请github帐户&lt;/li&gt;&#xA;&lt;li&gt;新建一个库 username.github.com 即你的用户名命名的地址&lt;/li&gt;&#xA;&lt;li&gt;将compiled目录,作为根路径,提交上去github.com上&lt;/li&gt;&#xA;&lt;li&gt;稍等几分钟, 你即可通过 &lt;a href=&#34;http://username.github.com&#34;&gt;http://username.github.com&lt;/a&gt; 访问到&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;附上git教程 &lt;a href=&#34;http://gitbook.liuhui998.com/&#34;&gt;GitBook中文版&lt;/a&gt;&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;一般来说,你只需要几个简单的git命令就足以应付大部分需求(仅示例)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git clone git://github.com/wendal/wendal.net.git&#xA;git add -A&#xA;git commit -m &amp;quot;...&amp;quot;&#xA;git pull&#xA;git push&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;用gor编写博客将会是一件很开心的事,如果有任何意见或建议,欢迎到 &lt;a href=&#34;http://github.com/wendal/gor&#34;&gt;gor的官网&lt;/a&gt; 提交issue&lt;/h2&gt;&#xA;&#xA;&lt;h1&gt;祝你使用愉快&lt;/h1&gt;&#xA;</description>
    </item>
  </channel>
</rss>